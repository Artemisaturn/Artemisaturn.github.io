<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MPM</title>
    <link href="/2021/09/06/MPM/"/>
    <url>/2021/09/06/MPM/</url>
    
    <content type="html"><![CDATA[<h1 id="2013-A-material-point-method-for-snow-simulation"><a href="#2013-A-material-point-method-for-snow-simulation" class="headerlink" title="2013-A material point method for snow simulation"></a>2013-A material point method for snow simulation</h1><p>提出了一种用户能控制的弹塑性本构模型集成一种混合欧拉-拉格朗日MPM方法，以模拟雪。</p><p>该方法基于连续统一体并且它的自然性质允许我们使用一个规则的笛卡尔网格自动处理自碰撞和断裂。</p><p>推导出一个基于网格的半隐式积分方案，该方案具有独立于拉格朗日粒子数的条件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>surface tension</title>
    <link href="/2021/07/13/surface-tension/"/>
    <url>/2021/07/13/surface-tension/</url>
    
    <content type="html"><![CDATA[<h1 id="Versatile-Surface-Tension-and-Adhesion-for-SPH-Fluids"><a href="#Versatile-Surface-Tension-and-Adhesion-for-SPH-Fluids" class="headerlink" title="Versatile Surface Tension and Adhesion for SPH Fluids"></a>Versatile Surface Tension and Adhesion for SPH Fluids</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一种新的表面张力和粘附力：可以处理很大的表面张力，防止自由表面的粒子聚集，最小化表面曲率；粘附力允许流固双向吸引，可以模拟不同的湿润条件；建模表面张力和粘附力不需要生成幽灵空气粒子或表面追踪；作用于流-流和流-固粒子对间的力是对称的，满足动量守恒。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>表面张力，由相邻流体分子之间的内聚力引起；</p><p>在流体内部，每个分子都被其邻居分子同等地吸引，所以合力为零；</p><p>然而，自由表面不是所有方向都有邻居粒子，这些区域的分子被向内牵引；</p><p>根据拉普拉斯定律，表面张力使表面积最小化，当排除外力时，水滴成球形。</p><p>另一个同样由分子间相互作用引起的效应是粘附力，使流体被其他材质吸引。</p><p>存在问题：</p><p>​        在SPH中，气-液和流-固界面上出现的一个重要问题是密度低估，错误的密度值会导致负的压力，造成粒子聚集；称为张力不稳定性。</p><p>解决方法：</p><p>​    （1）使用人工压力（但会导致虚假的表面张力）</p><p>​    （2）使用密度校正技术，或简单地不允许负压力（仍然没有解决流体界面黏附粒子的问题）</p><p>​    （3）通过为固体边界预先计算单层边界粒子来解决流-固界面的问题</p><p>为了模拟表面张力：计算基于曲率的粒子外力；基于内聚力的对称性力；修正的SPH公式；基于表面网格曲率的力</p><p>固-液粘附力建模：使用基于距离的吸引力；结合幽灵固体粒子和XSPH</p><hr><h3 id="Surface-Tension-in-Fluid-Simulation"><a href="#Surface-Tension-in-Fluid-Simulation" class="headerlink" title="Surface Tension in Fluid Simulation"></a>Surface Tension in Fluid Simulation</h3><p>早期的表面张力技术关注于施加力最小化表面曲率；</p><p>计算每个粒子的法线，从而确定力的方向，通过光滑颜色场的梯度来计算；</p><p>力的大小基于粒子位置的曲率，可以通过光滑颜色场的二阶导数或法线场的散度来计算。</p><p>存在的问题：</p><p>​    （1）流体内部的粒子，归一化光滑颜色场梯度会导致内部粒子的任意法线（通过将表面张力施加到光滑颜色场梯度大小 &gt; 阈值的粒子上，避免此问题，但会导致不连续的力）；</p><p>​    （2）由于需要二阶导数，曲率估计对粒子无序非常敏感；</p><p>​    （3）力以非对称的方式作为外力施加到流体粒子上，不能保持动量守恒。</p><p>新方法（1）</p><p>在分子水平上解决表面张力问题：使用相邻流体粒子间的内聚力。</p><p>优势：避免了法线计算和错误的曲率估计；所施加的力是对称性的，保持动量守恒。</p><p>缺点：仅使用流体粒子间的内聚力不能保证表面积最小化，大的内聚力会导致不真实的流体效果</p><p>新方法（2）</p><p>在邻居流体粒子间施加吸引力以产生表面张力，基本的SPH方法使用双密度松弛重制，其中表面张力是基于自由表面产生的负压计算的。</p><p>缺点：由于表面张力作为副作用出现，不同的表面张力行为不能用此方法来模拟，并且，没有考虑表面积最小化。</p><p>新方法（3）</p><p>曲率在流体表面网格上估计，产生的表面张力被施加到相邻的流体粒子上</p><p>优势：当表面网格比流体有更多的样本时（即比粒子有更多的顶点），曲率计算不像从粒子计算曲率那样容易出错</p><p>缺点：1、所采用的表面跟踪方案可能无法检测网格分辨率粗糙的区域中的独立流体块；2、表面张力的质量取决于跟踪的网格分辨率；3、在每个模拟步骤中要求流体表面显式表示，对于不需要显式表面的情况是一种额外开销</p><hr><h3 id="Solid-Adhesion-in-Fluid-Simulation"><a href="#Solid-Adhesion-in-Fluid-Simulation" class="headerlink" title="Solid Adhesion in Fluid Simulation"></a>Solid Adhesion in Fluid Simulation</h3><p>一种完全拉格朗日方法来模拟粘性液体，包括对固体的粘附：使用距离相关的力来定义不同类型材料的粘附特性；然而，所采用的线密度核和严格的防渗透约束限制了它们对高粘性液体的处理。</p><p>粘弹性SPH流体对固体的粘附通过使用基于距离的吸引力项来建模，该吸引力项作为流体粒子的脉冲被添加。</p><p>流体对固体的粘附通过结合固体自身的速度和最近的流体粒子速度的切向分量来计算每个固体粒子的幽灵速度来实现，在这个步骤之后，使用基于XSPH的人工粘度项产生流体对固体的粘附。</p><hr><h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><p>本文提出了一个表面张力和一个流-固粘附力来改善SPH中气-液和流-固界面的处理。</p><p>本文的表面张力方法可以在保持动量的同时，通过最小化所有尺度的表面积来处理大的表面张力。</p><p>此外，本文的表面张力还会对近距离产生排斥力，这可以防止自由表面上的粒子聚集，而不需要额外的处理，例如产生幽灵空气粒子或人工压力。</p><p>本文的粘附力允许物理上合理的固液粘附效果，而不需要额外的处理，如幽灵SPH。</p><p>此外，本文的方法允许模拟有趣的现象，如不同的润湿效果和双向粘附。</p><p>本文的两种力可以很容易地添加到现有的SPH求解器中，作为额外的力项。</p><p>通过结合本文的表面张力和粘附力，能够模拟自然界中可以观察到的各种效果。</p><h2 id="Surface-Tension-Model"><a href="#Surface-Tension-Model" class="headerlink" title="Surface Tension Model"></a>Surface Tension Model</h2><p>流体的表面张力源自分子的内聚力；</p><p>增大只有cohesion的表面张力，可能导致像蜘蛛网一样的流体结构，因为仅依靠分子间内聚力不能最小化流体的表面积，反而会加强已存在的结构。</p><p>只考虑曲率最小化项，也不行，会导致更严重的粒子聚集，液滴破碎成许多更小的液滴。</p><p>所以，同时考虑分子内聚力和表面积最小化。</p><h3 id="Cohesion-Term"><a href="#Cohesion-Term" class="headerlink" title="Cohesion Term"></a>Cohesion Term</h3><p>最初用分子内聚力产生表面张力：调整余弦函数，对远处的粒子产生吸引力，对近处的粒子产生排斥力；</p><p>邻居粒子非常接近时斥力消失，导致粒子聚集。</p><p>用SPH核函数代替余弦函数：缺少排斥项，导致粒子严重聚集。</p><p>本文内聚力模型：距离d &gt; 静态距离h/2，&lt; 支持半径h时，吸引力平滑减小到0；d&lt;h/2时，力平滑地减小到负值，避免粒子聚集。并且粒子过近，排斥力不会消失，也不会一直增加，避免斥力太强产生不稳定问题。</p><h3 id="Surface-Area-Minimization-Term"><a href="#Surface-Area-Minimization-Term" class="headerlink" title="Surface Area Minimization Term"></a>Surface Area Minimization Term</h3><p>由于从粒子计算曲率容易出错，所以避免显示计算表面曲率，通过SPH近似光滑颜色场梯度计算法线信息；</p><p>参数h，控制法线比例大小；</p><p>法线大小与曲率成正比：对于流体内部，n接近于0，在曲率大的自由表面处，n很大。</p><p>创造了一个对称性力：在平坦的区域和流体内部为0，随着曲率的增大而变大。</p><p>本文的表面积最小化力避免了先前技术的两个重要问题：n的归一化(在流体内部是错误的)和显式曲率计算(对粒子无序非常敏感)。</p><h3 id="Combined-Surface-Tension-Force"><a href="#Combined-Surface-Tension-Force" class="headerlink" title="Combined Surface Tension Force"></a>Combined Surface Tension Force</h3><p>现实中的流体，流体分子之间的引力发生在微观尺度上；</p><p>在SPH中，粒子代表流体的宏观体积。</p><p>提出的方法：修正SPH，适应性SPH  但是，增加了计算开销</p><p>本文通过创建对称化校正因子显式解决这个问题：缺少邻居粒子K&gt;1，充满邻居粒子K≈1</p><p>意义：对于邻居粒子不足的区域，K放大了力，而对于具有适当邻居粒子的区域，力保持不变</p><p>最终得到的表面张力模型：完全对称，总的力施加到粒子对上。简单地保持动量守恒。</p><h2 id="Adhesion-Model"><a href="#Adhesion-Model" class="headerlink" title="Adhesion Model"></a>Adhesion Model</h2><p>粘附力是不同材料分子相互作用的结果。</p><p>使用边界粒子对固体表面采样，边界粒子对流体粒子的贡献基于边界粒子的体积</p><p>在计算流体密度、压力和粘性力时，用\psi来代替边界粒子的质量。</p><p>本文的粘附力模型只吸引距离在h/2到h之间的粒子，并将这个区间内的吸引力变大，并保持连续性。</p><p>陡峭的抛物线函数，它对大多数邻近的流体粒子产生强烈的吸引力。</p><h1 id="Solid-Fluid-Interaction-with-Surface-Tension-Dominant-Contact"><a href="#Solid-Fluid-Interaction-with-Surface-Tension-Dominant-Contact" class="headerlink" title="Solid-Fluid Interaction with Surface-Tension-Dominant Contact"></a>Solid-Fluid Interaction with Surface-Tension-Dominant Contact</h1><p>主要内容：</p><p>​        一种新的<strong>三向耦合方法</strong>模拟强表面张力驱动下固体与流体的接触相互作用。</p><p>​        该物理模型的核心是一个薄液膜，它同时耦合液体和刚性物体，便于精确的动量传递、碰撞处理和表面张力计算。</p><p>​        该模型在<strong>混合欧拉-拉格朗日框架</strong>下进行数值实现，其中薄膜被建模为简单网格，液体体积在背景笛卡尔网格上模拟。</p><p>固液耦合：</p><p><img src="surface-tension/固液耦合.png" alt="固液耦合" style="zoom:80%;" /></p><p>​        从计算的角度来看，精确模拟三种力之间的相互作用需要正确处理三个子系统——液体、固体和它们之间的强张力液体界面。</p><p>​        本文提出一种新的三向耦合机制来模拟强表面张力驱动的流固耦合系统。将表面张力占主导地位的界面视为拉格朗日薄膜，有有限的厚度，可以直接对其接触的物体施加浮力和表面张力。</p><p>技术贡献：</p><ul><li>一种新的拉格朗日薄膜表示法，精确地捕捉强表面张力驱动下固体与流体之间的接触相互作用。</li><li>一个整体耦合框架，满足所有速度和位置约束，同时保持动量。</li><li>一个预测-校正接触处理方案，以准确处理具有现实物理参数的流固耦合。</li></ul><h3 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h3><p>体积流体</p><p>表面薄膜</p><p>刚体</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blender</title>
    <link href="/2021/07/03/blender/"/>
    <url>/2021/07/03/blender/</url>
    
    <content type="html"><![CDATA[<h1 id="blender流体模拟"><a href="#blender流体模拟" class="headerlink" title="blender流体模拟"></a>blender流体模拟</h1><p>Physics &gt;&gt;&gt; Fluid</p><ol><li>创建一个定义模拟边界的域物体（Domain object ）；</li><li>设置发射器流物体（Flow objects）；</li><li>设置效应器物体（Effector objects），使流体与场景中的物体交互；</li><li>为域物体分配材质；</li><li>烘焙缓存。</li></ol><h2 id="Domain-Type"><a href="#Domain-Type" class="headerlink" title="Domain Type"></a>Domain Type</h2><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><p><strong>Domain Type</strong></p><p>Gas</p><p>Liquid</p><p><strong>Resolution Divisions</strong></p><p>改变domain中voxel单位大小</p><p>细分精度越高，流体粒子数越多，细节更丰富</p><p><strong>Time Scale</strong></p><p>控制模拟的速度</p><p><strong>CFL Number</strong></p><p><strong>Use Adaptive Time Steps</strong></p><p>使用自适应时间步长</p><p><strong>Timesteps Maximum</strong></p><p><strong>Timesteps Minimum</strong></p><p><strong>Border Collisions</strong></p><h3 id="Liquid"><a href="#Liquid" class="headerlink" title="Liquid"></a>Liquid</h3><p><strong>Simulation Method</strong></p><p>FLIP （Fluid Implicit Particle，隐式粒子流体法）解决了PIC存在的耗散问题，有噪声，不稳定</p><p>APIC （Affine Particle-In-Cell，仿射粒子元胞法）更活跃更稳定，涡度保持更好</p><p><strong>FLIP Ratio</strong> （Simulation FLIP Only）</p><p>更新液体粒子速度时使用多少 FLIP 速度。值为 1.0 表示完全基于 FLIP 的模拟。</p><p><strong>System Maximum</strong></p><p>模拟中允许的最大流体粒子数。如果此字段设置为零，求解器将始终在需要时对新粒子进行采样。</p><p><strong>Particle Radius</strong></p><p>以网格单元为单位的一种液体粒子的半径</p><p><strong>Sampling</strong></p><p>改变每个voxel单元中流体粒子的采样数量，从而改变整体流体粒子的数量</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Resolution Divisions 和 Sampling 提升精度的区别：<br>Resolution Divisions 改变的是流体模拟的最小计算单位，从而增加参与计算的粒子数；<br>Sampling 改变的是每个计算单位里流体粒子的采样数，对全局模拟精度无提升，但能提升粒子间的运动细腻度和平滑度。<br></code></pre></td></tr></table></figure><p><strong>Randomness</strong></p><p>随机性，值为 0 时，所有新粒子都将在其相应的网格单元内均匀采样</p><p><strong>Particles Maximum</strong></p><p>每个网格单元的最大液体粒子数</p><p><strong>Minimum</strong></p><p>每个网格单元的最小液体粒子数</p><p><strong>Narrow Band Width</strong></p><h3 id="Viscosity"><a href="#Viscosity" class="headerlink" title="Viscosity"></a>Viscosity</h3><p><strong>Strength</strong> </p><p>液体的粘度。更高的值会导致更粘稠的流体。</p><h3 id="Diffusion"><a href="#Diffusion" class="headerlink" title="Diffusion"></a>Diffusion</h3><p>扩散的主要因素是<em>Viscosity</em>和<em>Surface Tension</em>。</p><p><strong>Base</strong>和<strong>Exponent</strong>决定了液体的粘度</p><p><strong>Surface Tension</strong> 表面张力</p><h3 id="Particles"><a href="#Particles" class="headerlink" title="Particles"></a>Particles</h3><p><strong>Spray</strong>   飞沫，在液体表面上方的空气中飞舞的颗粒</p><p><strong>Foam</strong>   泡沫，泡沫粒子仅在液体表面移动</p><p><strong>Bubbles</strong>  气泡，气泡粒子是那些在液体表面以下移动的粒子</p><h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><p><strong>Upres Factor</strong></p><p>在<strong>Resolution Divisions</strong>的基础上进一步提升Mesh的细分精度。</p><p><strong>Particle Radius</strong></p><p>以网格单元为单位的一种液体粒子的半径。该值描述了一个粒子覆盖了多少区域，从而确定了它周围有多少区域可以被视为液体。</p><p><strong>Use Speed Vectors</strong></p><p>如果启用此复选框，则会生成速度矢量（网格顶点速度）并将其存储在驱动器上。它们可用于通过合成节点计算基于图像的运动模糊。</p><p><strong>Mesh Generator</strong></p><p>网格生成器方法决定了网格的精度。<em>Final</em> 将产生更高质量的网格，<em>Preview</em>速度快但不平滑</p><p><strong>Smoothing Positive</strong></p><p>正网格平滑迭代。值越高网格轮廓越平滑。</p><p><strong>Smoothing Negative</strong></p><p>负网格平滑迭代。值越高网格轮廓越清晰。</p><p><strong>Concavity Upper</strong></p><p><strong>Concavity Lower</strong></p><h2 id="Flow-Type"><a href="#Flow-Type" class="headerlink" title="Flow Type"></a>Flow Type</h2><h3 id="Settings-1"><a href="#Settings-1" class="headerlink" title="Settings"></a>Settings</h3><p><strong>Flow Type</strong></p><p>Smoke、 Fire+Smoke、 Fire、 Liquid</p><p><strong>Flow Behavior</strong></p><p>Inflow</p><p>Outflow</p><p>Geometry</p><p><strong>Sampling Substeps</strong></p><h3 id="Flow-Source"><a href="#Flow-Source" class="headerlink" title="Flow Source"></a>Flow Source</h3><p><strong>Flow Source </strong></p><p>Mesh  直接从对象的网格中发射流体</p><p><strong>Is Planar</strong></p><p><strong>Surface Emission</strong></p><h3 id="Initial-Velocity"><a href="#Initial-Velocity" class="headerlink" title="Initial Velocity"></a>Initial Velocity</h3><h2 id="Effector-Type"><a href="#Effector-Type" class="headerlink" title="Effector Type"></a>Effector Type</h2><h3 id="Settings-2"><a href="#Settings-2" class="headerlink" title="Settings"></a>Settings</h3><p><strong>Effector Type</strong></p><p>Collision  这种类型的物体会与流体发生碰撞</p><p>Guide  这类物体需移动并具有一定的速度</p><p><strong>Effector Substeps</strong></p><p><strong>Surface Thickness</strong></p><p><strong>Use Effector</strong></p><p><strong>Is Planar</strong></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">bl_info = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;My Test Add-on&quot;</span>,<br>    <span class="hljs-string">&quot;blender&quot;</span>: (<span class="hljs-number">2</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;Object&quot;</span>,<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>():</span><br>    print(<span class="hljs-string">&quot;Hello World&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unregister</span>():</span><br>    print(<span class="hljs-string">&quot;Goodbye World&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>bl_info</code></p><p>一个字典，包含插件元数据如标题、版本和作者，这些信息会显示在用户设置的插件列表。</p><p><code>register</code></p><p>仅在启用插件时运行的函数，这意味着无需激活插件即可加载模块。</p><p><code>unregister</code></p><p>用于卸载 <code>register</code> 建立的数据的函数，在禁用插件时调用。</p><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python">bl_info = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Move X Axis&quot;</span>,<br>    <span class="hljs-string">&quot;blender&quot;</span>: (<span class="hljs-number">2</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;Object&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">import</span> bpy<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectMoveX</span>(<span class="hljs-params">bpy.types.Operator</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;My Object Moving Script&quot;&quot;&quot;</span>      <span class="hljs-comment"># Use this as a tooltip for menu items and buttons.</span><br>    bl_idname = <span class="hljs-string">&quot;object.move_x&quot;</span>        <span class="hljs-comment"># Unique identifier for buttons and menu items to reference.</span><br>    bl_label = <span class="hljs-string">&quot;Move X by One&quot;</span>         <span class="hljs-comment"># Display name in the interface.</span><br>    bl_options = &#123;<span class="hljs-string">&#x27;REGISTER&#x27;</span>, <span class="hljs-string">&#x27;UNDO&#x27;</span>&#125;  <span class="hljs-comment"># Enable undo for the operator.</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, context</span>):</span>        <span class="hljs-comment"># execute() is called when running the operator.</span><br><br>        <span class="hljs-comment"># The original script</span><br>        scene = context.scene<br>        <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> scene.objects:<br>            obj.location.x += <span class="hljs-number">1.0</span><br><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;FINISHED&#x27;</span>&#125;            <span class="hljs-comment"># Lets Blender know the operator finished successfully.</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">menu_func</span>(<span class="hljs-params">self, context</span>):</span><br>    self.layout.operator(ObjectMoveX.bl_idname)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>():</span><br>    bpy.utils.register_class(ObjectMoveX)<br>    bpy.types.VIEW3D_MT_object.append(menu_func)  <span class="hljs-comment"># Adds the new operator to an existing menu.</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unregister</span>():</span><br>    bpy.utils.unregister_class(ObjectMoveX)<br><br><br><span class="hljs-comment"># This allows you to run the script directly from Blender&#x27;s Text editor</span><br><span class="hljs-comment"># to test the add-on without having to install it.</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    register()<br></code></pre></td></tr></table></figure><p>Demo2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python">bl_info = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Cursor Array&quot;</span>,<br>    <span class="hljs-string">&quot;blender&quot;</span>: (<span class="hljs-number">2</span>, <span class="hljs-number">80</span>, <span class="hljs-number">0</span>),<br>    <span class="hljs-string">&quot;category&quot;</span>: <span class="hljs-string">&quot;Object&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">import</span> bpy<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCursorArray</span>(<span class="hljs-params">bpy.types.Operator</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Object Cursor Array&quot;&quot;&quot;</span><br>    bl_idname = <span class="hljs-string">&quot;object.cursor_array&quot;</span><br>    bl_label = <span class="hljs-string">&quot;Cursor Array&quot;</span><br>    bl_options = &#123;<span class="hljs-string">&#x27;REGISTER&#x27;</span>, <span class="hljs-string">&#x27;UNDO&#x27;</span>&#125;<br><br>    total: bpy.props.IntProperty(name=<span class="hljs-string">&quot;Steps&quot;</span>, default=<span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>=<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">100</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, context</span>):</span><br>        scene = context.scene<br>        cursor = scene.cursor.location<br>        obj = context.active_object<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.total):<br>            obj_new = obj.copy()<br>            scene.collection.objects.link(obj_new)<br><br>            factor = i / self.total<br>            obj_new.location = (obj.location * factor) + (cursor * (<span class="hljs-number">1.0</span> - factor))<br><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;FINISHED&#x27;</span>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">menu_func</span>(<span class="hljs-params">self, context</span>):</span><br>    self.layout.operator(ObjectCursorArray.bl_idname)<br><br><span class="hljs-comment"># store keymaps here to access after registration</span><br>addon_keymaps = []<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>():</span><br>    bpy.utils.register_class(ObjectCursorArray)<br>    bpy.types.VIEW3D_MT_object.append(menu_func)<br><br>    <span class="hljs-comment"># handle the keymap</span><br>    wm = bpy.context.window_manager<br>    <span class="hljs-comment"># Note that in background mode (no GUI available), keyconfigs are not available either,</span><br>    <span class="hljs-comment"># so we have to check this to avoid nasty errors in background case.</span><br>    kc = wm.keyconfigs.addon<br>    <span class="hljs-keyword">if</span> kc:<br>        km = wm.keyconfigs.addon.keymaps.new(name=<span class="hljs-string">&#x27;Object Mode&#x27;</span>, space_type=<span class="hljs-string">&#x27;EMPTY&#x27;</span>)<br>        kmi = km.keymap_items.new(ObjectCursorArray.bl_idname, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;PRESS&#x27;</span>, ctrl=<span class="hljs-literal">True</span>, shift=<span class="hljs-literal">True</span>)<br>        kmi.properties.total = <span class="hljs-number">4</span><br>        addon_keymaps.append((km, kmi))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unregister</span>():</span><br>    <span class="hljs-comment"># Note: when unregistering, it&#x27;s usually good practice to do it in reverse order you registered.</span><br>    <span class="hljs-comment"># Can avoid strange issues like keymap still referring to operators already unregistered...</span><br>    <span class="hljs-comment"># handle the keymap</span><br>    <span class="hljs-keyword">for</span> km, kmi <span class="hljs-keyword">in</span> addon_keymaps:<br>        km.keymap_items.remove(kmi)<br>    addon_keymaps.clear()<br><br>    bpy.utils.unregister_class(ObjectCursorArray)<br>    bpy.types.VIEW3D_MT_object.remove(menu_func)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    register()<br></code></pre></td></tr></table></figure><p>参数传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># moved assignment from execute() to the body of the class...</span><br>total: bpy.props.IntProperty(name=<span class="hljs-string">&quot;Steps&quot;</span>, default=<span class="hljs-number">2</span>, <span class="hljs-built_in">min</span>=<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># and this is accessed on the class</span><br><span class="hljs-comment"># instance within the execute() function as...</span><br>self.total<br></code></pre></td></tr></table></figure><p>键位映射</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># store keymaps here to access after registration</span><br>addon_keymaps = []<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">register</span>():</span><br><br>    <span class="hljs-comment"># handle the keymap</span><br>    wm = bpy.context.window_manager<br>    km = wm.keyconfigs.addon.keymaps.new(name=<span class="hljs-string">&#x27;Object Mode&#x27;</span>, space_type=<span class="hljs-string">&#x27;EMPTY&#x27;</span>)<br><br>    kmi = km.keymap_items.new(ObjectCursorArray.bl_idname, <span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-string">&#x27;PRESS&#x27;</span>, ctrl=<span class="hljs-literal">True</span>, shift=<span class="hljs-literal">True</span>)<br>    kmi.properties.total = <span class="hljs-number">4</span><br><br>    addon_keymaps.append((km, kmi))<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unregister</span>():</span><br><br>    <span class="hljs-comment"># handle the keymap</span><br>    <span class="hljs-keyword">for</span> km, kmi <span class="hljs-keyword">in</span> addon_keymaps:<br>        km.keymap_items.remove(kmi)<br>    addon_keymaps.clear()<br></code></pre></td></tr></table></figure><p>mesh data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python">so = bpy.context.active_object<br>verts = so.data.vertices<br>edges = so.data.edges<br>faces = so.data.polygons<br><span class="hljs-comment"># coordinates:</span><br><span class="hljs-comment"># verts[i].co</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verts:<br>    print(v.co)<br>    <br><span class="hljs-comment"># edges[i].vertices[j] -&gt; a list of integer values</span><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> edges:<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> e.vertices:<br>        print(v)<br>        <br>index = edges[i].vertices[j]<br>vertex = verts[index]<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> faces:<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> f.vertices:<br>        print(v)<br>        <br><span class="hljs-comment"># add </span><br>verts = []<br>edges = []<br>faces = []<br>verts.append([ <span class="hljs-comment">#index 0</span><br>    <span class="hljs-number">0.0</span>, <span class="hljs-comment"># x</span><br>    <span class="hljs-number">1.0</span>, <span class="hljs-comment"># y</span><br>    <span class="hljs-number">0.0</span>, <span class="hljs-comment"># z</span><br>])<br>verts.append([ <span class="hljs-comment">#index 1</span><br>    <span class="hljs-number">1.0</span>, <span class="hljs-comment"># x</span><br>    <span class="hljs-number">0.0</span>, <span class="hljs-comment"># y</span><br>    <span class="hljs-number">0.0</span>, <span class="hljs-comment"># z</span><br>])<br>edges.append([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br>faces.append([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>faces.append([<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])<br><br><span class="hljs-comment"># create a new mesh</span><br>name = <span class="hljs-string">&quot;New Object&quot;</span><br>mesh = bpy.data.meshes.new(name)<br>obj = bpy.data.objects.new(name, mesh)<br>col = bpy.data.collections.get(<span class="hljs-string">&quot;Objects&quot;</span>)<br>col.objects.link(obj)<br>bpy.context.view_layer.objects.active = obj<br>mesh.from_pydata(verts, edges, faces)<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>   <span class="hljs-attr">&quot;spacing_r&quot;</span> : <span class="hljs-number">0.1</span>,<br>   <span class="hljs-attr">&quot;bound_cube&quot;</span> : &#123;<br>      <br>   &#125;,<br>   <span class="hljs-attr">&quot;fluid&quot;</span> : [ <br>       [<br>           (<span class="hljs-number">-3.9</span>, <span class="hljs-number">-3.9</span>, <span class="hljs-number">-0.9</span>),<br>           (<span class="hljs-number">3.9</span>, <span class="hljs-number">-0.9</span>, <span class="hljs-number">0.9</span>)<br>       ],<br>       [<br>           (<span class="hljs-number">-3.9</span>, <span class="hljs-number">-0.8</span>, <span class="hljs-number">-0.9</span>),<br>           (<span class="hljs-number">3.9</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">0.9</span>)<br>       ]<br>   ],<br>   <span class="hljs-attr">&quot;density&quot;</span> : <span class="hljs-number">1000</span>,<br>   <span class="hljs-attr">&quot;vis&quot;</span> : <span class="hljs-number">0.05</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>win10+cuda+vs2019</title>
    <link href="/2021/06/27/win10-cuda-vs2019/"/>
    <url>/2021/06/27/win10-cuda-vs2019/</url>
    
    <content type="html"><![CDATA[<h1 id="win10-cuda-vs2019"><a href="#win10-cuda-vs2019" class="headerlink" title="win10+cuda+vs2019"></a>win10+cuda+vs2019</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、检查显卡支持的cuda版本"><a href="#1、检查显卡支持的cuda版本" class="headerlink" title="1、检查显卡支持的cuda版本"></a>1、检查显卡支持的cuda版本</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/cuda_version.png" alt="cuda_version"></p><h3 id="2、安装vs2019"><a href="#2、安装vs2019" class="headerlink" title="2、安装vs2019"></a>2、安装vs2019</h3><h3 id="3、安装cuda"><a href="#3、安装cuda" class="headerlink" title="3、安装cuda"></a>3、安装cuda</h3><p>（1）<a href="https://developer.nvidia.com/cuda-toolkit-archive">官网</a>下载对应版本的安装包：</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/download.png" alt="download" style="zoom:60%;" /></p><p>（2）自定义安装</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/%E5%AE%89%E8%A3%85.png" alt="安装" style="zoom:80%;" /></p><p>（3）安装结束后，系统变量中已经加入了cuda的两个路径</p><p>在系统变量中加入下面的路径：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">CUDA_BIN_PATH: <span class="hljs-variable">%CUDA_PATH%</span><span class="hljs-symbol">\b</span>in<br><br>CUDA_LIB_PATH: <span class="hljs-variable">%CUDA_PATH%</span><span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\x</span>64<br><br>CUDA_SDK_PATH: C:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\N</span>VIDIA Corporation<span class="hljs-symbol">\C</span>UDA Samples<span class="hljs-symbol">\v</span>11.0<br><br>CUDA_SDK_BIN_PATH: <span class="hljs-variable">%CUDA_SDK_PATH%</span><span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\w</span>in64<br><br>CUDA_SDK_LIB_PATH: <span class="hljs-variable">%CUDA_SDK_PATH%</span><span class="hljs-symbol">\c</span>ommon<span class="hljs-symbol">\l</span>ib<span class="hljs-symbol">\x</span>64<br></code></pre></td></tr></table></figure><p>在系统变量path中加入下面的的变量：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">CUDA_BIN_PATH</span></span>%<br><br><span class="hljs-tag">%<span class="hljs-selector-tag">CUDA_LIB_PATH</span></span>%<br><br><span class="hljs-tag">%<span class="hljs-selector-tag">CUDA_SDK_BIN_PATH</span></span>%<br><br><span class="hljs-tag">%<span class="hljs-selector-tag">CUDA_SDK_LIB_PATH</span></span>%<br></code></pre></td></tr></table></figure><h3 id="4、测试cuda是否安装成功"><a href="#4、测试cuda是否安装成功" class="headerlink" title="4、测试cuda是否安装成功"></a>4、测试cuda是否安装成功</h3><p>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2\extras\demo_suite下允许bandwidthTest.exe和deviceQuery.exe两个程序，result=pass则安装成功。</p><p>运行cmd，输入nvcc —version 查看版本号：</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/nvcc_version.png" alt="nvcc_version" style="zoom:80%;" /></p><h3 id="5、配置vs项目"><a href="#5、配置vs项目" class="headerlink" title="5、配置vs项目"></a>5、配置vs项目</h3><p>（1）vs2019，创建cuda项目：</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/vs%E9%A1%B9%E7%9B%AE.png" alt="vs项目" style="zoom:50%;" /></p><p>（2）工具–&gt;选项–&gt;文本编辑器–&gt;文件拓展名, 新增扩展名  .cu  Microsoft Visual C++</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/%E6%96%B0%E5%A2%9E%E6%89%A9%E5%B1%95%E5%90%8D.png" alt="新增扩展名" style="zoom:80%;" /></p><p>（3）工具–&gt;选项–&gt;项目和解决方案–&gt;VC++项目设置，添加要包括的扩展名”.cu”</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE.png" alt="包含扩展名" style="zoom:80%;" /></p><p>（4）右键打开的项目–&gt;生成依赖项–&gt;生成自定义–&gt;勾选CUDA v11.0</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E9%A1%B9.png" alt="生成依赖项" style="zoom:80%;" /></p><p>（5）右键.cu文件–&gt;文件属性设置为 CUDA c/c++</p><p><img src="https://cdn.jsdelivr.net/gh/Artemisaturn/my_pictures/img/win10-cuda-vs2019/%E5%8C%85%E5%90%AB%E6%89%A9%E5%B1%95%E5%90%8D.png" alt="文件属性设置" style="zoom:80%;" /></p><p>（6）包含目录配置：项目属性–&gt;属性–&gt;配置属性–&gt;VC++目录–&gt;包含目录，添加包含目录$(CUDA_PATH)\include</p><p>（7）库目录配置：VC++目录–&gt;库目录，$(CUDA_PATH)\lib\x64</p><p>（8）依赖项：配置属性–&gt;连接器–&gt;输入–&gt;附加依赖项，添加库文件：cublas.lib cuda.lib cudadevrt.lib cudart.lib cudart_static.lib OpenCL.lib cublas.lib</p><h2 id="NVIDIA-CUDA-Libraries"><a href="#NVIDIA-CUDA-Libraries" class="headerlink" title="NVIDIA CUDA Libraries"></a>NVIDIA CUDA Libraries</h2><h3 id="cuBLAS库"><a href="#cuBLAS库" class="headerlink" title="cuBLAS库"></a>cuBLAS库</h3><p>cuBLAS 库是<strong>基本线性代数子程序</strong> (BLAS) 在 NVIDIA CUDA 运行时上的实现。它使用户能够访问 NVIDIA GPU 的计算资源。</p><p>要使用 cuBLAS API，应用程序必须在 GPU 内存空间中分配所需的矩阵和向量，用数据填充它们，调用所需的 cuBLAS 函数序列，然后将结果从 GPU 内存空间上传回主机。</p><h4 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h4><p>为了最大程度地与现有 Fortran 环境兼容，cuBLAS 库使用列优先存储和基于 1 的索引。应该定义宏或内联函数来实现在一维数组之上的矩阵，在基于 1 的索引的情况下，可以通过以下宏计算行“i”和“j”列中矩阵元素的数组索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IDX2F(i,j,ld) ((((j)-1)*(ld))+((i)-1))</span><br></code></pre></td></tr></table></figure><p>这里，ld 指的是矩阵的前导维度，在列优先存储的情况下，它是分配矩阵的行数。对于本地编写的 C 和 C++ 代码，最有可能选择基于 0 的索引，在这种情况下，可以通过以下宏计算行“i”和列“j”中矩阵元素的数组索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IDX2C(i,j,ld) (((j)*(ld))+(i))</span><br></code></pre></td></tr></table></figure><h4 id="cuBLAS数据类型"><a href="#cuBLAS数据类型" class="headerlink" title="cuBLAS数据类型"></a>cuBLAS数据类型</h4><p><strong>cublasHandle_t</strong> 是指向包含 cuBLAS 库上下文的不透明结构的指针类型。cuBLAS 库上下文必须使用<em>cublasCreate()</em>初始化，并且返回的句柄必须传递给所有后续的库函数调用。最后使用<em>cublasDestroy()</em>释放与CUBLAS库上下文相关联的资源。</p><p><strong>cublasStatus_t</strong> ：该类型用于函数状态返回。 所有Cublas库函数都返回其状态，可以具有以下值。</p><div class="table-container"><table><thead><tr><th>value</th><th>meaning</th></tr></thead><tbody><tr><td>CUBLAS_STATUS_SUCCESS</td><td>操作成功完成</td></tr><tr><td>CUBLAS_STATUS_NOT_INITIALIZED</td><td>cuBLAS 库未初始化</td></tr><tr><td>CUBLAS_STATUS_ALLOC_FAILED</td><td>cuBLAS 库内的资源分配失败</td></tr><tr><td>CUBLAS_STATUS_MAPPING_ERROR</td><td>访问 GPU 内存空间失败</td></tr></tbody></table></div><h4 id="cuBLAS辅助函数"><a href="#cuBLAS辅助函数" class="headerlink" title="cuBLAS辅助函数"></a>cuBLAS辅助函数</h4><p><strong>cublasGetVector()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">cublasGetVector(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> elemSize, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *x, <span class="hljs-keyword">int</span> incx, <span class="hljs-keyword">void</span> *y, <span class="hljs-keyword">int</span> incy)<br></code></pre></td></tr></table></figure><p>将GPU内存空间的向量x的n个元素复制到主机内存空间的y向量。两个向量中的元素大小为elemSize字节。对于源向量x，连续元素之间的存储间隔为incx，对于目标向量y，连续元素之间的存储间隔为incy。</p><p><strong>cublasSgemm()</strong></p><script type="math/tex; mode=display">C=\alpha op(A)op(B)+\beta C</script><h3 id="cuFFT库"><a href="#cuFFT库" class="headerlink" title="cuFFT库"></a>cuFFT库</h3><p>NVIDIA CUDA 快速傅立叶变换 (cuFFT) 库由两个组件组成：cuFFT 和 cuFFTW。cuFFT 库在 NVIDIA GPU 上提供高性能，cuFFTW 库是一个移植工具，用于在 NVIDIA GPU 上使用最快的傅立叶变换 (FFTW)。</p><h3 id="cuRAND库"><a href="#cuRAND库" class="headerlink" title="cuRAND库"></a>cuRAND库</h3><p>NVIDIA CUDA 随机数生成 (cuRAND) 库提供了一个 API，用于简单高效地生成高质量的伪随机数和准随机数。</p><h3 id="cuSOLVER库"><a href="#cuSOLVER库" class="headerlink" title="cuSOLVER库"></a>cuSOLVER库</h3><p>cuSOLVER 库是基于 cuBLAS 和 cuSPARSE 库的高级包。它提供类似于线性代数包 (LAPACK) 的功能，例如常见矩阵分解和用于密集矩阵的三角求解例程。</p><h3 id="cuSPARSEL库"><a href="#cuSPARSEL库" class="headerlink" title="cuSPARSEL库"></a>cuSPARSEL库</h3><p>cuSPARSE 库包含一组用于处理稀疏矩阵的基本线性代数子程序。它在 NVIDIA CUDA 运行时上实现，旨在从 C 和 C++ 调用。</p><h3 id="cuSPARSELt库"><a href="#cuSPARSELt库" class="headerlink" title="cuSPARSELt库"></a>cuSPARSELt库</h3><p>cuSPARSELt 库提供高性能、结构化、矩阵密集的矩阵乘法功能。cuSPARSELt 允许用户利用最新的 NVIDIA GPU 的计算资源。</p><h3 id="cuTENSOR库"><a href="#cuTENSOR库" class="headerlink" title="cuTENSOR库"></a>cuTENSOR库</h3><p>cuTENSOR 库是同类中首创的、GPU 加速的张量线性代数库，提供高性能的张量收缩、缩减和元素操作。cuTENSOR 用于加速深度学习训练和推理、计算机视觉、量子化学和计算物理领域的应用。</p><h3 id="NPP库"><a href="#NPP库" class="headerlink" title="NPP库"></a>NPP库</h3><p>NVIDIA Performance Primitives (NPP) 是一个用于执行 CUDA 加速 2D 图像和信号处理的函数库。该库广泛适用于这些领域的开发人员，其编写目的是在保持高性能的同时最大限度地提高灵活性。</p><h2 id="NVIDIA-CUDA-Toolkit"><a href="#NVIDIA-CUDA-Toolkit" class="headerlink" title="NVIDIA CUDA Toolkit"></a>NVIDIA CUDA Toolkit</h2><p>线性内存通常使用<em>cudaMalloc()</em>分配和<em>cudaFree()</em>释放，主机内存和设备内存之间的数据传输通常使用<em>cudaMemcpy()</em>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>overleaf latex</title>
    <link href="/2021/05/21/overleaf-latex/"/>
    <url>/2021/05/21/overleaf-latex/</url>
    
    <content type="html"><![CDATA[<p>表格</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[b]<br><span class="hljs-keyword">\centering</span><br><span class="hljs-keyword">\caption</span>&#123;Number of iterations between 4.5s and 4.6s in the experiment of fluid coupling: two-phase dam-break (see Sec.<span class="hljs-keyword">\@</span>~<span class="hljs-keyword">\ref</span>&#123;sec:exp-vfsph&#125;).&#125;<br><span class="hljs-keyword">\label</span>&#123;tab:iteration&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|c|l|ccc|&#125;<br><span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;SPH&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\multicolumn</span>&#123;1&#125;&#123;c|&#125;&#123;<span class="hljs-keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;Solver&#125;&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\multicolumn</span>&#123;3&#125;&#123;c|&#125;&#123;<span class="hljs-built_in">$</span><span class="hljs-keyword">\rho</span><span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\mathrm</span>&#123;red&#125;&#125;:<span class="hljs-keyword">\rho</span><span class="hljs-built_in">_</span>&#123;<span class="hljs-keyword">\mathrm</span>&#123;blue&#125;&#125;<span class="hljs-built_in">$</span>&#125; <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\cline</span>&#123;3-5&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-keyword">\multicolumn</span>&#123;1&#125;&#123;c|&#125;&#123;&#125; <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>1:2<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>1:5<span class="hljs-built_in">$</span>  <span class="hljs-built_in">&amp;</span> <span class="hljs-built_in">$</span>1:40<span class="hljs-built_in">$</span>   <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;DFSPH&#125; <span class="hljs-built_in">&amp;</span> divergenceFreeSolver <span class="hljs-built_in">&amp;</span> 379  <span class="hljs-built_in">&amp;</span> 662 <span class="hljs-built_in">&amp;</span> 787 <span class="hljs-keyword">\\</span> <br>                       <span class="hljs-built_in">&amp;</span> constantDensitySolver <span class="hljs-built_in">&amp;</span> 638 <span class="hljs-built_in">&amp;</span> 316 <span class="hljs-built_in">&amp;</span> 471 <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\multirow</span>&#123;2&#125;&#123;*&#125;&#123;VFSPH&#125; <span class="hljs-built_in">&amp;</span> divergenceFreeSolver <span class="hljs-built_in">&amp;</span> 264 <span class="hljs-built_in">&amp;</span> 327 <span class="hljs-built_in">&amp;</span> 338 <span class="hljs-keyword">\\</span> <br>                       <span class="hljs-built_in">&amp;</span> constantDensitySolver <span class="hljs-built_in">&amp;</span> 647 <span class="hljs-built_in">&amp;</span> 533 <span class="hljs-built_in">&amp;</span> 417 <span class="hljs-keyword">\\</span> <span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volume rendering</title>
    <link href="/2021/03/20/volume-rendering/"/>
    <url>/2021/03/20/volume-rendering/</url>
    
    <content type="html"><![CDATA[<h1 id="Volume-Rendering"><a href="#Volume-Rendering" class="headerlink" title="Volume Rendering"></a>Volume Rendering</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​        随着技术的重大进步以及计算能力的提高，路径跟踪现已成为电影制作中使用的主要渲染方法。 得益于这些进步，体渲染现在可以充分利用路径跟踪的革命，从而可以创建仅几年前就无法实现的照片级逼真的图像。 但是，体渲染还提供了其自身的一系列独特挑战，这些挑战对于习惯于仅处理曲面的路径跟踪开发人员和研究人员而言可能是艰巨的。 尽管最近的文本和材料已经涵盖了其中一些挑战，但据我们所知，还没有全面地做到这一点，尤其是在面对生产所需的复杂性和规模要求时。</p><p>​        </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PyTorch</title>
    <link href="/2021/03/20/PyTorch/"/>
    <url>/2021/03/20/PyTorch/</url>
    
    <content type="html"><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>资源：</p><p>课程主页：<a href="https://courses.del.ai/zh-v2">https://courses.del.ai/zh-v2</a></p><p>教材：<a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></p><p>课程论坛讨论：<a href="https://discuss.d2l.ai/c/16">https://discuss.d2l.ai/c/16</a></p><p>Pytorch: <a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hybrid Lagrangian-Eulerian method</title>
    <link href="/2021/03/08/hybrid-Lagrangian-Eulerian-method/"/>
    <url>/2021/03/08/hybrid-Lagrangian-Eulerian-method/</url>
    
    <content type="html"><![CDATA[<p>Particle-in-cell(PIC),  Affine PIC(APIC),  Polynomial PIC(PolyPIC)</p><p>Fluid Implicit Particles (FLIP)  流体隐式粒子</p><p>Material Point Method(MPM)  物质点法</p><p>守恒：动量守恒、角动量守恒、体积不可压缩、能量守恒</p><p>性能：容不容易并行，在访问内存时时间空间局部性是不是好</p><p>实现的复杂性</p><p>advection：移动流体的场</p><p>projection：把速度场速度分量投影掉，保证不可压缩性</p><p>欧拉网格：擅长projection，均匀网格上离散拉普拉斯算子非常容易，查找结点邻居也非常容易</p><p>​                    缺点：advection时会丢失能量和几何细节</p><p>拉格朗日粒子：擅长移动，模拟几何细节，更容易质量守恒、动量守恒，因为粒子在模拟过程中质量不变</p><p>​                        缺点：离散化复杂，邻居搜索复杂</p><p>（1）P2G Particle to Grid transfer：把粒子信息传输到网格上（速度、质量）</p><p>（2）Grid operations：动力学计算：pressure projection，boundary condition</p><p>（3）G2P  Grid to Particle transfer</p><p>（4）Particle operations：移动粒子，更新属性（体积）</p><p>P2G：MPM 里会传输力</p><p>距离越近，重要性越高—&gt;核函数</p><p>问题：信息丢失，18个自由度—&gt;2个自由度 （2维，3x3网格节点）</p><p>1个粒子，9个格点，每个格点有x分量y分量速度，有18个自由度</p><p>多传输一些信息：APIC（角速度）</p><p>不传输更多的信息，只传输物理量在grid操作上的增量：FLIP</p><p>FLIP：不gather物理量，gather物理量在grid操作上的增量，叠加到粒子旧的值上面，信息就不完全是从P2G,G2P，多了一条P2P的信息路径，就能避免很多信息的丢失</p><p>PIC、FLIP都是只有advection</p><p>MPM用拉格朗日粒子和欧拉网格完成整个过程</p><p>MPM优点：可以自动耦合不同材料，自动处理碰撞，擅长模拟大形变</p><p>算法比较复杂，步骤比较多</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Multiphase Fluids</title>
    <link href="/2021/02/05/Multiphase-Fluids/"/>
    <url>/2021/02/05/Multiphase-Fluids/</url>
    
    <content type="html"><![CDATA[<h1 id="Multiphase-Fluids"><a href="#Multiphase-Fluids" class="headerlink" title="Multiphase Fluids"></a>Multiphase Fluids</h1><h2 id="A-Divergence-free-Mixture-Model-for-Multiphase-Fluids"><a href="#A-Divergence-free-Mixture-Model-for-Multiphase-Fluids" class="headerlink" title="A Divergence-free Mixture Model for Multiphase Fluids"></a>A Divergence-free Mixture Model for Multiphase Fluids</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        我们提出了一个新的多相流无散度混合模型和相关的流固耦合。新的混合模型建立在体积加权混合速度的基础上，因此可混溶和不可混溶的多相流体满足无散度条件。建议的混合速度可以通过调整单相不可压缩解算器有效地求解，允许更大的时间步长和更小的体积偏差。此外，修正了漂移速度公式，以确保模拟过程中的质量守恒。新方法将多相流体模拟的精度提高了几个数量级。通过模拟不同的多相流现象，包括多种流体的混合和不混合、涉及可变形固体和颗粒材料的流固耦合，证明了新的无散度混合模型的能力。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        多相流在我们的日常生活中很常见，具有有趣的视觉效果。从拿铁艺术到水彩混合，多相流展现出丰富的纹理、形状和颜色。然而，多相流的复杂性可能远远超出单相系统，尤其是当具有显著不同特性的材料混合在一起时。模拟相之间的界面处的不连续性以及由此产生的行为一直是一个具有挑战性的问题。</p><p>​        模拟多相系统需要仔细考虑各个相及其相互作用。一种直观的方法是对每个相单独建模，并将相之间的耦合视为额外的力和边界条件。另一种方法是所谓的混合模型。它将混合物建模为单相，并求解平均速度，而各相的相对速度是用本构模型计算的。后一种方法比为每个阶段求解一组单独的方程需要更少的计算，对于效率更重要的图形应用是理想的。</p><p>​        然而，仍然存在一些未解决的问题，限制了仿真的效率和精度。首先，混合速度并不是固有的无散度的，即使所有的分量相都是不可压缩的。因此，相关的多相SPH模型与计算效率更高的不可压缩解算器不兼容。其次，推导了漂移速度和相变的公式不能保证质量守恒，并且相关的误差在模拟期间累积。</p><p>​        为了解决上述问题，我们提出了一种新的无散度混合模型，它使得不可压缩流体求解器能够用于多相系统。我们的方法支持更大的时间步长，并显著提高了效率。我们还提出了一个修正的漂移速度公式，以便在模拟过程中满足质量守恒。我们表明，相对误差控制在0.001%以下，比以前的工作小几个数量级。</p><h2 id="Kinetic-based-Multiphase-Flow-Simulation-气液、固液"><a href="#Kinetic-based-Multiphase-Flow-Simulation-气液、固液" class="headerlink" title="Kinetic-based Multiphase Flow Simulation(气液、固液)"></a>Kinetic-based Multiphase Flow Simulation(气液、固液)</h2><h3 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        多相流表现出很大范围的复杂行为，如气泡、胶合、润湿和飞溅，这些都是由空气-水和水-固体相互作用产生的。目前图形领域的<strong>流体求解器</strong>已经在再现这些视觉效果方面取得了显著的成功，但是没有一个能提供足够通用的模型来同时捕捉所有的视觉效果。相比之下，<strong>计算流体动力学</strong>已经开发出非常通用的多相流方法，通常基于动力学模型。然而，在这两个社区中，<strong>缺乏能够模拟密度比和雷诺数的方法</strong>，而这是电影制作试图以数字方式创建的具有挑战性的现实生活模拟所需要的，例如空气-水流动。在本文中，我们<strong>提出了</strong>纳维尔-斯托克斯方程与保守相场方程耦合的动力学模型，并对现有的基于动力学的求解器进行了一系列数值改进，以提供通用的多相流求解器。由此产生的算法令人尴尬地并行、保守，甚至在现实条件下也比当前的求解器稳定得多，并且足够通用以捕捉典型的多相流行为。各种模拟结果，包括与以前的工作和真实镜头的比较，以突出我们的新方法的优势。</p><p><em>（雷诺数（Reynolds number）一种可用来表征流体流动情况的无量纲数。是流体力学中表征粘性影响的相似准则数。雷诺数较小时，粘滞力对流场的影响大于惯性，流场中流速的扰动会因粘滞力而衰减，流体流动稳定，为层流；反之，若雷诺数较大时，惯性对流场的影响大于粘滞力，流体流动较不稳定，流速的微小变化容易发展、增强，形成紊乱、不规则的紊流流场。）</em></p><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        几十年来，流体模拟一直是计算机图形学中的一个重要研究课题，到目前为止，电影制作中经常会产生逼真的水体或复杂的烟雾。直到大约十年前，绝大多数流体动画作品都专注于单相模拟，在单相模拟中，流体周围的空气被认为没有对流体表面施加压力，结果不幸的是，任何被困在水下的空气都会立即坍塌，而不是形成气泡。最近，CG将注意力转向多相流，在多相流中，计算相互作用流体的同时演化，以捕捉空气-水和水-固体相互作用中出现的重要视觉现象，例如飞溅、晃动、胶合、沸腾、空化，甚至流体在亲水或疏水表面上产生的复杂润湿模式。</p><p>​        在不混溶的多相流表现出的各种行为中，涉及气泡的特定效应，表面张力流，或甚至润湿，已经在我们的领域中成功解决。然而，这些方法通常依赖于简化的模型来有效地实现每个特征行为，但是没有一个能够同时模拟显示所有这些行为的多相流的真实例子。此外，大多数CG技术无法数值捕捉典型密度比的多相流(例如，空气对水为800，因为ρ_air = 1.2kg/m3，ρ_water= 1000kg/m3)和雷诺数(湍流水流的雷诺数大于4000)。这种限制虽然很少被提及，但它限制了可以通过数字动画处理的模拟范围，并对视觉真实感产生了负面影响。</p><p>​        没有一项工作能够为同时具有高密度比和高雷诺数的多相流提供稳定的处理。</p><p>​        目前，能够再现多相流所有典型特征的最通用和最有效的解算器是基于格子玻尔兹曼方法(LBM)，结合保守相场模型来处理界面计算。这与图形中最常用的方法有很大的不同:这些解算器依赖于从统计力学中导出的流动动力学公式，该公式使用玻尔兹曼(输运)方程来表示流体粒子的位置和速度的概率分布。虽然最初的LBM公式使用了带有局部空间相互作用的显式时间步进(因此，没有全局求解)，在图形中被认为是高度可并行的，但由于其不符合标准的视觉结果及其相对于密度比和雷诺数的有限稳定性和/或准确性，它很快就被废弃了。然而，LBM在最近几年经历了一系列的发展，特别是随着中心矩弛豫模型的发展以及与单陈模型、自由能模型或相场模型的耦合。因此，现代LBM方法在不牺牲效率的情况下，在精度和稳定性方面取得了长足的进步，以至于最近在汽车和航空航天工业中采用了计算流体力学辅助设计。</p><p>​        在本文中，我们重新审视流体模拟的动力学方法，<strong>以提供一个高效而统一的流体求解器，能够捕捉多相流的所有相关可视化行为</strong>。我们证明，目前最先进的格子玻尔兹曼技术与相场模型相结合的主要弱点在于相场数值处理中的两个关键缺陷：离散梯度计算的虚假旋转相关性和单弛豫时间的使用，这两个缺陷共同在界面附近产生了人为的大速度，从而破坏了精度和稳定性。我们为每个问题引入了一个解决方案，并表明由此产生的LBM-粒子滤波数值方案提供了一个统一的框架来模拟大多数多相流的视觉效果(图1)，该框架不仅与许多现有的重心模拟技术一样有效，而且比现有的多相流计算流体动力学方法更加稳定和准确(图7)。</p><h2 id="A-Moving-Least-Square-Reproducing-Kernel-Particle-Method-for-Unified-Multiphase-Continuum-Simulation（纯粒子方法）"><a href="#A-Moving-Least-Square-Reproducing-Kernel-Particle-Method-for-Unified-Multiphase-Continuum-Simulation（纯粒子方法）" class="headerlink" title="A Moving Least Square Reproducing Kernel Particle Method for Unified Multiphase Continuum Simulation（纯粒子方法）"></a>A Moving Least Square Reproducing Kernel Particle Method for Unified Multiphase Continuum Simulation（纯粒子方法）</h2><h3 id="Abstract-2"><a href="#Abstract-2" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        在基于物理的动画中，纯粒子方法因其简单的数据结构、易于实现和方便并行化而广受欢迎。移动最小二乘再生核方法(MLSRK)是一种基于纯粒子的方法，采用Galerkin离散化，在工程计算中发展成为求解偏微分方程的通用数值工具。移动最小二乘法(MLS)的基本思想也被用于计算机图形学中，以估计可变形实体的变形梯度。基于这些先前的研究，我们提出了一个多相MLSRK框架，它以统一的方式模拟复杂和耦合的流体和固体。具体来说，我们使用柯西动量方程和相场模型来统一捕获多相系统中的动量平衡和相演化/相互作用，并系统地制定MLSRK离散化来支持一般的多相本构模型。展示了一系列动画示例，以展示我们新的多相多管火箭发动机框架的性能，包括超弹性、弹塑性、粘性、断裂和多相耦合行为等。</p><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        具有多种物理相互作用的多相材料在我们的日常生活中很常见，例如煎鸡蛋、煮咖啡和蘸面包，但是这些琐碎的现象给计算机模拟带来了非平凡的技术挑战。能够方便地处理多媒体和多物理耦合的仿真框架仍然是基于物理的动画研究的主要目标。由于概念、数据结构和实现的简单性，基于粒子的方法在计算机图形学中被广泛用于动画各种连续体。由于易于实现，粒子可以单独用于模拟，如流行的SPH(平滑粒子流体动力学)方法。与[杨等2017]一起使用的相场模型可以模拟扩散、反应、溶解、熔化等各种现象。粒子还可以与背景网格/栅格相结合，以提高插值精度，例如近年来越来越受到关注的<strong>PIC/MPM(Particle-in-Cell / Material Point Method)</strong>。MPM是众所周知的模拟雪[气孔欣等人，2013年]，并成功模拟了各种材料和相变现象。MPM的多功能性来自于它使用非线性连续体模型的能力。但是背景网格的加入使系统变得更加复杂，这给了我们将一般连续体模型结合到纯粒子方法中的动力。</p><p>​        连续本构模型在MPM被广泛用于制作各种复杂材料的动画，但是由于对导数计算的更高精度要求，在纯基于粒子的模拟中支持它们并不简单。光滑粒子流体力学，顾名思义，历史上主要用于流体模拟。在将SPH推广到固体的尝试中，暴露了原始SPH的许多问题，例如插值不一致性和拉伸不稳定性。在工程计算领域，已经进行了广泛的努力来改进原始的SPH方案以获得更好的精度和稳定性，并且图形社区也采用和进一步发展了这些改进中的一些。例如，线性一致梯度估计[Bonet和Lok  1999]用于弹性和弹塑性固体模拟[Gissler等人2020；Peer等人，2018年]。使用一致插值和伽辽金离散化，RKPM[刘等1995]是另一个众所周知的改进，它被广泛用于工程中模拟各种材料的物理过程。在更广泛的背景下，RKPM可以被看作是移动最小二乘法的一个变种，因此它有时被称为移动最小二乘法[刘等人，1997]。基于点的MLS的一般思想已经在计算机图形学中用于实体仿真[Gerszewski等2009；Jones等人，2014年；穆勒等人，2004年]，主要用于增强可变形固体中变形梯度的估计。然而，与工程领域中的成功应用相比，多层线性系统在提高微分和积分的离散化精度方面的全部潜力似乎没有得到充分开发。多层线性离散化中偏微分方程的统一离散化使得它特别适合于具有多物理相互作用的多相材料的统一模拟。在这些现有研究的基础上，我们提出了一个准线性的多相材料和相变现象统一模拟的MLSRK框架，它是精确的、鲁棒的和纯粹基于粒子的。提出的框架处理固体和流体，并支持弹塑性、断裂和扩散、溶解等多相现象等复杂的材料行为。仅使用粒子数据结构，新的多相MLSRK框架在概念上也比混合方法更简单。</p><h2 id="Fast-Multiple-fluid-Simulation-Using-Helmholtz-Free-Energy"><a href="#Fast-Multiple-fluid-Simulation-Using-Helmholtz-Free-Energy" class="headerlink" title="Fast Multiple-fluid Simulation Using Helmholtz Free Energy"></a>Fast Multiple-fluid Simulation Using Helmholtz Free Energy</h2><h3 id="Abstract-3"><a href="#Abstract-3" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        多流体相互作用是我们经常观察到的一种有趣而常见的视觉现象。在本文中，我们提出了一种基于能量的拉格朗日方法，它扩展了现有多流体方法处理各种现象的能力，如萃取、部分溶解等。基于我们用户可调整的Helmholtz自由能函数，模拟流体从高能状态演变为低能状态，允许灵活捕捉各种混合和解混合过程。我们还扩展了原来的Cahn-Hilliard方程，以更好地模拟复杂的流体-流体相互作用和丰富的视觉现象，如与运动相关的混合和基于位置的模式。我们的方法很容易与现有的最先进的光滑粒子流体动力学(SPH)解算器集成，并且可以在基于位置的动力学(PBD)方法的基础上进一步实现，从而在大时间步长下的拉格朗日模拟期间提高流体的稳定性和不可压缩性。性能分析表明，我们的方法比最先进的多流体方法至少快4倍。提供的例子证明了我们方法的新能力和有效性。</p><p>（Cahn-Hilliard方程来自数学物理，旨在描述相分离的过程。它已被用来模拟许多物理多流体现象）</p><p>现实世界的现象往往会从高能态演变为低能态。在Cahn-Hilliard方程中，能量定律是组分分数变化的主要来源。</p><p>多相流体的状态将向总化学势减小的方向发展，这反过来依赖于亥姆霍兹自由能。亥姆霍兹自由能是决定最终稳定状态的材料内能。通过适当地设置不同形式的亥姆霍兹自由能方程，NSCH模型可以产生各种能量驱动的视觉效果。</p><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        在过去的几年里，多流体模拟受到了图形界越来越多的关注。多相或多组分流体模拟对于从广泛的现实世界现象中再现逼真的视觉效果至关重要，而单相方法不能充分模拟这些现象。以前关于多流体模拟的工作可以分为两大类，分别关注不混溶流体或混溶或分散流体。在前一类中，不同阶段之间存在明确的接口，许多作品(如洪、金2005；洛萨索等人，2006年；Kim  2010Boyd和Bridson  2012Misztal等人，2012年；Da等人[2014])通过跟踪界面获得了视觉上可信的结果。然而，在后一类中，不同相之间没有明确的界面，并且体积分数方法[·米勒等人[2005]已被广泛采用。</p><p>​        以前用于混相多流体模拟混合相或组分的基于网格和粒子的方法主要是根据浓度差[康等人，2010；鲍等2010；刘等人，2011年]或漂移速度[任等人，2014年]。这些模型实现了丰富的视觉效果。然而，这些作品都没有考虑到能量(这是许多现实世界现象所必需的)。物理上，材料从高能级进化到低能级。基于非能量的模型不能容易地或直观地捕捉现象的演变。</p><p>​        我们采用了一个基于能量的模型，并将Cahn-Hilliard 方程集成到多流体模拟中。我们的方法可以潜在地用于模拟与混合和不混合相关的广泛的常见日常现象，例如油和水的混合物。从能量的角度来看，这项工作提供了一种替代方法，扩展了多流体模拟的能力，是灵活和稳定的。我们进一步扩展了原来的Cahn-Hilliard方程，而不是仅仅遵循它，使其能够模拟更复杂和更丰富的视觉现象，如鸡蛋混合物和灰色/彩色图案。</p><h2 id="A-material-point-method-for-snow-simulation"><a href="#A-material-point-method-for-snow-simulation" class="headerlink" title="A material point method for snow simulation"></a>A material point method for snow simulation</h2><h3 id="Abstract-4"><a href="#Abstract-4" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        雪是一种具有挑战性的自然现象，需要视觉模拟。虽然图形社区先前已经考虑了雪的累积和渲染，但是雪动力学的动画还没有被完全解决。此外，现有的固体和流体技术难以产生令人信服的降雪结果。具体来说，既有固体又有液体的潮湿或浓密的雪很难处理。因此，本文提出了一种新的雪模拟方法，该方法采用用户可控的弹塑性本构模型与欧拉/拉格朗日混合材料点法相结合。该方法是基于连续体的，其混合性质允许我们使用规则的笛卡尔网格来自动处理自碰撞和断裂。它也自然地允许我们导出一个基于网格的半隐式积分方案，该方案具有独立于拉格朗日粒子数的条件。我们用各种各样的雪现象，包括复杂的角色互动来展示我们方法的力量。</p><h3 id="Introduction-4"><a href="#Introduction-4" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        不幸的是，雪具有连续变化的相位效应，有时表现为刚性/变形固体，有时表现为流体。因此，代替离散耦合，我们必须在同一领域同时有效地处理连续的材料特性，即使这样的解算器对于单个离散现象可能不是最有效的。</p><p>​        我们提出实现这些目标的两个主要贡献。首先，我们开发了一种半隐式材料点方法(MPM)，专门设计用于有效处理复杂雪景中出现的各种材料刚度、碰撞和拓扑变化。据我们所知，这是MPM第一次被用于图形学。MPM方法将拉格朗日物质粒子(点)与欧拉笛卡尔网格相结合。值得注意的是，不需要拉格朗日网格连接。图形领域的许多研究人员已经尝试了混合网格和粒子方法。例如，朱和昂[2010]使用PIC/FLIP不可压缩流体技术将沙子模拟为流体。事实上，MPMs是作为PIC/FLIP解算器对计算实体的推广而设计的。与PIC/FLIP一样，MPMs使用背景欧拉网格隐式处理自碰撞和断裂。考虑到实际的雪动力学表现出的许多拓扑变化，这是必不可少的。我们的第二个贡献是一个新颖的雪本构模型（材料的应力-应变模型），设计用于用户对实际雪行为的直观控制。这也是为了实现我们的用一个本构关系描述雪行为的多个阶段的目标。</p><h3 id="MPM"><a href="#MPM" class="headerlink" title="MPM"></a>MPM</h3><p>​        材料点法是我们技术的中心。就其核心而言，MPM依赖于连续统近似，避免了对每一个雪粒建模的需要。虽然MPM方法通常使用笛卡尔网格来自动进行拓扑变化和自碰撞，但通过非离散拉格朗日粒子(如SPH)跟踪质量(和其他守恒量)，它的性能优于纯欧拉方法。然而，与SPH不同的是，MPM使用网格作为有效的连续体暂存区，避免了从最近邻居查询中得到的高价通信模式。</p><p>（1）将粒子数据栅格化到网格：将质量、速度从粒子转移到网格</p><p>（2）计算粒子体积和密度：仅第一时间步</p><p>（3）计算网格力：</p><p>（4）更新网格上的速度</p><p>（5）基于网格的物体碰撞</p><p>（6）求解线性系统</p><p>（7）更新形变梯度</p><p>（8）更新粒子速度</p><p>（9）基于粒子的物体碰撞</p><p>（10）更新粒子位置</p><h2 id="Hybrid-Grains-Adaptive-Coupling-of-Discrete-and-Continuum-Simulations-of-Granular-Media（颗粒材料）"><a href="#Hybrid-Grains-Adaptive-Coupling-of-Discrete-and-Continuum-Simulations-of-Granular-Media（颗粒材料）" class="headerlink" title="Hybrid Grains: Adaptive Coupling of Discrete and Continuum Simulations of Granular Media（颗粒材料）"></a>Hybrid Grains: Adaptive Coupling of Discrete and Continuum Simulations of Granular Media（颗粒材料）</h2><h3 id="Abstract-5"><a href="#Abstract-5" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        我们提出了一种模拟颗粒材料的技术，该技术利用了离散和连续处理的双重强度。离散元素模拟提供了无与伦比的细节和通用性，但在应用于大规模系统时证明成本过高。连续体方法在计算上很容易处理，但由于内置的建模假设，适用性有限；例如，适用于颗粒流的模型通常不能捕捉堵塞、反弹和弹道运动。在我们的混合方法中，oracle<strong>动态地将域划分为安全的连续区域和必要的离散区域</strong>。这些区域沿着过渡带重叠，其中拉格朗日动力学质量分裂耦合原理强制两个模拟状态之间的一致性。浓缩和均质化操作允许分区随时间演变。这种方法准确有效地模拟了以前需要完全离散处理的情况。</p><h3 id="Introduction-5"><a href="#Introduction-5" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        我们建议在<strong>安全的情况下采用连续模型，必要时采用离散模型</strong>。我们从连续体模型中获得计算性能，并在需要的地方为颗粒尺度的现象投入额外的计算。</p><p>​        在制定模拟颗粒材料的混合方法时，我们引入了<strong>三个核心贡献</strong>：一种将连续材料点模拟有效地耦合到离散元素模拟的方法，一种根据连续模型识别区域行为的自适应颗粒oracle(在本文中，这些区域基于与颗粒自由表面的距离)，以及一种在连续和离散表示之间动态转换的均匀化和粗化技术。</p><h2 id="The-Affine-Particle-In-Cell-Method"><a href="#The-Affine-Particle-In-Cell-Method" class="headerlink" title="The Affine Particle-In-Cell Method"></a>The Affine Particle-In-Cell Method</h2><h3 id="Abstract-6"><a href="#Abstract-6" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        混合拉格朗日/欧拉模拟在流体和其他经历大变形的材料的计算机图形学中是常见的。在这些方法中，<strong>粒子用于解决传输和拓扑变化，而背景欧拉网格用于计算机械力和碰撞响应</strong>。粒子单元技术，尤其是流体隐式粒子技术，已经成为计算机图形计算的标准。虽然这些方法已被证明非常强大，但它们确实存在一些众所周知的局限性。最初的粒子图像是稳定的，但具有很高的耗散性，而设计用来消除这种耗散性的FLIP噪声更大，有时也不稳定。我们提出了一种新的技术，旨在保持原始图片的稳定性，而不会遭受噪音和倒装不稳定。我们的主要观察是，<strong>原始PIC中的耗散是在网格和粒子表示之间传输时信息丢失的结果</strong>。<strong>我们通过用局部仿射而不是局部恒定的速度描述来增加每个粒子来防止这种信息的丢失</strong>。我们表明，这不仅稳定地消除了粒子间耦合的耗散，而且还允许粒子和网格之间传输的角动量的精确守恒。</p><h3 id="Introduction-6"><a href="#Introduction-6" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        具体来说，粒子和网格自由度的不匹配会导致信息的丢失。由于粒子通常比网格节点多，一些粒子模式不会被网格看到，也不会得到物理响应。这就是所谓的“振铃不稳定性”。</p><p>​        传统粒子模拟方法耗散的一个特别有问题的人为因素是角动量的损失。从网格到粒子的标准粒子图像传输耗散了大量的角动量，这导致了严重的旋转伪影。</p><p>​        当前的状态给我们运行的每个模拟留下了困难的选择：（1）将我们的模拟偏向PIC，以耗散为代价有效地避免不稳定，或者（2）将我们的模拟偏向FLIP，以噪声和可能的不稳定行为为代价获得更活跃的模拟。在本文中，我们提出了第三种选择。（3）特别地，我们通过保持粒子群优化算法的纯滤波特性来控制噪声，但是通过用3×3矩阵丰富每个粒子来最小化信息损失，该矩阵给出了流的局部仿射(而不是局部常数)描述。这种仿射胞内粒子(APIC)方法有效地减少了耗散，保持了角动量和稳定性。此外，我们证明了该方法既适用于不可压缩液体，也适用于材料点法(MPM)模拟。</p><h2 id="A-Polynomial-Particle-In-Cell-Method"><a href="#A-Polynomial-Particle-In-Cell-Method" class="headerlink" title="A Polynomial Particle-In-Cell Method"></a>A Polynomial Particle-In-Cell Method</h2><h3 id="Abstract-7"><a href="#Abstract-7" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        最近江等人提出了仿射细胞内粒子方法；<strong>通过用局部仿射而不是局部恒定的速度描述来增加每个粒子，从而提高粒子在网格中转移的准确性</strong>。这减少了原始粒子图像的耗散，而没有受到历史替代方案流体隐式粒子(FLIP)中存在的噪声的影响。我们通过用一个更一般的局部函数来扩充每个粒子，给出了APIC的一个推广。<strong>通过将网格到粒子的转移视为粒子方向局部网格速度在简化基础上的线性和角动量守恒投影</strong>，我们大大改善了原始APIC上的<strong>能量和涡量守恒</strong>。此外，我们证明了当使用一类特殊的局部多项式函数时，广义投影的成本在APIC上是可以忽略的。最后，我们注意到我们的方法保留了APIC滤波和粒子滤波的特性，因此对噪声具有相似的鲁棒性。</p><h3 id="Introduction-7"><a href="#Introduction-7" class="headerlink" title="Introduction"></a>Introduction</h3><p>​        拉格朗日技术准确地解决了运输现象，并允许简单的渲染。然而，欧拉技术自然解决拓扑变化和接触/碰撞。</p><p>​        粒子像质量和动量一样存储初始状态，但内部应力对动量的影响是在欧拉网格上添加的。这是通过粒子和网格之间的来回转移来协调的。粒子和网格自由度的数量通常不匹配，这可能导致表示之间频繁转换的错误[Brackbill  1988]。原始粒子图像具有稳定的滤波特性，因为粒子速度是在应力响应后从网格中插值得到的。然而，这导致过度耗散，因为粒子模式基本上被通常较低分辨率的网格覆盖。FLIP通过插值速度增量而不是速度本身来消除这种限制，如在PIC中；然而，这意味着尽管没有接收到有意义的本构响应，网格不可见的粒子模式仍然存在。这可能导致粒子伪影，如噪声、不稳定性、结块和体积损失/增加。最近，江等[2015；2017b]开发了一种仿射粒子入射(APIC)方法，旨在防止这些伪影，而不会导致粒子图像的过度耗散。其想法是保留过滤特性，但通过从网格向粒子插入更多信息来防止耗散。通过允许粒子存储速度和速度导数信息，姜等人设计了保存角动量的粒子/网格转移，并且通常获得PIC和FLIP的好处。</p><p>​        我们对这种技术提出了一种改进，它允许对网格速度场进行局部多项式逼近，而不是局部仿射逼近:PolyPIC。我们的概括改进了转移过程中的动能守恒，这导致流体模拟中更好的涡度分辨率和弹塑性模拟中更少的数值阻尼。</p><h2 id="Multiple-Fluid-SPH-Simulation-Using-a-Mixture-Model"><a href="#Multiple-Fluid-SPH-Simulation-Using-a-Mixture-Model" class="headerlink" title="Multiple-Fluid SPH Simulation Using a Mixture Model"></a>Multiple-Fluid SPH Simulation Using a Mixture Model</h2><h3 id="Abstract-8"><a href="#Abstract-8" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        本文介绍了一种通用和稳健的多流体流动SPH模拟方法。不同相或组分的空间分布使用体积分数表示来建模，多流体流动的动力学通过使用改进的混合物模型来捕获，并且稳定和精确的SPH公式被严格地导出以解决在多流体流动中遇到的复杂的传输和转换过程。这种新方法可以捕捉到广泛的真实世界的多流体现象，包括可混溶和不可混溶流体的混合/不混合、扩散效应和化学反应等。此外，新的多流体SPH方案可以很容易地集成到现有的最先进的SPH模拟器，多流体模拟很容易建立。给出了各种例子来证明我们方法的有效性。</p><h2 id="A-Hybrid-Approach-to-Multiple-Fluid-Simulation-using-Volume-Fractions（欧拉方法）"><a href="#A-Hybrid-Approach-to-Multiple-Fluid-Simulation-using-Volume-Fractions（欧拉方法）" class="headerlink" title="A Hybrid Approach to Multiple Fluid Simulation using Volume Fractions（欧拉方法）"></a>A Hybrid Approach to Multiple Fluid Simulation using Volume Fractions（欧拉方法）</h2><h3 id="Abstract-9"><a href="#Abstract-9" class="headerlink" title="Abstract"></a>Abstract</h3><p>​        本文提出了一种混合的多流体模拟方法，可以同时处理可混合和不可混合流体。我们结合距离函数和体积分数，不仅捕捉不混溶流体之间的不连续界面，而且捕捉混溶流体之间的平滑过渡。我们的方法包括四个步骤:速度场计算、体积分数平流、混相流体扩散和可视化。通过提供体积分数和水平集函数之间的组合方案，我们能够利用流体的两种表示方案。从系统的角度来看，我们的工作是<strong>第一个基于欧拉网格的多流体模拟方法</strong>，包括可混溶和不可混溶流体。从技术角度来看，我们的方法解决了因密度和粘度变化以及材料扩散而产生的问题。我们通过实验证明了我们的方法处理多种可混溶和不可混溶流体的有效性。</p>]]></content>
    
    
    <categories>
      
      <category>scientific research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>SPH方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pr make img vedio</title>
    <link href="/2021/01/25/pr-make-img-vedio/"/>
    <url>/2021/01/25/pr-make-img-vedio/</url>
    
    <content type="html"><![CDATA[<h1 id="PR制作图片视频"><a href="#PR制作图片视频" class="headerlink" title="PR制作图片视频"></a>PR制作图片视频</h1><p>1、导入素材</p><p><img src="pr-make-img-vedio\导入.png" alt="导入" style="zoom:100%;" /></p><p>2、新建序列（1080P）</p><p><img src="pr-make-img-vedio\新建序列.png" alt="新建序列" style="zoom:80%;" /></p><p>3、</p>]]></content>
    
    
    <categories>
      
      <category>technological tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>pr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>neighbor_search</title>
    <link href="/2020/12/15/neighbor-search/"/>
    <url>/2020/12/15/neighbor-search/</url>
    
    <content type="html"><![CDATA[<h1 id="SPH-Neighborhood-Search"><a href="#SPH-Neighborhood-Search" class="headerlink" title="SPH Neighborhood Search"></a>SPH Neighborhood Search</h1><h2 id="Neighbor-Search-Characteristics"><a href="#Neighbor-Search-Characteristics" class="headerlink" title="Neighbor Search Characteristics"></a>Neighbor Search Characteristics</h2><ul><li>高效构建和处理动态变化的邻居粒子集</li><li>邻居搜索需要快速存取</li><li>保持时间的一致性</li><li>保持空间局部性</li><li>分层数据结构的效率很低</li><li>首选均匀网格法</li></ul><h2 id="Uniform-Grid-Implementations"><a href="#Uniform-Grid-Implementations" class="headerlink" title="Uniform Grid Implementations"></a>Uniform Grid Implementations</h2><h3 id="Basic-Grid"><a href="#Basic-Grid" class="headerlink" title="Basic Grid"></a>Basic Grid</h3><ul><li>粒子被存储在一个单元网格里，坐标 $(k, l, m)$ </li><li>27个网格需要被邻居搜索查询 $(k\pm1, l\pm1, m\pm1)$</li><li>单元格大小等于粒子影响半径h</li><li>并行构造会受到竞争条件的影响：粒子从不同的线程插入同一个cell</li></ul><h3 id="Index-Sort-Construction"><a href="#Index-Sort-Construction" class="headerlink" title="Index Sort Construction"></a>Index Sort Construction</h3><ul><li>cell index: $c=k+l<em>K+m</em>K*L$  </li><li>粒子根据cell index进行排序</li><li>每个网格单元（k, l, m）存储排序列表中第一个粒子的索引</li><li>可并行性</li><li>内存分配可避免</li><li>内存消耗是常数</li><li>为了找相邻的单元格，需要对整个空间网格进行表示</li></ul><h3 id="Index-Sort-Query"><a href="#Index-Sort-Query" class="headerlink" title="Index Sort Query"></a>Index Sort Query</h3><ul><li>查询已排序的粒子数组（可并行）</li><li>查询同一个cell里的粒子</li><li>获取邻近cell中的粒子</li><li>提高缓存命中率<ul><li>particles in the same cell are close in memory</li><li>particles of neighboring cells are not necessarily close in memory</li></ul></li></ul><h3 id="Z-Index-Sort"><a href="#Z-Index-Sort" class="headerlink" title="Z-Index Sort"></a>Z-Index Sort</h3><ul><li>粒子用一个Z曲线索引排序</li><li><p>提高缓存命中率</p><ul><li>particles in adjacent cells are close in memory</li></ul></li><li><p>有效计算Z曲线索引</p></li></ul><p><img src="neighbor-search\Z-curve.png" alt="Z-curve" style="zoom:50%;" /></p><h3 id="Z-Index-Sort-Sorting"><a href="#Z-Index-Sort-Sorting" class="headerlink" title="Z-Index Sort Sorting"></a>Z-Index Sort Sorting</h3><ul><li>particle attributes 和 z-curve indices 分别处理</li><li><p>句柄（particle identifier, z-curve index）在每个时间步中排序</p><ul><li>reduces memory transfer</li><li>spatial locality is only marginally influenced due to temporal coherence</li></ul></li><li><p>属性集每100个模拟步骤排序一次</p><ul><li>restores spatial locality</li></ul></li><li>采用插入排序代替基排序<ul><li>O (n) for almost sorted arrays</li><li>due to temporal coherence, only 2% of all particles change their cell</li></ul></li></ul><h3 id="Spatial-Hashing"><a href="#Spatial-Hashing" class="headerlink" title="Spatial Hashing"></a>Spatial Hashing</h3><ul><li>哈希函数将网格单元格映射到哈希单元格<ul><li>将无限域映射到有限链表</li><li>与索引排序相比，可以处理无限域</li></ul></li><li>大型哈希表减少哈希冲突的次数<ul><li>如果不同的空间单元被映射到相同的哈希单元格，哈希会发生冲突</li><li>哈希冲突减慢查询速度</li></ul></li><li>减少内存分配<ul><li>为每个哈希单元分配一定数量的内存</li></ul></li><li>减少缓存命中率<ul><li>哈希列表被稀疏填充</li><li>满的和空的单元格是交替的</li></ul></li></ul><h3 id="Compact-Hashing"><a href="#Compact-Hashing" class="headerlink" title="Compact Hashing"></a>Compact Hashing</h3><p><img src="neighbor-search\compact-hashing.png" alt="compact-hashing" style="zoom:70%;" /></p><ul><li>hash cells store handles to a compact list of used cells<ul><li>k entries are pre-allocated for each element in the list of used cells</li><li>elements in the used-cell list are generated if a particle is placed in a new cell</li><li>elements are deleted, if a cell gets empty</li></ul></li><li>memory consumption is reduced from O (m · k) to O (m + n · k) with m » n </li><li>list of used cells is queried in the neighbor search</li></ul><h3 id="Compact-Hashing-1"><a href="#Compact-Hashing-1" class="headerlink" title="Compact Hashing"></a>Compact Hashing</h3><ul><li>not parallelizable<ul><li>particles from different threads might be inserted in the same cell</li></ul></li><li>larger hash table compared to spatial hashing to reducehash collisions</li><li>temporal coherence is employed<ul><li>list of used cells is not rebuilt, but updated</li><li>set of particles with changed cell index is estimated (about 2% of all particles)</li><li>particle is removed from the old cell and added to the new cell (again not parallelizable)</li></ul></li></ul><h3 id="Compact-Hashing-Query"><a href="#Compact-Hashing-Query" class="headerlink" title="Compact Hashing Query"></a>Compact Hashing Query</h3><ul><li>processing of used cells<ul><li>bad spatial locality </li><li>used cells close in memory are not close in space </li></ul></li><li><p>hash-collision flag</p><ul><li>if there is no hash collision in a cell, hash indices of adjacent cells have to be computed only once for all particles in this cell</li><li>large hash table results in 2% cells with hash collisions</li></ul></li><li><p>particles are sorted with respect to a z-curve every 100th step</p></li><li>after sorting, the list of used cells has to be rebuilt</li><li>as particles are serially inserted into the list of used cells, the list is consistent with the z-curve<ul><li>improved cache hit rate during the traversal of the list of used cells</li></ul></li></ul><p><strong>C++ 并行编程: 设定 指令执行顺序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">memory_order</span> &#123;</span><br>    memory_order_relaxed,    <span class="hljs-comment">// 不对执行顺序做保证</span><br>    memory_order_acquire,    <span class="hljs-comment">// 本线程中,所有后续的读操作必须在本条原子操作完成后执行</span><br>    memory_order_release,    <span class="hljs-comment">// 本线程中,所有之前的写操作完成后才能执行本条原子操作</span><br>    memory_order_acq_rel,    <span class="hljs-comment">// 同时包含 memory_order_acquire 和 memory_order_release</span><br>    memory_order_consume,    <span class="hljs-comment">// 本线程中,所有后续的有关本原子类型的操作,必须在本条原子操作完成之后执行</span><br>    memory_order_seq_cst    <span class="hljs-comment">// 全部存取都按顺序执行</span><br>    &#125; memory_order;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>scientific research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>邻居搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ansys learning</title>
    <link href="/2020/11/20/ansys-learning/"/>
    <url>/2020/11/20/ansys-learning/</url>
    
    <content type="html"><![CDATA[<h3 id="了解操作界面"><a href="#了解操作界面" class="headerlink" title="了解操作界面"></a>了解操作界面</h3><h3 id="了解有限元分析基本流程"><a href="#了解有限元分析基本流程" class="headerlink" title="了解有限元分析基本流程"></a>了解有限元分析基本流程</h3><p>分析操作流程：</p><p>模型简化 → CAD模型转化为CAE模型 → （分析类型选择 → 材料加载 → 约束、载荷及接触 → 离散化） → 求解 → 后处理</p><p>用户主界面：</p><p>​        左侧：各种分析模块，常用：静态结构模块。</p><p>​        表格：分析类型的选择；工程数据；几何模型；有限元分析模型；</p><p>DM界面</p><p>材料库界面</p><p>分析界面</p>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ansys</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IISPH</title>
    <link href="/2020/11/09/IISPH/"/>
    <url>/2020/11/09/IISPH/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我们提出了一种用于平滑粒子流体动力学（SPH）的投影方法的新公式。我们将对称的SPH压力和连续性方程的SPH离散化相结合，以获得压力泊松方程（PPE）的离散化形式。与以前的投影方案相比，我们的系统确实考虑了压力的实际计算。这种结合提高了求解器的收敛速度。此外，由于该公式提高了时间积分方案的鲁棒性，因此我们建议基于速度而不是位置来计算密度偏差。我们表明，我们的新型配方优于以前的投影方案和最新的SPH方法。在典型情况下，可以处理大的时间步长和低至0.01％的小密度偏差。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在SPH中强制执行不可压缩性对于模拟场景的视觉质量非常重要</p><p>标准SPH（SSPH）使用状态方程（EOS）来计算压力，该压力会导致破坏当前压缩的力。通过使用用户定义的刚度值对局部评估的压缩权重计算压力。压力值的直接计算使SSPH非常适用于可压缩流体的有效仿真。对于弱可压缩流体（WCSPH），使用了相当坚硬的EOS，它施加了严格的时间步长限制，从而限制了整体性能。</p><p>SSPH的性能已通过基于EOS的预测器校正器方案（例如PCISPH和local Poisson SPH）得到了显着改善。将压力建模为约束力，以解决由非压力引起的压缩。通过基于EOS迭代地预测和校正粒子位置来计算相应的压力值。这些方法仍然依赖于局部信息，但是与SSPH和WCSPH相比，EOS不包含用户定义的刚度参数。与WCSPH相比，PCISPH和local Poisson SPH处理的时间步长最多高两个数量级，而相对于WCSPH的整体加速分别可以达到55或23。</p><p>作为使用局部计算的惩罚力的EOS方法的替代方法，也可以使用投影方案来计算SPH中的压力场。首先，在不考虑压力的情况下预测中间速度。然后，求解PPE以计算压力，以使所产生的压力将中间速度校正为无散度状态。在拉格朗日方法中，可以根据泊松公式中的源项来区分投影方案。在此，要么是中间速度场的散度，要么是由于中间速度场引起的压缩，或者是两者都使用。由于不可压缩性是逼真的流体动画的重要组成部分，因此在SPH中似乎首选压缩方式。如移动粒子半隐式方法（MPS），仅使用发散项往往会导致可感知的压缩。</p><p>拉普拉斯算子与SPH的数值挑战性近似是SPH投影方案中的主要问题。已知使用二阶核导数直接离散化Laplace运算符对采样敏感。例如，在[18]，[11]中对此进行了讨论，其中提出了近似值。为了避免拉普拉斯算子的SPH离散化，一些作者建议以不同的（通常是较低的）分辨率来计算背景网格上的压力场。在将压力值从网格传递到粒子后，可以使用[21]中的EOS细化粒子压力值。</p><p>SPH投影方案，也称为不可压缩SPH（ISPH）方法，目前在计算机图形环境中被认为是不切实际的。ISPH的性能无法在问题域中很好地扩展，对于大型方案尤其如此。我们的工作解决了这一点。我们建议对PPE进行离散化处理，以显着提高求解器的收敛性和时间积分方案的稳定性。这不仅与以前的ISPH方法相比，而且与当前的最新技术PCISPH相比，都显着提高了速度。在典型情况下，可以处理大的时间步长和低至0.01％的小密度偏差。与以前的投影方案相比，该方法在仿真领域可以很好地扩展。</p><h2 id="Implicit-Incompressible-SPH-IISPH"><a href="#Implicit-Incompressible-SPH-IISPH" class="headerlink" title="Implicit Incompressible SPH (IISPH)"></a>Implicit Incompressible SPH (IISPH)</h2><p>EOS计算压力p：</p><script type="math/tex; mode=display">p_i(t) = \frac{\kappa ρ_0}{\gamma}\left(\left(\frac{ρ_i(t)}{ρ_0} \right)^{\gamma} -1 \right) \quad\quad (1)</script><p>动量守恒的压力计算：</p><script type="math/tex; mode=display">F_i^p(t) = -m_i \sum_j m_j \left( \frac{p_i(t)}{ρ_i^2(t)} + \frac{p_j(t)}{ρ_j^2(t)} \right) \nabla W_{ij}(t)  \quad\quad (2)</script><p>IISPH方法通过迭代求解线性系统来计算压力。为了建立具有未知压力值的系统，我们主要采用连续性方程的离散形式和投影概念。</p><p>continuity equation</p><script type="math/tex; mode=display">\frac{Dρ}{Dt} = -ρ\nabla \cdot \mathbf{v}</script><p>速度散度：</p><script type="math/tex; mode=display">\nabla \cdot \mathbf{v}_i = -\frac{1}{ρ_i} \sum_j m_j \mathbf{v}_{ij} \nabla W_{ij}</script><p>离散化：</p><script type="math/tex; mode=display">\frac{ρ_i(t + \Delta t)-ρ_i(t)}{\Delta t} = \sum_j m_j \mathbf{v}_{ij}(t+\Delta t) \nabla W_{ij}(t)  \quad\quad(3)</script><p>半隐式欧拉法更新位置和速度：</p><script type="math/tex; mode=display">\mathbf{v}_i(t+\Delta t) = \mathbf{v}_i(t) + \Delta t \frac{F_i^{adv}(t)+F_i^p(t)}{m_i}</script><p>中间速度：</p><script type="math/tex; mode=display">\mathbf{v}_i^{adv} = \mathbf{v}_i(t) + \Delta t \frac{F_i^{adv}(t)}{m_i}</script><p>中间密度：（预测步骤）</p><script type="math/tex; mode=display">ρ_i^{adv} = ρ_i(t) + \Delta t \sum_j m_j \mathbf{v}_{ij}^{adv} \nabla W_{ij}(t) \quad\quad(4)</script><p>PPE：</p><script type="math/tex; mode=display">\Delta t^2 \nabla^2 p_i = ρ_0 - ρ_i^{adv}</script><p>不可压缩性：通过压力来解决压缩问题，恢复与静止密度的偏差。（用于计算压力的PPE）</p><script type="math/tex; mode=display">\Delta t^2 \sum_j m_j \left(\frac{F_i^p(t)}{m_i} - \frac{F_j^p(t)}{m_j} \right)\nabla W_{ij}(t) = ρ_0 - ρ_i^{adv}  \quad\quad (5)</script><p>（2）—&gt;（5）</p><script type="math/tex; mode=display">\sum_j a_{ij}p_j = b_i = ρ_0 - ρ_i^{adv} \quad\quad (6)</script><p>矫正速度：</p><script type="math/tex; mode=display">\mathbf{v}_i(t + \Delta t) = \mathbf{v}_i^{adv} + \Delta t F_i^p(t)/m_i</script><p>由于以下讨论的两个新颖方面，我们的公式显着改善了求解器的收敛性和时间积分方案的稳定性：</p><p>离散化拉普拉斯算子：</p><p>这些ISPH方法从PPE的连续形式开始。然后，他们离散拉普拉斯算子和源项。所得系统不考虑最终从压力场导出的压力。因此，没有与计算的压力场有特殊关系的压力的区别形式。相反，我们的推导考虑了压力和压力之间的关系。首先，我们不是从一个连续的PPE开始，而是从离散化的连续连续性方程开始。这种离散化的主要目标是在最终速度更新中使用的压力项表示。因此，我们最终可以应用压力场计算中所考虑的压力的特殊形式。这种合并提高了收敛速度和整体性能。</p><p>源项：根据预测的位置计算：</p><script type="math/tex; mode=display">ρ_i(t+\Delta t) = \sum_j m_j W ( x_i^* - x_j^*, h ) \quad\quad (7)</script><p>但是，求解（7）意味着邻域的重新计算。在PCISPH中，仅通过更新当前邻域的距离就可以避免这种开销。这就引入了一个误差，对于更大的位移，误差会变得更大：</p><script type="math/tex; mode=display">\Delta {\bf x}_i = \Delta t{\bf v}_i^{adv}+ \Delta t^2 {\bf F}^p_i/m_i</script><p>而IISPH根据速度预测密度，避免邻域的近似更新，可以忍受更大的时间步长，从而提高了时间积分方案的鲁棒性。</p><h2 id="Solver"><a href="#Solver" class="headerlink" title="Solver"></a>Solver</h2><h3 id="Relaxed-Jacobi"><a href="#Relaxed-Jacobi" class="headerlink" title="Relaxed Jacobi"></a>Relaxed Jacobi</h3><p>使用松弛雅克比，我们迭代求解（6）的各个压力值pi：</p><script type="math/tex; mode=display">p_i^{l+1} = (1-\omega) p_i^l + \omega {\rho_0 - \rho_i^{adv}- \sum_{j\ne i} a_{ij} p_j^{l}\over a_{ii} } \quad \quad(8)</script><p> ω 称为松弛因子</p><p>为了提取系数，将由压力引起的位移重写为：</p><script type="math/tex; mode=display">\eqalign{\Delta t^2 { {\bf F}_i^{p}\over m_i} &= - \Delta t^2 \sum_j m_j \left( {p_i\over \rho_i^2} +{ p_j\over \rho_j^2} \right) \nabla W_{ij} \cr &= \underbrace{\Big (- \Delta t^2 \sum_j {m_j\over \rho_i^2} \nabla W_{ij}\Big) }_{ {\bf d}_{ii} } p_i+ \sum_j\underbrace{-\Delta t^2 {m_j\over \rho_j^2} \nabla W_{ij} }_{ {\bf d}_{ij} } p_j} \quad\quad (9)</script><p>将（9）插入（5），k是j的邻居粒子：</p><script type="math/tex; mode=display">\rho_0 - \rho_i^{adv} = \sum_j m_j \bigg({\bf d}_{ii} p_i + \sum_j {\bf d}_{ij} p_j - {\bf d}_{jj} p_j - \sum_k {\bf d}_{jk} p_k\bigg) \nabla W_{ij} \quad\quad(10)</script><p>分离pi：</p><script type="math/tex; mode=display">\sum_k {\bf d}_{jk} p_k = \sum_{k\ne i}{\bf d}_{jk} p_k + {\bf d}_{ji} p_i  \quad\quad(11)</script><p>整理（10）：</p><script type="math/tex; mode=display">\eqalign{\rho_0 - \rho_i^{adv} &=p_i \sum_j m_j ({\bf d}_{ii} - {\bf d}_{ji})\nabla W_{ij} \cr &\quad+ \sum_j m_j \bigg (\sum_j {\bf d}_{ij} p_j - {\bf d}_{jj} p_j - \sum_{k\ne i}{\bf d}_{jk} p_k\bigg) \nabla W_{ij}}</script><script type="math/tex; mode=display">a_{ii} = \sum_j m_j ({\bf d}_{ii} - {\bf d}_{ji})\nabla W_{ij} \quad\quad(12)</script><script type="math/tex; mode=display">\eqalign{p_i^{l+1} &= (1-\omega) p_i^{l} + \omega {1\over a_{ii}} \bigg (\rho_0 - \rho_i^{adv} \cr &\quad- \sum_j m_j \bigg(\sum_j {\bf d}_{ij} p^{l}_j - {\bf d}_{jj} p^{l}_j - \sum_{k\ne i}{\bf d}_{jk} p^{l}_k\bigg) \nabla W_{ij}\bigg)} \quad\quad(13)</script><p><img src="F:\blog\source\_posts\IISPH\algorithm.png" alt="algorithm" style="zoom:80%;" /></p><h2 id="Boundary-Handling"><a href="#Boundary-Handling" class="headerlink" title="Boundary Handling"></a>Boundary Handling</h2><h2 id="RESULTS"><a href="#RESULTS" class="headerlink" title="RESULTS"></a>RESULTS</h2><h3 id="5-1-Convergence-Criterion"><a href="#5-1-Convergence-Criterion" class="headerlink" title="5.1 Convergence Criterion"></a>5.1 Convergence Criterion</h3><h3 id="5-2-Performance-Comparisons"><a href="#5-2-Performance-Comparisons" class="headerlink" title="5.2 Performance Comparisons"></a>5.2 Performance Comparisons</h3><h3 id="5-3-Large-Scale-Scenarios"><a href="#5-3-Large-Scale-Scenarios" class="headerlink" title="5.3 Large Scale Scenarios"></a>5.3 Large Scale Scenarios</h3><p>状态方程：</p><script type="math/tex; mode=display">p_i = k(\frac{\rho_i}{\rho_0}-1) \quad\quad p_i = k(\rho_i - \rho_0)</script><p>泰特方程：</p><script type="math/tex; mode=display">p_i = k \left(\left(\frac{\rho_i}{\rho_0}\right)^7 -1\right)</script><p>分割压力和非压力加速度：</p><script type="math/tex; mode=display">\frac{D\mathbf{v}(t)}{Dt} = - \frac{1}{\rho (t)}\nabla p(t) + \mathbf{a}^{nonp}(t)</script><p>预测无压力加速度后的速度:</p><script type="math/tex; mode=display">\boldsymbol{v}^* = \boldsymbol{v}(t) + \Delta t \boldsymbol{a}^{nonp}(t)</script><p>计算压力后校正速度：</p><script type="math/tex; mode=display">\boldsymbol{v}(t+\Delta t) = \boldsymbol{v}^* - \Delta t \frac{1}{\rho(t)}\nabla p(t)</script><p>连续方程：</p><script type="math/tex; mode=display">\frac{D\rho_i}{Dt} = -\rho_i \nabla \cdot \boldsymbol{v}_i</script><p>速度散度：</p><script type="math/tex; mode=display">\nabla \cdot \boldsymbol{v}^* + \nabla \cdot (-\Delta t \frac{1}{\rho} \nabla p) = 0</script><p>密度不变性：</p><script type="math/tex; mode=display">\frac{\rho_0 - \rho^*}{\Delta t} + \rho \nabla \cdot(- \Delta t \frac{1}{\rho} \nabla^2 p) = 0</script><script type="math/tex; mode=display">\rho_i = \sum_j m_j W_{ij}</script><script type="math/tex; mode=display">\rho_i = \sum_j m_i W_{ij}</script><p>PCISPH</p><script type="math/tex; mode=display">\rho(t+\Delta t) = \rho_0 = \sum_j m_j W_{ij} + \Delta t \sum_j m_j(\boldsymbol{v}_i^* - \boldsymbol{v}_j^*)\nabla W_{ij} + \Delta t \sum_j m_j(\Delta t \boldsymbol{a}_i^p - \Delta t \boldsymbol{a}_j^p)\nabla W_{ij}</script><script type="math/tex; mode=display">\rho_i^*</script>]]></content>
    
    
    <categories>
      
      <category>scientific research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>SPH方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重燃project</title>
    <link href="/2020/09/20/%E9%87%8D%E7%87%83project/"/>
    <url>/2020/09/20/%E9%87%8D%E7%87%83project/</url>
    
    <content type="html"><![CDATA[<p><em>没接触过diango啊，从零开始学起吧，边解决问题边学习。</em></p><h3 id="部署时连不到数据库"><a href="#部署时连不到数据库" class="headerlink" title="部署时连不到数据库"></a>部署时连不到数据库</h3><p>把MySQL服务关掉可以解决。猜测是127.0.0.1连接问题。</p><h2 id="task1：前端用户注册改为手机号验证"><a href="#task1：前端用户注册改为手机号验证" class="headerlink" title="task1：前端用户注册改为手机号验证"></a>task1：前端用户注册改为手机号验证</h2><h3 id="源代码学习"><a href="#源代码学习" class="headerlink" title="源代码学习"></a>源代码学习</h3><p><em>urls.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">urlpatterns = [<br>    path(<span class="hljs-string">&#x27;login&#x27;</span>, views.LoginView.as_view()),<br>    path(<span class="hljs-string">&#x27;register&#x27;</span>, views.RegisterView.as_view()),<br>    path(<span class="hljs-string">&#x27;index&#x27;</span>, views.IndexView.as_view()),<br>    path(<span class="hljs-string">&#x27;mypage&#x27;</span>, views.UpdateView.as_view()),<br>]<br></code></pre></td></tr></table></figure><p><strong>urlpatterns</strong> 在url文件中是一个url映射列表。系统会自动遍历url文件中的urlpatterns列表然后进行对应的处理函数查找。当url有重复的情况则以找到的第一个为准。</p><p><strong>Django怎么处理请求：</strong></p><ul><li>一旦生成url页面请求，请求传递到urls.py；</li><li>Django去urlpatterns中匹配链接（Django会在匹配到的第一个就停下来）；</li><li>一旦匹配成功，就会去执行，path后面的方法，Django便会给出相应的view页面（该页面可以为一个Python的函数，或者基于view（Django内置的）的类），也就是用户看到的页面；</li><li>若匹配失败，则出现错误的页面。</li></ul><p><strong>as_view()方法：</strong></p><ol><li>前端发送请求，方法可能是post或get</li><li>url()定位到类(view)方法as_view()</li><li>as_view()返回一个view方法，view转到dispatch()</li><li>dispatch()会自动判断当前的请求方式</li></ol><p><em>models.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebUser</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;网站用户表，主要用于衡量职工是否可以注册自己的账户并访问数据库网站&quot;&quot;&quot;</span><br>    nickname = models.CharField(max_length=<span class="hljs-number">64</span>, verbose_name=<span class="hljs-string">&#x27;昵称&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>)<br>    realname = models.CharField(max_length=<span class="hljs-number">32</span>, verbose_name=<span class="hljs-string">&#x27;真实姓名&#x27;</span>, help_text=<span class="hljs-string">&#x27;员工的名字&#x27;</span>, db_index=<span class="hljs-literal">True</span>)<br>    gender_choices = (<br>        (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;未知&#x27;</span>),<br>        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;男&#x27;</span>),<br>        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;女&#x27;</span>),<br>    )<br>    gender = models.IntegerField(choices=gender_choices, verbose_name=<span class="hljs-string">&#x27;性别&#x27;</span>, default=<span class="hljs-number">0</span>)<br>    idcard = models.CharField(max_length=<span class="hljs-number">18</span>, verbose_name=<span class="hljs-string">&#x27;身份证号&#x27;</span>, help_text=<span class="hljs-string">&#x27;18位的身份证号码&#x27;</span>)<br>    phone = models.CharField(max_length=<span class="hljs-number">11</span>, verbose_name=<span class="hljs-string">&#x27;手机号&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>)<br>    password = models.CharField(max_length=<span class="hljs-number">64</span>, verbose_name=<span class="hljs-string">&#x27;密码&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>)<br>    email = models.EmailField(max_length=<span class="hljs-number">64</span>, verbose_name=<span class="hljs-string">&#x27;邮箱&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>)<br>    birthday = models.DateField(verbose_name=<span class="hljs-string">&#x27;生日&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>)<br>    department = models.ForeignKey(to=Department, on_delete=models.CASCADE, blank=<span class="hljs-literal">False</span>, null=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;部门&#x27;</span>, db_index=<span class="hljs-literal">True</span>)<br>    enable = models.BooleanField(verbose_name=<span class="hljs-string">&#x27;状态&#x27;</span>, default=<span class="hljs-literal">True</span>)<br>    create_time = models.DateTimeField(verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>, auto_now_add=<span class="hljs-literal">True</span>)<br>    update_time = models.DateTimeField(verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>, auto_now=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        verbose_name = <span class="hljs-string">&quot;员工&quot;</span><br>        verbose_name_plural = <span class="hljs-string">&quot;员工管理&quot;</span><br>        db_table = <span class="hljs-string">&quot;T_WebUser&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.realname<br></code></pre></td></tr></table></figure><p><strong>表字段及说明</strong></p><div class="table-container"><table><thead><tr><th>表字段</th><th>说明</th></tr></thead><tbody><tr><td>models.AutoField</td><td>默认会生成一个名为id的字段并未int类型</td></tr><tr><td>models.CharField</td><td>字符串类型</td></tr><tr><td>models.BooleanField</td><td>布尔类型</td></tr><tr><td>models.DateField</td><td>日期（Date）类型</td></tr><tr><td>models.DateTimeField</td><td>日期（datetime）类型</td></tr><tr><td>models.EmailField</td><td>字符串类型（正则表达式邮箱）</td></tr><tr><td>models.FloatField</td><td>浮点类型</td></tr><tr><td>models.IntegerField</td><td>整数类型</td></tr><tr><td>models.TextField</td><td>长文本类型</td></tr><tr><td>models. TimeField</td><td>时间类型， 显示时分秒HH:MM[:ss[ .uuuuuu]]</td></tr><tr><td>models. URLField</td><td>字符串， 地址为正则表达式</td></tr><tr><td>models.FilePathField</td><td>Django Admin以及ModelForm中提供读取文件夹下文件的功能<br />参数：<br />        path：文件夹路径<br />        match=None：正则匹配<br />        recursive=False：递归下面的文件夹<br />        allow_files=True：允许文件<br />        allow_folders=False：允许文件夹</td></tr><tr><td>models.FileField</td><td>路径保存在数据库，文件上传到指定目录<br />参数：<br />        upload_to = “”          上传文件的保存路径<br />        storage = None         存储组件，默认django.core.files.storage.FileSystemStorage</td></tr><tr><td>models.ForeignKey(other_table)</td><td>创建外键(即创建一对多的表的关联)<br />参数:<br />        to=:          要进行关联的表名<br />        to_field=:     要关联的表中的字段名称<br />        on_delete=:   当删除关联表中的数据时，当前表与其关联的行的行为<br />        on_delete的参数:<br />               - models.CASCADE          删除关联数据，与之关联也删除<br />               - models.DO_NOTHING       删除关联数据，引发错误IntegrityError<br />               - models.PROTECT          删除关联数据，引发错误ProtectedError<br />               - models.SET_NULL          删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）<br />               - models.SET_DEFAULT      删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）<br />               - models.SET               删除关联数据</td></tr></tbody></table></div><p><strong>表字段参数及说明</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Null</td><td>数据库中字段是否可以为空</td></tr><tr><td>db_column</td><td>数据库中字段的列名</td></tr><tr><td>db_tablespace</td><td>表空间，如果该字段已经创建了索引，那么数据库表空间的名称将作为该字段的索引名。</td></tr><tr><td>default</td><td>数据库中字段的默认值</td></tr><tr><td>primary_key</td><td>数据库中字段是否为主键</td></tr><tr><td>db_index</td><td>数据库中字段是否可以建立索引</td></tr><tr><td>unique</td><td>数据库中字段是否可以建立唯一索引</td></tr><tr><td>verbose_name</td><td>Admin中显示的字段名称</td></tr><tr><td>blank</td><td>Admin中是否允许用户输入为空</td></tr><tr><td>editable</td><td>Admin中是否可以编辑</td></tr><tr><td>help_text</td><td>Admin中该字段的提示信息</td></tr><tr><td>choices</td><td>Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作</td></tr><tr><td>error_messages</td><td>自定义错误信息(字典类型)从而,定制想要显示的错误信息</td></tr></tbody></table></div><p><strong>class Meta</strong></p><p>通过一个内嵌类 “class Meta” 给你的 model 定义元数据</p><ul><li>verbose_name：给你的模型类起一个更可读的名字</li><li>verbose_name_plural：模型的复数形式</li><li>db_table：用于指定自定义数据库表名</li></ul><p><em>views.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegisterView</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;注册&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        res = BaseResponse()<br>        <span class="hljs-comment">#nickname = request.data.get(&#x27;nickname&#x27;)</span><br>        realname = request.data.get(<span class="hljs-string">&#x27;realname&#x27;</span>)<br>        idcard = request.data.get(<span class="hljs-string">&#x27;idcard&#x27;</span>)<br>        <span class="hljs-comment">#password = request.data.get(&#x27;password&#x27;)</span><br>        user_obj = models.WebUser.objects.<span class="hljs-built_in">filter</span>(realname=realname)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user_obj.exists():<br>            <span class="hljs-comment">#返回错误信息</span><br>            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">10020</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;您没有注册权限！请联系管理员申请！&#x27;</span>&#125;)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> user_obj:<br>                <span class="hljs-keyword">if</span> user.idcard[-<span class="hljs-number">6</span>:] == idcard:<br>                    serializer = serializers.RegisterSerializer(user, data=request.data)<br>                    <span class="hljs-keyword">if</span> serializer.is_valid():<br>                        user = serializer.save()<br>                    <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: res.data&#125;)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment">#返回错误信息</span><br>                    <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">10050</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;您的身份证后六位输入错误，请重新输入！&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>先判断数据库中是否有该员工，是否有注册权限。</p><p>然后根据身份证后6位验证。</p><p>调用serializers.RegisterSerializer，update实例。</p><p>判断serializer是否实例化，修改user实例。</p><p><strong>表操作</strong></p><p>增</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># method1</span><br>models.Host.objects.create(hostname=<span class="hljs-string">&#x27;xx&#x27;</span>,ip=<span class="hljs-string">&#x27;xx&#x27;</span>,...)  <span class="hljs-comment">#增加一条数据，可以接受字典类型数据 **kwargs</span><br><span class="hljs-comment"># method2</span><br>obj = models.Host(hostname=<span class="hljs-string">&#x27;xx&#x27;</span>,ip=<span class="hljs-string">&#x27;xx&#x27;</span>,...)<br>obj.save()<br></code></pre></td></tr></table></figure><p>删</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">models.Host.objects.<span class="hljs-built_in">filter</span>(hostname=<span class="hljs-string">&#x27;xxx&#x27;</span>).delete()       <span class="hljs-comment">#删除指定条件的数据</span><br></code></pre></td></tr></table></figure><p>改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">models.Host.objects.<span class="hljs-built_in">filter</span>(hostname=<span class="hljs-string">&#x27;xx&#x27;</span>).update(ip=<span class="hljs-string">&#x27;xxx&#x27;</span>)  <span class="hljs-comment">#将指定条件的数据更新，均支持 **kwargs</span><br>obj = models.Host.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)<br>obj.ip = <span class="hljs-string">&#x27;xx&#x27;</span><br>obj.save()                                                  <span class="hljs-comment">#修改单条数据</span><br></code></pre></td></tr></table></figure><p>查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">models.Tb1.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>)                         <span class="hljs-comment"># 获取单条数据，不存在则报错(不建议使用)</span><br>models.Tb1.objects.<span class="hljs-built_in">all</span>()                             <span class="hljs-comment"># 获取全部</span><br>models.Tb1.objects.<span class="hljs-built_in">filter</span>(name=<span class="hljs-string">&#x27;seven&#x27;</span>).first()      <span class="hljs-comment"># 获取指定条件的数据</span><br></code></pre></td></tr></table></figure><p><em>serializers.py</em></p><h3 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h3><p>首先修改前端</p><p>后端：</p><p><em>views.py</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">idcard = request.data.get(<span class="hljs-string">&#x27;idcard&#x27;</span>)<br></code></pre></td></tr></table></figure><p>改为：</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">phone = request.data.get(<span class="hljs-string">&#x27;phone&#x27;</span>)<br></code></pre></td></tr></table></figure></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user.idcard[-<span class="hljs-number">6</span>:] == idcard:<br></code></pre></td></tr></table></figure><p>改为：</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user.phone[-<span class="hljs-number">4</span>:] == phone:<br></code></pre></td></tr></table></figure></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.core.exceptions <span class="hljs-keyword">import</span> ValidationError<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># 验证电话号码是否合法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_phone</span>(<span class="hljs-params">value</span>):</span><br>    p = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d&#123;8&#125;$&#x27;</span>)<br>    <span class="hljs-keyword">if</span> p.match(value) == <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> ValidationError(message=<span class="hljs-string">&quot;电话号码不合法&quot;</span>)<br>    exists = WebUser.objects.<span class="hljs-built_in">filter</span>(phone=value).exists()<br>    <span class="hljs-keyword">if</span> exists:<br>        <span class="hljs-keyword">raise</span> ValidationError(message=<span class="hljs-string">&quot;此手机号码已经被注册&quot;</span>)<br>        <br>phone = models.CharField(max_length=<span class="hljs-number">11</span>, verbose_name=<span class="hljs-string">&#x27;手机号&#x27;</span>, validators=[validate_phone])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> user.phone[-<span class="hljs-number">4</span>:] == phone:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    serializer = serializers.RegisterSerializer(user, data=request.data)</span><br><span class="hljs-string">    if serializer.is_valid():</span><br><span class="hljs-string">        user = serializer.save()</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    user.nickname = request.data.get(<span class="hljs-string">&#x27;nickname&#x27;</span>, user.nickname)<br>    exists = models.WebUser.objects.<span class="hljs-built_in">filter</span>(nickname=user.nickname).exists()<br>    <span class="hljs-keyword">if</span> exists:<br>        <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">10040</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;该用户名已存在，请重新输入！&#x27;</span>&#125;)<br>    hash_key = <span class="hljs-string">&#x27;password&#x27;</span><br>    password = request.data.get(<span class="hljs-string">&#x27;password&#x27;</span>) + hash_key<br>    password_md5 = hashlib.md5(password.encode()).hexdigest()<br>    user.password = password_md5<br>    user.save()<br>    <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: res.data&#125;)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment">#返回错误信息</span><br>    <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">10050</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;您的电话号码后四位输入错误，请重新输入！&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>前端：npm run dev 报错</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">you can run: npm install --save !!vue-styles-loader!css-loader?<br></code></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm install sass-loader --save<br>npm install <span class="hljs-keyword">node</span><span class="hljs-title">-sass</span> --save<br></code></pre></td></tr></table></figure><p>意见反馈表models.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> extra_apps.DjangoUeditor.models <span class="hljs-keyword">import</span> UEditorField<br><br><span class="hljs-comment"># Create your models here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackTable</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-string">&quot;意见反馈表&quot;</span><br>    feedback = UEditorField(verbose_name=<span class="hljs-string">&quot;反馈意见&quot;</span>, imagePath=<span class="hljs-string">&quot;articles/images/&quot;</span>+<span class="hljs-string">&quot;/%(basename)s_%(basename)s_%(datetime)s.%(extname)s&quot;</span>, width=<span class="hljs-number">1000</span>, height=<span class="hljs-number">300</span>,<br>                            filePath=<span class="hljs-string">&quot;articles/files/&quot;</span>, default=<span class="hljs-string">&#x27;&#x27;</span>)<br>    username = models.CharField(max_length=<span class="hljs-number">32</span>, verbose_name=<span class="hljs-string">&#x27;留言人&#x27;</span>, blank=<span class="hljs-literal">True</span>, null=<span class="hljs-literal">True</span>)<br>    ip_address = models.CharField(max_length=<span class="hljs-number">32</span>, verbose_name=<span class="hljs-string">&#x27;IP地址&#x27;</span>, blank=<span class="hljs-literal">True</span>, null=<span class="hljs-literal">True</span>)<br>    time = models.DateTimeField(verbose_name=<span class="hljs-string">&#x27;留言时间&#x27;</span>, auto_now=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        verbose_name = <span class="hljs-string">&quot;意见反馈&quot;</span><br>        verbose_name_plural = <span class="hljs-string">&quot;意见反馈&quot;</span><br>        db_table = <span class="hljs-string">&quot;T_Feedback&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>)<br></code></pre></td></tr></table></figure><p>admin.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> FeedbackTable<br><br><span class="hljs-meta">@admin.register(<span class="hljs-params">FeedbackTable</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackAdmin</span>(<span class="hljs-params">admin.ModelAdmin</span>):</span><br>    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;feedback&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;ip_address&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>)<br>    search_fields = (<span class="hljs-string">&#x27;feedback&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>)<br>    list_per_page = <span class="hljs-number">20</span><br>    list_filter = (<span class="hljs-string">&#x27;ip_address&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>)<br></code></pre></td></tr></table></figure><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> url<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;feedback&#x27;</span>, views.FeedbackView.as_view()),<br>]<br></code></pre></td></tr></table></figure><p>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> APIView<br><span class="hljs-keyword">from</span> rest_framework.response <span class="hljs-keyword">import</span> Response<br><span class="hljs-keyword">from</span> apps.Feedback <span class="hljs-keyword">import</span> models<br><br><span class="hljs-comment"># Create your views here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackView</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;意见反馈&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        feedback = request.POST.get(<span class="hljs-string">&#x27;feedback&#x27;</span>)<br>        <span class="hljs-keyword">if</span> feedback <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">1010</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;留言不能为空！&#x27;</span>&#125;)<br>        username = request.POST.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>        ip_address = self.get_ip(request)<br>        models.FeedbackTable.objects.create(<br>            feedback = feedback,<br>            username = username,<br>            ip_address = ip_address<br>        )<br>        <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;留言成功！感谢您的建议&#x27;</span>&#125;)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_ip</span>(<span class="hljs-params">request</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;获取请求者的IP信息&#x27;&#x27;&#x27;</span><br>        x_forwarded_for = request.META.get(<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>)  <span class="hljs-comment"># 判断是否使用代理</span><br>        <span class="hljs-keyword">if</span> x_forwarded_for:<br>            ip = x_forwarded_for.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 使用代理获取真实的ip</span><br>        <span class="hljs-keyword">else</span>:<br>            ip = request.META.get(<span class="hljs-string">&#x27;REMOTE_ADDR&#x27;</span>)  <span class="hljs-comment"># 未使用代理获取IP</span><br>        <span class="hljs-keyword">return</span> ip<br></code></pre></td></tr></table></figure><p>Feedback</p><p>models.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> extra_apps.DjangoUeditor.models <span class="hljs-keyword">import</span> UEditorField<br><span class="hljs-keyword">from</span> ckeditor_uploader.fields <span class="hljs-keyword">import</span> RichTextUploadingField<br><br><span class="hljs-comment"># Create your models here.</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackTable</span>(<span class="hljs-params">models.Model</span>):</span><br>    <span class="hljs-string">&quot;意见反馈表&quot;</span><br>    title = models.CharField(max_length=<span class="hljs-number">100</span>, verbose_name=<span class="hljs-string">&quot;标题&quot;</span>, default=<span class="hljs-string">&#x27;&#x27;</span>)<br>    username = models.CharField(max_length=<span class="hljs-number">32</span>, verbose_name=<span class="hljs-string">&#x27;留言人&#x27;</span>, blank=<span class="hljs-literal">True</span>, null=<span class="hljs-literal">True</span>)<br>    content = RichTextUploadingField(verbose_name=<span class="hljs-string">&#x27;反馈内容&#x27;</span>, default=<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-comment"># files = models.ManyToManyField(Files, related_name=&#x27;files&#x27;)</span><br>    status_choices = (<br>        (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;已接收&#x27;</span>),<br>        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;已反馈&#x27;</span>),<br>        (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;处理中&#x27;</span>),<br>        (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;已完成&#x27;</span>),<br>        (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;忽视&#x27;</span>)<br>    )<br>    status = models.IntegerField(choices=status_choices, verbose_name=<span class="hljs-string">&#x27;状态&#x27;</span>, default=<span class="hljs-number">0</span>)<br>    time = models.DateTimeField(verbose_name=<span class="hljs-string">&#x27;留言时间&#x27;</span>, auto_now=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        verbose_name = <span class="hljs-string">&quot;意见反馈&quot;</span><br>        verbose_name_plural = <span class="hljs-string">&quot;意见反馈&quot;</span><br>        db_table = <span class="hljs-string">&quot;T_Feedback&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Files</span>(<span class="hljs-params">models.Model</span>):</span><br>    file = models.FileField(upload_to=<span class="hljs-string">&#x27;feedback/file/%Y-%m-%d/&#x27;</span>, null=<span class="hljs-literal">True</span>, blank=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&quot;添加附件&quot;</span>)<br>    feedback = models.ForeignKey(to=FeedbackTable, on_delete=models.CASCADE, verbose_name=<span class="hljs-string">&quot;feedback_id&quot;</span>)<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        verbose_name = <span class="hljs-string">&quot;反馈附件&quot;</span><br>        verbose_name_plural = <span class="hljs-string">&quot;反馈附件&quot;</span><br>        db_table = <span class="hljs-string">&quot;T_FeedbackFiles&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>)<br></code></pre></td></tr></table></figure><p>admin.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> FeedbackTable, Files<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilesInline</span>(<span class="hljs-params">admin.TabularInline</span>):</span><br>    model = Files<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_extra</span>(<span class="hljs-params">self, request, obj=<span class="hljs-literal">None</span>, **kwargs</span>):</span><br>        extra = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> extra<br><br><span class="hljs-meta">@admin.register(<span class="hljs-params">FeedbackTable</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackAdmin</span>(<span class="hljs-params">admin.ModelAdmin</span>):</span><br>    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;status&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>)<br>    search_fields = (<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>)<br>    list_per_page = <span class="hljs-number">20</span><br>    list_filter = (<span class="hljs-string">&#x27;status&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>)<br>    inlines = [FilesInline]<br><br><span class="hljs-meta">@admin.register(<span class="hljs-params">Files</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilesAdmin</span>(<span class="hljs-params">admin.ModelAdmin</span>):</span><br>    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;file&#x27;</span>, <span class="hljs-string">&#x27;feedback&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> APIView<br><span class="hljs-keyword">from</span> django.apps <span class="hljs-keyword">import</span> apps<br><span class="hljs-keyword">from</span> rest_framework.response <span class="hljs-keyword">import</span> Response<br><span class="hljs-keyword">from</span> apps.Feedback <span class="hljs-keyword">import</span> models, serializers<br><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> StreamingHttpResponse<br><br><span class="hljs-comment"># Create your views here.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackView</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;意见反馈&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        title = request.POST.get(<span class="hljs-string">&#x27;title&#x27;</span>)<br>        <span class="hljs-comment">#if title is None:</span><br>        <span class="hljs-comment">#    return Response(&#123;&#x27;code&#x27;: 1010, &#x27;message&#x27;: &#x27;标题不能为空！&#x27;&#125;)</span><br>        content = request.POST.get(<span class="hljs-string">&#x27;content&#x27;</span>)<br>        <span class="hljs-comment">#if feedback is None:</span><br>        <span class="hljs-comment">#    return Response(&#123;&#x27;code&#x27;: 1011, &#x27;message&#x27;: &#x27;内容不能为空！&#x27;&#125;)</span><br>        username = request.POST.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-literal">None</span>)<br>        files = request.FILES.getlist(<span class="hljs-string">&#x27;file&#x27;</span>)<br>        <span class="hljs-comment"># ip_address = self.get_ip(request)</span><br>        feedback = models.FeedbackTable()<br>        feedback.title = title<br>        feedback.content = content<br>        feedback.username = username<br>        feedback.save()<br>        <span class="hljs-keyword">if</span> files <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files:<br>                file = models.Files()<br>                file.file = f<br>                file.feedback = feedback.<span class="hljs-built_in">id</span><br>                file.save()<br>        <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;提交成功！感谢您的建议&#x27;</span>&#125;)<br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    def get_ip(request):</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        x_forwarded_for = request.META.get(&#x27;HTTP_X_FORWARDED_FOR&#x27;)  # 判断是否使用代理</span><br><span class="hljs-string">        if x_forwarded_for:</span><br><span class="hljs-string">            ip = x_forwarded_for.split(&#x27;,&#x27;)[0]  # 使用代理获取真实的ip</span><br><span class="hljs-string">        else:</span><br><span class="hljs-string">            ip = request.META.get(&#x27;REMOTE_ADDR&#x27;)  # 未使用代理获取IP</span><br><span class="hljs-string">        return ip</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetBasicInformation</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    获取意见反馈表中的id，标题，用户名，时间，状态</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, request</span>):</span><br>        feedback = models.FeedbackTable.objects.<span class="hljs-built_in">all</span>()<br>        res = serializers.FeedbackSerializers(feedback, many=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">return</span> Response(res.data)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GetContentAndFiles</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    获取详细内容和附件</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        <span class="hljs-built_in">id</span> = request.data.get(<span class="hljs-string">&#x27;id&#x27;</span>)<br>        res = &#123;&#125;<br>        filepath = []<br>        filename = []<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 获取内容</span><br>            feedback_obj = models.FeedbackTable.objects.get(<span class="hljs-built_in">id</span>=<span class="hljs-built_in">id</span>)<br>            content = feedback_obj.content<br>            res[<span class="hljs-string">&#x27;content&#x27;</span>] = content<br>            <span class="hljs-comment"># 获取文件</span><br>            file_obj = models.Files.objects.<span class="hljs-built_in">filter</span>(feedback=feedback_obj)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file_obj.exists():<br>                <span class="hljs-comment"># 没有附件</span><br>                res[<span class="hljs-string">&#x27;files&#x27;</span>] = <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 存在附件</span><br>                res[<span class="hljs-string">&#x27;files&#x27;</span>] = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> file_obj:<br>                    file_path = <span class="hljs-built_in">str</span>(f.file)<br>                    file_name = file_path.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]<br>                    filepath.append(file_path)<br>                    filename.append(file_name)<br>                    res[<span class="hljs-string">&#x27;filepath&#x27;</span>] = filepath<br>                    res[<span class="hljs-string">&#x27;filename&#x27;</span>] = filename<br>            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>: res&#125;)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">10010</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;该反馈意见不存在!&#x27;</span>&#125;)<br><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileDown</span>(<span class="hljs-params">APIView</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    下载文件</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span><br>        filename = request.data.get(<span class="hljs-string">&#x27;filename&#x27;</span>)<br>        filepath = request.data.get(<span class="hljs-string">&#x27;filepath&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            response = StreamingHttpResponse(self.readFile(filepath))<br>            response[<span class="hljs-string">&#x27;Content-Type&#x27;</span>] = <span class="hljs-string">&#x27;application/octet-stream&#x27;</span><br>            response[<span class="hljs-string">&#x27;Content-Disposition&#x27;</span>] = <span class="hljs-string">&#x27;attachment;filename=&quot;&#123;0&#125;&quot;&#x27;</span>.<span class="hljs-built_in">format</span>(filename)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> Response(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">201</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;没有找到该附件&#x27;</span>&#125;)<br>        <span class="hljs-keyword">return</span> response<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readFile</span>(<span class="hljs-params">filepath, chunk_size=<span class="hljs-number">512</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        缓冲流下载文件方法</span><br><span class="hljs-string">        :param filepath:</span><br><span class="hljs-string">        :param chunk_size:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                c = f.read(chunk_size)<br>                <span class="hljs-keyword">if</span> c:<br>                    <span class="hljs-keyword">yield</span> c<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>serializers.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> apps.Feedback <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeedbackSerializers</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span><br>    <span class="hljs-string">&quot;反馈意见基本信息&quot;</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span><br>        model = models.FeedbackTable<br>        fields = [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;status&#x27;</span>, <span class="hljs-string">&#x27;time&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h2><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-progress</span> <span class="hljs-attr">:percentage</span>=<span class="hljs-string">&quot;ocr_progress&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-progress</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>java</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>onUploadProgress: <span class="hljs-function"><span class="hljs-params">progress</span> =&gt;</span> &#123;<br><span class="hljs-built_in">this</span>.ocr_progress = <span class="hljs-built_in">Math</span>.round(progress.loaded / progress.total * <span class="hljs-number">100</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>technology</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前后端</tag>
      
      <tag>diango</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linear Algebra</title>
    <link href="/2020/09/14/Linear-Algebra/"/>
    <url>/2020/09/14/Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<h1 id="1、向量是什么？"><a href="#1、向量是什么？" class="headerlink" title="1、向量是什么？"></a>1、向量是什么？</h1><p>向量（Vector）是线性代数中最基础、最根源的组成部分。</p><script type="math/tex; mode=display">\text{三种观点} = \begin{cases}                \text{physics student perspective}\\                \text{computer science student perspective}\\                \text{mathematician's perspective}          \end{cases}</script><ul><li>从物理专业学生的视角看：向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向，只要以上两个特征相同，你可以自由移动一个向量而保持它不变。</li><li>从计算机专业学生的视角看：向量是有序的数字列表。</li><li>数学家试图去概括这两种观点：a vector can be anything，只要保证两个向量相加以及数字与向量相乘是有意义的即可。</li></ul><p><strong>几何含义：</strong></p><p>向量相加：从第一个向量的起点出发，指向第二个向量的终点</p><p>向量数乘：向量的缩放（scaling）</p>]]></content>
    
    
    <categories>
      
      <category>basic knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>Linear_Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Taichi</title>
    <link href="/2020/08/23/Taichi/"/>
    <url>/2020/08/23/Taichi/</url>
    
    <content type="html"><![CDATA[<h1 id="1、The-Taichi-Programming-Language"><a href="#1、The-Taichi-Programming-Language" class="headerlink" title="1、The Taichi Programming Language"></a>1、The Taichi Programming Language</h1><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h3 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h3><p>Taichi is strongly typed. Supported basics types include:</p><ul><li>Signed integers:  ti.i8/i16/i32/i64</li><li>Unsigned integers:  ti.u8/u16/u32/u64</li><li>Float-point numbers:  ti.f32/f64</li></ul><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Taichi is a data-oriented programming language where tensors are first-class citizens.</p><ul><li>Tensors are essentially multi-dimensional arrays.（在Taichi种，tensor和matrix是两个完全不同的概念）</li><li>An element of a tensor can be either a scalar(var), a vector(ti.Vector), or a matrix(ti.Matrix)</li><li>Tensor elements are always accessed via the a[i, j, k] syntax. (No pointers! 编译器不易优化)</li><li>Access out-of-bound is undefined behavior.</li><li>Tensors can be spatially  sparse.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br>ti.init()<br>a = ti.var(dt=ti.f32, shape=(<span class="hljs-number">42</span>, <span class="hljs-number">63</span>)) <span class="hljs-comment"># A tensor of 42x63 scalars</span><br>b = ti.Vector(<span class="hljs-number">3</span>, dt=ti.f32, shape=<span class="hljs-number">4</span>) <span class="hljs-comment"># A tensor of 4x3D vectors</span><br>C = ti.Matrix(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, dt=ti.f32, shape=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment"># A tensor pf 3x5 2x2 matrices</span><br>loss = ti.var(dt=ti.f32, shape=()) <span class="hljs-comment"># A (0-D) tensor of a single scalar</span><br><br>a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br>print(<span class="hljs-string">&#x27;a[3, 4] = &#x27;</span>, a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-comment"># &quot;a[3, 4] = 1.000000&quot;</span><br><br>b[<span class="hljs-number">2</span>] = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>print(<span class="hljs-string">&#x27;b[0] =&#x27;</span>, b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], b[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br><span class="hljs-comment"># print(b[0]) is not yet supported</span><br><br>loss[<span class="hljs-literal">None</span>] = <span class="hljs-number">3</span> <span class="hljs-comment"># 没有下标</span><br>print(loss[<span class="hljs-literal">None</span>]) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>a（标量张量）：有42x63个元素，每个元素是一个标量</p><p>b（向量张量）：tensor长度为4，向量有3个元素，4个3D vectors组成的张量</p><p>c（矩阵张量）：3x5的tensor，里面每个元素是一个2x2的矩阵</p><p>loss：0-D的张量，只有一个标量元素</p><h2 id="computation"><a href="#computation" class="headerlink" title="computation"></a>computation</h2><h3 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h3><p>Kernels——用来计算的函数。</p><ul><li>The language used in Taichi kernels and functions is similar to Python.（区别：该语言会被即时编译，Taichi自带一个编译器，把kernel里的语言编译成高性能kernel，能够运行的更快。）</li><li>The Taichi kernel lanuage is compiled, statically-typed, lexically-scoped, parallel and differentiable.</li><li>Kernels must be decorated with @ti.kernel.</li><li>Kernel arguments and return values must be type-hinted.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">i: ti.i32</span>):</span><br>    a = <span class="hljs-number">40</span><br>    print(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, a + i)<br>    <br>hello(<span class="hljs-number">2</span>) <span class="hljs-comment"># Hello world! 42</span><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc</span>() -&gt; ti.i32:</span><br>    s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        s += i<br>    <span class="hljs-keyword">return</span> s  <span class="hljs-comment"># 45</span><br></code></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Taichi Functions 可以被 Taichi Kernels 调用，但是Taichi Function 不能被 python 调用。（<strong>device</strong> functions；<strong>global</strong> kernels）</p><p>Taichi functions can be called by Taichi kernels and other Taichi functions. They must be decorated with @ti.func.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.func</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">triple</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">3</span><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">triple_array</span>:</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">128</span>):<br>        a[i] = triple(a[i])<br></code></pre></td></tr></table></figure><p>Taichi Function will be force-inlined. 暂时不支持递归。一个Taichi Function最多只能包含一条return statement。</p><h3 id="Matrices-and-linear-algebra"><a href="#Matrices-and-linear-algebra" class="headerlink" title="Matrices and linear algebra"></a>Matrices and linear algebra</h3><ul><li>ti.Matrix is for small matrices(e.g. 3x3) only.</li><li>ti.Vector is the same as ti.Matrix, except that it has only one column.</li></ul><p><strong>Note:</strong>  Differentiate element-wise product * and matrix product @</p><h4 id="Parallel-for-loops"><a href="#Parallel-for-loops" class="headerlink" title="Parallel for-loops"></a>Parallel for-loops</h4><p>For loops in Taichi have two forms:</p><ul><li><strong>Range-for loops</strong>, which are no different from Python for loops, except that it will be parallelized when used at the outermost scope. Range-for loops can be nested.</li><li><strong>Struct-for loops</strong>, which iterates over (sparse) tensor elements. </li></ul><p>For loops at the outermost scope in a Taichi kernel is <strong>automatically parallelized</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <span class="hljs-comment"># Parallelized</span><br>        x[i] += i<br>        <br>        s = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <span class="hljs-comment"># Serialized in each parallel thread</span><br>            s += j<br>         <br>        y[i] = s<br>      <br><span class="hljs-meta">@ti,kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill_3d</span>():</span><br>    <span class="hljs-comment"># Parallelized for all 3&lt;=i&lt;8, 1&lt;=j&lt;6, 0&lt;=k&lt;9</span><br>    <span class="hljs-keyword">for</span> i, j, k <span class="hljs-keyword">in</span> ti.ndrange((<span class="hljs-number">3</span>, <span class="hljs-number">8</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">6</span>), <span class="hljs-number">9</span>):<br>        x[i, j, k] = i + j + k<br></code></pre></td></tr></table></figure><p><strong>Note:</strong> It is the loop at the outermost scope that gets parallelized, not the outermost loop.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>): <span class="hljs-comment"># Parallelized</span><br>        ...<br>      <br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>(<span class="hljs-params">k: ti.i32</span>):</span><br>    <span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">42</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>): <span class="hljs-comment"># Serical</span><br>            ...<br></code></pre></td></tr></table></figure><h4 id="Struct-for-loops"><a href="#Struct-for-loops" class="headerlink" title="Struct-for loops"></a>Struct-for loops</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init(arch=ti.gpu)<br><br>n = <span class="hljs-number">320</span><br>pixels = ti.var(dt=ti.f32, shape=(n * <span class="hljs-number">2</span>, n))<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">paint</span>(<span class="hljs-params">t: ti.f32</span>):</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> pixels:  <span class="hljs-comment"># Parallelized over all pixels</span><br>        pixels[i, j] = i * <span class="hljs-number">0.001</span> + j * <span class="hljs-number">0.002</span> + t<br>        <br>paint(<span class="hljs-number">0.3</span>)<br></code></pre></td></tr></table></figure><h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><p>In Taichi, augmented assignments (e.g.  x[i] += 1) are automatically atomic.</p><p>When modifying global variables in parallel, make sure you use atomic operations.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>():</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:<br><span class="hljs-comment"># Approach 1: OK</span><br>total[<span class="hljs-literal">None</span>] += x[i]  <span class="hljs-comment"># total 0-D tensor</span><br>    <br><span class="hljs-comment"># Approach 2: OK</span><br>ti.atomic_add(total[<span class="hljs-literal">None</span>], x[i])<br>    <br><span class="hljs-comment"># Approach 3: Wrong result (the operation is not atomic .)</span><br>total[<span class="hljs-literal">None</span>] = total[<span class="hljs-literal">None</span>] + x[i]<br></code></pre></td></tr></table></figure><h3 id="Taichi-scope-v-s-Python-scope"><a href="#Taichi-scope-v-s-Python-scope" class="headerlink" title="Taichi-scope v.s. Python-scope"></a>Taichi-scope v.s. Python-scope</h3><p><strong>Definition：</strong></p><ul><li>Taichi-scope: Everything decorated with ti.kernel and ti.func.</li><li>Python-scope: Code outside the Taichi-scope.</li></ul><p><strong>Note：</strong></p><ul><li>Code in Taichi-scope will be compiled by the Taichi compiler and run on parallel devices.</li><li>Code in Python-scope is simply Python code and will be executed by the Python interpreter.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br>ti.init()<br><br>a = ti.var(dt=ti.f32, shape=(<span class="hljs-number">42</span>, <span class="hljs-number">63</span>)) <span class="hljs-comment"># A tensor of 42x63 scalars</span><br>b = ti.Vector(<span class="hljs-number">3</span>, dt=ti.f32, shape=<span class="hljs-number">4</span>) <span class="hljs-comment"># A tensor of 4x3D vectors</span><br>C = ti.Matrix(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, dt=ti.f32, shape=(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)) <span class="hljs-comment"># A tensor of 3x5 2x2 matrices</span><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br>    print(<span class="hljs-string">&#x27;a[3, 4] =&#x27;</span>, a[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) <br>    <span class="hljs-comment"># a[3, 4] = 1.000000</span><br>    <br>    b[<span class="hljs-number">2</span>] = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br>    print(<span class="hljs-string">&#x27;b[0] =&#x27;</span>, b[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;, b[2] =&#x27;</span>, b[<span class="hljs-number">2</span>])<br>    <span class="hljs-comment"># b[0] = [0.000000, 0.000000, 0.000000] , b[2] = [6.000000, 7.000000, 8.000000]</span><br>    <br>    C[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    print(<span class="hljs-string">&#x27;C[2, 1] =&#x27;</span>, C[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>])<br>    <span class="hljs-comment"># C[2, 1] = [[0.000000, 1.000000], [0.000000, 0.000000]]</span><br>    <br>foo()<br></code></pre></td></tr></table></figure><h3 id="Phases-of-a-Taichi-program"><a href="#Phases-of-a-Taichi-program" class="headerlink" title="Phases of a Taichi program"></a>Phases of a Taichi program</h3><ol><li>Initialization: ti.init(…)</li><li>Tensor allocation: ti.var, ti.Vector, ti.Matrix</li><li>Computation (launch kernels, access tensors in Python-scope)</li><li>Optional: restart the Taichi system (clear memory, destroy all variables and kernels): ti.reset()</li></ol><p><strong>Note</strong></p><p>For now, after the first kernel launch or tensor access in Python-scope, no more tensor allocation is allowed.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># fractal.py</span><br><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br>ti.init(arch=ti.gpu)<br><br>n = <span class="hljs-number">320</span><br>pixels = ti.var(dt=ti.f32, shape=(n * <span class="hljs-number">2</span>, n))<br><br><span class="hljs-meta">@ti.func</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complex_sqr</span>(<span class="hljs-params">z</span>):</span><br>    <span class="hljs-keyword">return</span> ti.Vector([z[<span class="hljs-number">0</span>]**<span class="hljs-number">2</span> - z[<span class="hljs-number">1</span>]**<span class="hljs-number">2</span>, z[<span class="hljs-number">1</span>]*z[<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>])<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">paint</span>(<span class="hljs-params">t: ti.f32</span>):</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> pixels: <span class="hljs-comment"># Parallelized over all pixels</span><br>        c = ti.Vector([-<span class="hljs-number">0.8</span>, ti.cos(t)*<span class="hljs-number">0.2</span>])<br>        z = ti.Vector([i/n-<span class="hljs-number">1</span>, j/n-<span class="hljs-number">0.5</span>]) * <span class="hljs-number">2</span><br>        iterations = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> z.norm() &lt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> iterations &lt;<span class="hljs-number">50</span>:<br>            z = complex_sqr(z) + c<br>            iterations += <span class="hljs-number">1</span><br>        pixels[i, j] = <span class="hljs-number">1</span> - iterations * <span class="hljs-number">0.02</span><br>        <br>gui = ti.GUI(<span class="hljs-string">&quot;Julia Set&quot;</span>, res=(n*<span class="hljs-number">2</span>, n))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>):<br>    paint(i * <span class="hljs-number">0.03</span>)<br>    gui.set_image(pixels)<br>    gui.show()<br></code></pre></td></tr></table></figure><h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><p> ti.init(debug=True, arch=ti.cpu) initializes Taichi in debug mode, which enables bound checkers (CPU only).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br>ti.init(debug=<span class="hljs-literal">True</span>, arch=ti.cpu)<br><br>a = ti.var(ti.i32, shape=(<span class="hljs-number">10</span>))<br>b = ti.var(ti.i32, shape=(<span class="hljs-number">10</span>))<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shift</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        a[i] = b[i+<span class="hljs-number">1</span>] <span class="hljs-comment"># Runtime error in debug mode</span><br>        <br>shift()<br></code></pre></td></tr></table></figure><h2 id="Objective-data-oriented-programming"><a href="#Objective-data-oriented-programming" class="headerlink" title="Objective data-oriented programming"></a>Objective data-oriented programming</h2><p>Taichi is a data-oriented programming (DOP) language, but simple DOP makes modularization hard. To improve code reusability, Taichi borrows some concepts from object-oriented programming (OOP).</p><p>The hybrid scheme is called objective data-oriented programming (ODOP).</p><p>Three important decorators</p><ul><li>Use @ti.data_oriented to decorate your class.</li><li>Use @ti.kernel to decorate class members functions that are Taichi kernels.</li><li>Use @ti.func to decorate class members functions that are Taichi functions.</li></ul><p>Demo:  ti example odop_solar  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><span class="hljs-keyword">import</span> math<br>ti.init()<br><br><span class="hljs-meta">@ti.data_oriented</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SolarSystem</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, n, dt</span>):</span><br>        <span class="hljs-comment"># initializer of the solar system simulator</span><br>        self.n = n<br>        self.dt = dt<br>        self.x = ti.Vector.field(<span class="hljs-number">2</span>, dtype=<span class="hljs-built_in">float</span>, shape=n)<br>        self.v = ti.Vector.field(<span class="hljs-number">2</span>, dtype=<span class="hljs-built_in">float</span>, shape=n)<br>        self.center = ti.Vector.field(<span class="hljs-number">2</span>, dtype=<span class="hljs-built_in">float</span>, shape=())<br><br><span class="hljs-meta">    @staticmethod</span><br><span class="hljs-meta">    @ti.func</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_vector_in</span>(<span class="hljs-params">rmax</span>):</span><br>        <span class="hljs-comment"># create a random vector</span><br>        a = ti.random() * math.tau<br>        r = ti.random() * rmax<br>        <span class="hljs-keyword">return</span> r * ti.Vector([ti.cos(a), ti.sin(a)])<br><br><span class="hljs-meta">    @ti.kernel</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># initialization or reset</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n):<br>            offset = self.random_vector_in(<span class="hljs-number">0.5</span>)<br>            self.x[i] = self.center[<span class="hljs-literal">None</span>] + offset  <span class="hljs-comment"># Offset from center</span><br>            self.v[i] = [-offset.y, offset.x]  <span class="hljs-comment"># Perpendicular to offset</span><br>            self.v[i] += self.random_vector_in(<span class="hljs-number">0.02</span>)  <span class="hljs-comment"># Shaking</span><br>            self.v[i] *= <span class="hljs-number">1</span> / offset.norm()**<span class="hljs-number">1.5</span>  <span class="hljs-comment"># Kepler&#x27;s 3rd law</span><br><br><span class="hljs-meta">    @ti.func</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gravity</span>(<span class="hljs-params">self, pos</span>):</span><br>        <span class="hljs-comment"># compute gravitational acceleration at pos</span><br>        offset = -(pos - self.center[<span class="hljs-literal">None</span>])<br>        <span class="hljs-keyword">return</span> offset / offset.norm()**<span class="hljs-number">3</span><br><br><span class="hljs-meta">    @ti.kernel</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">integrate</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># semi-implicit time integration</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n):<br>            self.v[i] += self.dt * self.gravity(self.x[i])<br>            self.x[i] += self.dt * self.v[i]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, gui</span>):</span><br>        <span class="hljs-comment"># render the simulation scene on the GUI</span><br>        gui.circle([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], radius=<span class="hljs-number">10</span>, color=<span class="hljs-number">0xffaa88</span>)<br>        gui.circles(solar.x.to_numpy(), radius=<span class="hljs-number">3</span>, color=<span class="hljs-number">0xffffff</span>)<br><br><br>solar = SolarSystem(<span class="hljs-number">8</span>, <span class="hljs-number">0.0001</span>)<br>solar.center[<span class="hljs-literal">None</span>] = [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>]<br>solar.initialize()<br><br>gui = ti.GUI(<span class="hljs-string">&quot;Solar System&quot;</span>, background_color=<span class="hljs-number">0x0071a</span>)<br><br><span class="hljs-keyword">while</span> gui.running:<br>    <span class="hljs-comment"># GUI event processing</span><br>    <span class="hljs-keyword">if</span> gui.get_event(gui.PRESS):<br>        <span class="hljs-keyword">if</span> gui.event.key == gui.SPACE:<br>            solar.initialize()<br>        <span class="hljs-keyword">elif</span> gui.event.key == gui.ESCAPE:<br>            gui.running = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        solar.integrate()<br><br>    solar.render(gui)<br>    gui.show()<br></code></pre></td></tr></table></figure><h2 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h2><p>Taichi provides metaprogramming tools. Metaprogramming can :</p><ul><li>Allow users to pass almost anything (including Taichi tensors) to Taichi kernels</li><li>Improve run-time performance by moving run-time costs to compile time</li><li>Achieve dimensionality independence (e.g. write 2D and 3D simulation code simultaneously.)</li><li>Simplify the development of Taichi standard library</li></ul><p>Taichi kernels are <strong>lazily instantiated</strong> and a lot of computation can happen at compile time. Every kernel in Taichi is a template kernel, even if it has no template arguments.</p><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">x: ti.template (<span class="hljs-params"></span>), y: ti.template (<span class="hljs-params"></span>), c: ti.f32</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:   <br>        y[i] = x[i] + c<br></code></pre></td></tr></table></figure><p>如果不用template很难把tensor当argument传给kernel</p><p><strong>Template instantiation</strong></p><p>Kernel templates will be instantiated on the first call, and cached for later calls with the same template signature.</p><p><strong>Template argument takes (almost) everything</strong></p><p>Feel free to pass tensors, classes, functions, and numerical values to ti.template() arguments.</p><h3 id="Template-kernel-instantiation"><a href="#Template-kernel-instantiation" class="headerlink" title="Template kernel instantiation"></a>Template kernel instantiation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br>ti.init()<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>(<span class="hljs-params">i: ti.template (<span class="hljs-params"></span>)</span>):</span><br>    print(i)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">100</span>):<br>    hello(i) <span class="hljs-comment"># 100 different kernels will be created</span><br>    <br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">world</span>(<span class="hljs-params">i: ti.i32</span>):</span><br>    print(i)<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">100</span>):<br>    world(i) <span class="hljs-comment"># The only instance will be reused</span><br></code></pre></td></tr></table></figure><h3 id="Dimensionality-independent-programming"><a href="#Dimensionality-independent-programming" class="headerlink" title="Dimensionality-independent programming"></a>Dimensionality-independent programming</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">x: ti.template(<span class="hljs-params"></span>), y: ti.template(<span class="hljs-params"></span>)</span>):</span><br>    <span class="hljs-keyword">for</span> I <span class="hljs-keyword">in</span> ti.grouped(y):  <span class="hljs-comment"># 将y的全部index打包,I--&gt;n维向量</span><br>        x[I] = y[I]<br>        <br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">array_op</span>(<span class="hljs-params">x: ti.template(<span class="hljs-params"></span>), y: ti.template(<span class="hljs-params"></span>)</span>):</span><br>    <span class="hljs-keyword">for</span> I <span class="hljs-keyword">in</span> ti.grouped(x):<br>        <span class="hljs-comment"># I is a vector of size x.dim() and data type i32</span><br>        y[I] = I[<span class="hljs-number">0</span>] + I[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># If tensor x is 2D, the above is equivalent to</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> x:<br>        y[i, j] = i + j<br></code></pre></td></tr></table></figure><h3 id="Tensor-size-reflection"><a href="#Tensor-size-reflection" class="headerlink" title="Tensor-size reflection"></a>Tensor-size reflection</h3><p>Fetch tensor dimensionality info as compile-time constants:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>tensor = ti.var(ti.f32, shape=(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>))<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_tensor_size</span>(<span class="hljs-params">x: ti.template(<span class="hljs-params"></span>)</span>):</span><br>    print(<span class="hljs-built_in">len</span>(x.shape))  <span class="hljs-comment"># x.dim() &amp; x.shape() is deprecated</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ti.static(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x.shape))):<br>        print(x.shape[i])<br><br>print_tensor_size(tensor)<br></code></pre></td></tr></table></figure><h3 id="Compile-time-branching"><a href="#Compile-time-branching" class="headerlink" title="Compile-time branching"></a>Compile-time branching</h3><p>Using compile-time evaluation will allow certain computations to happen when kernels are being instantiated. This saves the overhead of those computations at runtime. (C++17 equivalence: if constexpr.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">enable_projection = <span class="hljs-literal">True</span><br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">static</span>():</span><br>    <span class="hljs-keyword">if</span> ti.static(enable_projection): <span class="hljs-comment"># No runtime overhead</span><br>        x[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="Forced-loop-unrolling"><a href="#Forced-loop-unrolling" class="headerlink" title="Forced loop-unrolling"></a>Forced loop-unrolling</h3><p>Use ti.static(range(…)) to unroll the loops at compile time:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> taichi <span class="hljs-keyword">as</span> ti<br><br>ti.init()<br>x = ti.Vector(<span class="hljs-number">3</span>, dt=ti.i32, shape =<span class="hljs-number">16</span>)<br><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span>():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> ti.static(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)):<br>            x[i][j] = j<br>        print(x[i])<br><br>fill()<br></code></pre></td></tr></table></figure><p>When to use range-for loops?</p><ul><li>For performance.  （loop-unrolling后可以减少loop本身的overhead）</li><li>To loop over vector/matrix elements. Indices into Taichi matrices must be compile-time constants. Indices into Taichi tensors can be run-time variables. For example, if x is a 1-D tensor of 3D vectors, accessed as x [tensor_index] [matrix_index]. The first index can be a variable, yet the second must be a constant.</li></ul><h3 id="Variable-aliasing"><a href="#Variable-aliasing" class="headerlink" title="Variable aliasing"></a>Variable aliasing</h3><p>Creating handy aliases for global variables and functions with cumbersome names can sometimes improve readability:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_kernel</span> ():</span><br>    <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> tensor_a:<br>        tensor_b[i, j] = some_function(tensor_a[i, j])<br>        <br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_kernel</span> ():</span><br>    a, b, fun = ti.static(tensor_a , tensor_b , some_function)<br>    <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> a:<br>        b[i,j] = fun(a[i,j])<br></code></pre></td></tr></table></figure><h2 id="Differentiable-Programming"><a href="#Differentiable-Programming" class="headerlink" title="Differentiable Programming"></a>Differentiable Programming</h2><p>Forward programs evaluate $f(x)$, differentiable programs evaluate $\frac{∂f(x)}{∂x}$</p><p>Taichi supports <strong>reverse-mode automatic differentiation (AutoDiff)</strong> that back-propagates gradients w.r.t. a scalar (loss) function f(x).</p><p>Two ways to compute gradients:</p><ol><li>Use Taichi’s tape (ti.Tape(loss)) for both forward and gradient evaluation.</li><li>Explicitly use gradient kernels for gradient evaluation with more controls.</li></ol><h3 id="Gradient-based-optimization"><a href="#Gradient-based-optimization" class="headerlink" title="Gradient-based optimization"></a>Gradient-based optimization</h3><script type="math/tex; mode=display">min_x \quad L(x) = \frac{1}{2}\sum_{i=0}^{n-1}(x_i - y_i)^2</script><ol><li><p>Allocating tensors with gradients：x = ti.var(dt=ti.f32, shape=n, needs_grad=True)</p></li><li><p>Defining loss function kernel(s)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reduce</span> ():</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        L[<span class="hljs-literal">None</span>] += <span class="hljs-number">0.5</span> * (x[i] - y[i])**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>Compute loss with ti.Tape(loss=L)：reduce()</p></li><li><p>Gradient descent：for i in x: x[i] -= x.grad[i] * 0.1</p></li></ol><h3 id="Application-1-Forces-from-potential-energy-gradients"><a href="#Application-1-Forces-from-potential-energy-gradients" class="headerlink" title="Application 1: Forces from potential energy gradients"></a>Application 1: Forces from potential energy gradients</h3><p>From the definition of potential energy: (potential energy关于位置的导数—&gt;顶点的受力)</p><script type="math/tex; mode=display">f_i = -\frac{∂U(x)}{∂x_i}</script><p>Manually deriving gradients is hard. Let’s use AutoDiff:</p><ol><li>Allocate a 0−D tensor to store the potential energy: potential = ti.var(ti.f32, shape=()).</li><li>Define forward kernels that computes potential energy from x[i].</li><li>In a ti.Tape(loss=potential), call the forward kernels.</li><li>Force on each particle is -x.grad[i].</li></ol><h3 id="Application-2-Differentiating-a-whole-physical-process"><a href="#Application-2-Differentiating-a-whole-physical-process" class="headerlink" title="Application 2: Differentiating a whole physical process"></a>Application 2: Differentiating a whole physical process</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> ti.Tape(loss=loss):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(steps - <span class="hljs-number">1</span>):<br>        simulate(i)<br></code></pre></td></tr></table></figure><p><strong>Computational history</strong></p><p>Always keep the whole computational history of time steps for end-to-end differentiation. I.e., instead of only allocating<br>ti.Vector(3, dt=ti.f32, shape=(num_particles)) that stores the latest particles, allocate for the whole simulation process<br>ti.Vector(3, dt=ti.f32, shape=(num_timesteps, num_particles)). (Use checkpointing to reduce memory consumption.)</p><h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><p><strong>Visualizing 2D results</strong></p><p>Simply make use of Taichi’s GUI system. Useful functions:</p><ul><li>gui = ti.GUI(“Taichi MLS-MPM-128”, res=512, background_color=0x112F41)</li><li>gui.circle/gui.circles(x.to_numpy(), radius=1.5, color=colors.to_numpy())</li><li>gui.line/triangle/set_image/show/…</li></ul><p><strong>Visualizing 3D results</strong></p><p>Exporting 3D particles and meshes using ti.PLYWriter</p><p>Use Houdini/Blender to view (and render) your 3D results.</p><hr><p>ti example: 查看example demo 4</p><p>python -m taichi example mpm128 (demo_name)</p><h1 id="2、Lagrangian-Simulation-Approaches"><a href="#2、Lagrangian-Simulation-Approaches" class="headerlink" title="2、Lagrangian Simulation Approaches"></a>2、Lagrangian Simulation Approaches</h1><h2 id="Mass-Spring-Systems-弹簧质点系统"><a href="#Mass-Spring-Systems-弹簧质点系统" class="headerlink" title="Mass-Spring Systems (弹簧质点系统)"></a>Mass-Spring Systems (弹簧质点系统)</h2><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/taichi/mass_spring.png" alt="mass_spring" style="zoom:50%;" /></p><p>k: spring stiffness; l<sub>ij</sub>: spring rest length between particle i and particle j;</p><p>m<sub>i</sub>: the mass of particle i. (<strong>x<sub>i</sub></strong> − <strong>x<sub>j</sub></strong>): direction vector from particle j to particle i;</p><h2 id="Time-integration"><a href="#Time-integration" class="headerlink" title="Time integration"></a>Time integration</h2><p><strong>1、Forward Euler</strong> (explicit)：</p><p>​        前向欧拉法：根据现有的状态推测以后的状态：</p><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta t\frac{f_t}{m}</script><script type="math/tex; mode=display">x_{t+1} = x_t + \Delta tv_t</script><p><strong>2、Semi-implicit Euler</strong> (aka. symplectic Euler, explicit)：</p><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta t\frac{f_t}{m}</script><script type="math/tex; mode=display">x_{t+1} = x_t + \Delta tv_{t+1}</script><p><strong>3、Backward Euler</strong> (often with Newton’s method, implicit)：</p><h3 id="Implementing-a-mass-spring-system-with-symplectic-Euler"><a href="#Implementing-a-mass-spring-system-with-symplectic-Euler" class="headerlink" title="Implementing a mass-spring system with symplectic Euler"></a>Implementing a mass-spring system with symplectic Euler</h3><ol><li><p>Compute new velocity using </p><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta t\frac{f_t}{m}</script></li><li><p>Collision with ground</p></li><li><p>Compute new position using</p><script type="math/tex; mode=display">x_{t+1} = x_t + \Delta tv_{t+1}</script></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># mass_spring.py</span><br><span class="hljs-meta">@ti.kernel</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">substep</span>():</span><br>    n = num_particles[<span class="hljs-literal">None</span>]<br>    <br>    <span class="hljs-comment"># Compute force and new velocity</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        v[i] *= ti.exp(-dt * damping[<span class="hljs-literal">None</span>]) <span class="hljs-comment"># damping</span><br>        total_force = ti.Vector(gravity) * particle_mass<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> rest_length[i, j] != <span class="hljs-number">0</span>:<br>                x_ij = x[i] - x[j]<br>                total_force += -spring_stiffness[<span class="hljs-literal">None</span>] * (x_ij.norm() - rest_length[i, j]) * x_ij.normalized()<br>        v[i] += dt * total_force / particle_mass<br>        <br>    <span class="hljs-comment"># Collide with ground</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">if</span> x[i].y &lt; bottom_y:<br>            x[i].y = bottom_y<br>            v[i].y = <span class="hljs-number">0</span><br>            <br>    <span class="hljs-comment"># Compute new position</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        x[i] += v[i] * dt<br></code></pre></td></tr></table></figure><h3 id="Explicit-v-s-implicit-time-integrators"><a href="#Explicit-v-s-implicit-time-integrators" class="headerlink" title="Explicit v.s. implicit time integrators"></a>Explicit v.s. implicit time integrators</h3><p>Explicit (forward Euler, symplectic Euler, RK, …)：</p><ul><li><p>Future depends only on past</p></li><li><p>Easy to implement</p></li><li><p>Easy to explode: （从材料的刚度考虑时间步长的限制）</p><script type="math/tex; mode=display">\Delta t \leq c\sqrt{\frac{m}{k}} \quad\quad(c-1)</script></li><li><p>Bad for stiff materials</p></li></ul><p>Implicit (backward Euler, middle-point, …):</p><ul><li>Future depends on both future and past</li><li>Chicken-egg problem: need to solve a system of (linear) equations</li><li>In general harder to implement</li><li>Each step is more expensive but time steps are larger</li><li>Numerical damping and locking</li></ul><h3 id="Mass-spring-systems"><a href="#Mass-spring-systems" class="headerlink" title="Mass-spring systems"></a>Mass-spring systems</h3><p>Implicit time integration:</p><script type="math/tex; mode=display">x_{t+1} = x_t + \Delta tv_{t+1} \quad\quad (1)</script><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta tM^{-1}f(x_{t+1}) \quad\quad (2)</script><p>Eliminate x<sub>t+1</sub>:</p><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta tM^{-1}f(x_t + \Delta tv_{t+1}) \quad\quad (3)</script><p>Linearize (one step of Newton’s method):</p><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta tM^{-1}[f(x_t) + \frac{∂f}{∂x}(x_t)\Delta tv_{t+1}] \quad\quad (4)</script><p>Clean up:</p><script type="math/tex; mode=display">[I - \Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)] v_{t+1} = v_t + \Delta tM^{-1}f(x_t) \quad\quad (5)</script><p>How to solve it?</p><ul><li>Jacobi/Gauss-Seidel iterations (easy to implement!)</li><li>Conjugate gradients (later in this course)</li></ul><script type="math/tex; mode=display">A = [I - \Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)]</script><script type="math/tex; mode=display">b = v_t + \Delta tM^{-1}f(x_t)</script><script type="math/tex; mode=display">Av_{t+1} = b</script><h3 id="Unifying-explicit-and-implicit-integrators"><a href="#Unifying-explicit-and-implicit-integrators" class="headerlink" title="Unifying explicit and implicit integrators"></a>Unifying explicit and implicit integrators</h3><script type="math/tex; mode=display">[I - \beta\Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)] v_{t+1} = v_t + \Delta tM^{-1}f(x_t)</script><ol><li>β = 0: forward/semi-implicit Euler (explicit)</li><li>β = 1/2: middle-point (implicit)</li><li>β = 1: backward Euler (implicit)</li></ol><h2 id="Lagrangian-fluid-simulation-SPH"><a href="#Lagrangian-fluid-simulation-SPH" class="headerlink" title="Lagrangian fluid simulation: SPH"></a>Lagrangian fluid simulation: SPH</h2><p><strong>High-level idea:</strong> use particles carrying samples of physical quantities, and a kernel function W, to approximate continuous fields: (<em>A</em> can be almost any spatially varying physical attributes: density, pressure, etc. Derivatives: different story)</p><script type="math/tex; mode=display">A(x) = \sum_i{A_i}\frac{m_i}{ρ_i}W(||x-x_j||_2, h)</script><ol><li>Originally proposed for astrophysical problems</li><li>No meshes. Very suitable for free-surface flows!</li><li>Easy to understand intuitively: just imagine each particle is a small parcel of water (although strictly not the case!)</li></ol><h3 id="Implementing-SPH-using-the-Equation-of-States"><a href="#Implementing-SPH-using-the-Equation-of-States" class="headerlink" title="Implementing SPH using the Equation of States"></a>Implementing SPH using the Equation of States</h3><p>Also known as Weakly Compressible SPH (WCSPH).</p><p>Momentum equation: ( ρ: density;  B: bulk modulus;  γ : constant, usually ∼ 7 )</p><script type="math/tex; mode=display">\frac{Dv}{Dt} = -\frac{1}{ρ}\nabla p + g, \quad\quad p = B((\frac{ρ}{ρ_0})^\gamma - 1)</script><script type="math/tex; mode=display">A(x) = \sum_i{A_i}\frac{m_i}{ρ_i}W(||x-x_j||_2,h)</script><script type="math/tex; mode=display">ρ_i = \sum_j{m_j}W(||x_i-x_j||_2,h)</script><p>Extras: surface tension, viscosity</p><p>Note: the WCSPH paper should have used material derivatives.</p><h3 id="Gradients-in-SPH"><a href="#Gradients-in-SPH" class="headerlink" title="Gradients in SPH"></a>Gradients in SPH</h3><script type="math/tex; mode=display">\nabla A_i = ρ_i \sum{m_j}(\frac{A_i}{ρ_i^2} + \frac{A_j}{ρ_j^2}) \nabla_{x_i}W(||x_i-x_j||_2,h)</script><p>Not really accurate.</p><p>But at least symmetric and momentum conserving!</p><h3 id="SPH-Simulation-Cycle"><a href="#SPH-Simulation-Cycle" class="headerlink" title="SPH Simulation Cycle"></a>SPH Simulation Cycle</h3><script type="math/tex; mode=display">\frac{Dv}{Dt} = -\frac{1}{ρ}\nabla p + g, \quad\quad p = B((\frac{ρ}{ρ_0})^\gamma - 1)</script><ol><li>For each particle i, compute $ρ_i = \sum{m_j}W(||x_i-x_j||_2,h)$</li><li>For each particle i, compute $\nabla p_i$ using the gradient operator</li><li>Symplectic Euler step (again…):</li></ol><script type="math/tex; mode=display">v_{t+1} = v_t + \Delta t\frac{D_v}{D_t}</script><script type="math/tex; mode=display">x_{t+1} = x_t + \Delta tv_{t+1}</script><h3 id="Variants-of-SPH"><a href="#Variants-of-SPH" class="headerlink" title="Variants of SPH"></a>Variants of SPH</h3><p>Predictive-Corrective Incompressible SPH (PCI-SPH)：隐式的时间积分（不完全隐式），采用预测矫正的格式，每次先预测一下粒子的位置/速度，然后根据预测做出矫正，得到一个散度比较小的速度场—&gt;更加接近不可压缩</p><p>Position-based fluids (PBF) Demo: ti example pbf2d</p><p>Divergence-free SPH (DFSPH)</p><h3 id="Courant–Friedrichs–Lewy-CFL-condition"><a href="#Courant–Friedrichs–Lewy-CFL-condition" class="headerlink" title="Courant–Friedrichs–Lewy (CFL) condition"></a>Courant–Friedrichs–Lewy (CFL) condition</h3><p>显示时间积分：从粒子运动的速度考虑时间步长的限制：</p><script type="math/tex; mode=display">C = \frac{u \Delta t}{\Delta x} \leq C_{max} - 1</script><ul><li>C:  CFL number (Courant number, or simple the CFL)</li><li>$\Delta t$:  time step</li><li>$\Delta x$:  length interval (e.g. particle radius and grid size)</li><li>u: maximum (velocity)     $u\Delta t$  —&gt; 一个时间步之内粒子移动的最大距离</li></ul><p>Application: estimating allowed time step in (explicit) time integrations. Typical C<sub>max</sub> in graphics:</p><ul><li>SPH: ∼ 0.4</li><li>MPM: 0.3 ∼ 1</li><li>FLIP fluid (smoke): 1 ∼ 5+</li></ul><h3 id="Accelerating-SPH-Neighborhood-search"><a href="#Accelerating-SPH-Neighborhood-search" class="headerlink" title="Accelerating SPH: Neighborhood search"></a>Accelerating SPH: Neighborhood search</h3><p>So far, per substep complexity of SPH is $O(n^2)$ . This is too costly to be practical. In practice, people build spatial data structure such as voxel grids to accelerate neighborhood search. This reduces time complexity to O(n).</p><h1 id="3、Basics-of-deformation-elasticity-and-finite-elements"><a href="#3、Basics-of-deformation-elasticity-and-finite-elements" class="headerlink" title="3、Basics of deformation, elasticity, and finite elements"></a>3、Basics of deformation, elasticity, and finite elements</h1><h2 id="Deformation"><a href="#Deformation" class="headerlink" title="Deformation"></a>Deformation</h2><p>Deformation map ϕ : a (vector to vector) function that relates rest material position and deformed material position.  (将静止位置映射到形变位置，如果在3D中，即是从三维向量到三维向量的一个向量函数)</p><script type="math/tex; mode=display">x_{deformed} = \phi (x_{rest})</script><p>Deformation gradient F：（对静止位置求导数）</p><script type="math/tex; mode=display">F:=\frac{∂x_{deformed}}{∂x_{rest}}</script><p>Deformation gradients are translational invariant:</p><script type="math/tex; mode=display">\phi_1 = \phi(x_{rest}) \quad and \quad \phi_2 = \phi(x_{rest}) + c</script><p>​        have the same deformation gradients</p><p>Deform/rest volume ratio $J = det(F)$   （$J$ ：形变以后的体积/静止的体积 = F的行列式）</p><h2 id="Elasticity"><a href="#Elasticity" class="headerlink" title="Elasticity"></a>Elasticity</h2><h3 id="Hyperelasticity"><a href="#Hyperelasticity" class="headerlink" title="Hyperelasticity"></a>Hyperelasticity</h3><p>Hyperelastic materials: materials whose stress–strain relationship is defined by a strain energy density function：</p><script type="math/tex; mode=display">\psi = \psi(F)</script><p>Intuitive understanding: $\psi$ is a potential function that penalizes deformation.</p><p>“Stress”：the material’s internal elastic forces. （用来恢复原来体积形状的内力）</p><p>“Strain”：just replace it with deformation gradients F for now.</p><p><strong>Be careful</strong></p><p>We use ψ as the strain energy density function and ϕ as the deformation map. They are completely different.</p><h3 id="Stress-tensor"><a href="#Stress-tensor" class="headerlink" title="Stress tensor"></a>Stress tensor</h3>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>taichi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Weakly compressible SPH for free surface flows</title>
    <link href="/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/"/>
    <url>/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>基于Tait方程，本文提出了一种弱可压缩光滑粒子流体动力学方法。与通常采用的严格执行不可压缩性的投影方法相比，通过允许用户定义小的密度波动，避免了泊松方程的耗时求解。我们还讨论了一个改进的表面张力模型，特别适合单相自由表面流动。通过与已有模型的比较，验证了该方法对自由表面流动的准确性。结合所提出的方法，可以有效地利用SPH模拟低粘度液体。该方法适用于中、小规模现象。喷溅和碎波等波浪效果是自然处理的。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​    在流体动画中，最理想的功能是模拟具有碎波和飞溅的湍流液体。像SPH这样的拉格朗日方法是捕捉这种性质的一个有前途的方法。</p><p>​    Miller 和 Pearcy 提出了基于粒子的方法，这种早期的方法是基于简单的粒子-粒子力。</p><p>​    Stam 和 Fiume 第一次将SPH应用于气体和火焰现象的模拟。</p><p>​    Takeshita等人对爆炸火焰也采用了粒子法。</p><p>​    除了这些可压缩现象，SPH还被用于模拟液体。</p><p>​    这些方法采用理想气体方程来联系压力和密度。这导致高压缩性和振荡，与气体相反，这是不希望的，视觉上令人不快。增强粒子方法的不可压缩性是一个具有挑战性的问题。康明斯和鲁德曼为拉格朗日方法提出了一种投影方法，这种方法也用于欧拉方法。类似地，Premoze等人已经实现了移动粒子半隐式方法(MPS)的不可压缩性。在这种方法中，基于压力校正将速度估计投影到无发散子空间上。因此，泊松方程必须求解。虽然可以处理大的时间步长，但是用于求解泊松方程的共轭梯度解算器对于大系统来说是耗时的。对于100k粒子，Premoze注释是3分钟，而可压缩的SPH实现可以处理类似的复杂性5-10秒每时间步。</p><p>​    在我们的SPH模拟中，我们建议使用Tait方程和一个高声速，这导致具有非常低密度波动的弱可压缩公式。该方法避免了由于可压缩性而导致的不可信的模拟结果。虽然与泊松方法相比，该方法需要更小的时间步长，但每时间步长的计算速度要快得多，而且实现很容易适应SPH框架。弱可压缩形式的计算时间与基于理想气体方程的可压缩形式所需的时间相对应。</p><p>​    除了体积保持，表面张力在逼真的流体动画中也起着重要的作用。由于对小细节的处理主要受表面张力的控制，所以在自由表面流体的拉格朗日方法中通常会考虑到这一点。然而，这些方法最初是为多相流设计的。虽然在高动态环境中不可评估，但它们不能正确处理大曲率。这是因为粒子在这些区域的邻居太少。此外，[Mor99]要求计算颜色场的二阶导数，颜色场对粒子无序非常敏感，因此不适用于湍流环境。</p><p>​    我们提出了一个基于内聚力的表面张力模型。该模型特别适合于单相流，但也可以处理多相流。避免了导数的计算，提高了方法的效率和稳定性。</p><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>​    受早期程序方法的启发，计算机图形学中的流体模拟主要由欧拉方法和拉格朗日方法组成。一般来说，欧拉方法显示出许多有用的特征。仅举几个例子，计算是在固定的网格上进行的，避免了拉格朗日方法所要求的耗时的邻居搜索。此外，通过设置适当的边界条件，可以容易地处理流入和流出。</p><p>​    在[KM90]中，卡斯和米勒提出了一个基于浅水方程线性化的高度场模型(height-field model)。在[FM96]中，福斯特和梅塔克萨斯引入了三维纳维尔-斯托克斯方程组的有限差分解法。使用2D高度场和表面标记粒子来跟踪自由表面，并且实现了流体和刚性物体的单向耦合。在[FM97]中，2D标记粒子法被推广到三维，并提出了一种局部自适应阻尼方法来提高稳定性。斯塔姆[99]提出了三维不可压缩纳维尔-斯托克斯方程的无条件稳定解算器。福斯特和费迪基通过结合水平集和表面标记粒子来减轻质量耗散，使用改进的表面跟踪来增强流体的方法。这就是所谓的粒子水平集方法。埃尔科特等人提供了对[Sta99]的进一步扩展的全面概述。他们使用相同的半拉格朗日平流策略，但提出了一个保持循环的积分方案。</p><p>​    其他作者引入了处理多相流的扩展，包括两种或多种流体，与运动刚性固体的双向耦合，可变形固体，以及局部细化。奥布莱恩和哈金斯通过使用粒子系统来模拟液滴来增强基于网格的方法，米哈利夫等人解决了欧拉流体模拟的碎波问题。最近，点阵玻尔兹曼方法已经被提出用于流体模拟。在这种基于网格的替代方法中，粒子分布是使用碰撞和传播规则在有限的网格上演化的。</p><p>​    计算机图形学中拉格朗日方法的研究—至少在某种程度上—是由交互式应用推动的。拉格朗日方法在内存和计算时间方面是比较有效的。它们对于时变仿真域具有灵活性，易于实现。基于上述基本SPH方法，已经给出了各种扩展。SPH流体的应用范围从河流模拟、多相流体模拟和高粘性流体到流体控制。Desbrun和Cani 提出了一种用于可变形固体的弹性SPH方法。Hadap和Magnenat-Thalmann 使用SPH进行头发动力学。在[MST∗04]中，实现了基于sph的流体和可变形固体的双向耦合。Solenthaler等人[SSP07]提出了一种适用于液体、弹性和刚性物体的统一SPH方法。SPH也在虚拟手术中得到了应用。</p><p>​    Bell等人提出了一种基于分子动力学的颗粒方法。Zhu和Bridson 将细胞内粒子法扩展到模拟水和颗粒物质。为了更好地介绍图形中的各种流体模拟技术，我们参考了Bridson、Fedkiw和MullerFischer的优秀SIGGRAPH课程笔记。</p><h2 id="SPH-fluid-model"><a href="#SPH-fluid-model" class="headerlink" title="SPH fluid model"></a>SPH fluid model</h2><p>对于流体，插值公式如下：</p><script type="math/tex; mode=display">A(\mathbf{x}) = \sum_j m_j \frac{A_j}{ρ_j} W(\mathbf{x}-\mathbf{x}_j,h) \quad\quad (1)</script><h3 id="The-governing-equations-and-their-SPH-formulation"><a href="#The-governing-equations-and-their-SPH-formulation" class="headerlink" title="The governing equations and their SPH formulation"></a>The governing equations and their SPH formulation</h3><p>​    在我们的方法中，我们求解欧拉方程，它是无粘流的Navier-Stokes方程的简化。为了提高方法的数值稳定性，在模型中加入了动量守恒的人工粘度。在非守恒形式下，欧拉方程：</p><script type="math/tex; mode=display">\frac{dρ}{dt} = -ρ\nabla \cdot \mathbf{v} \quad\quad \text{(continuity equation)} \quad\quad (2)</script><script type="math/tex; mode=display">\frac{d\mathbf{v}}{dt} = -\frac{1}{ρ}\nabla P + \mathbf{g} \quad\quad \text{(momentum equation)} \quad\quad (3)</script><p>​    v表示速度，P表示压力，g表示外力</p><p><strong>Continuity equation</strong></p><p>​    最初的SPH方法使用求和公式来计算密度:</p><script type="math/tex; mode=display">ρ_a = \sum_b m_b W_{ab}  \quad\quad (W_{ab} = W(\mathbf{x}_a - \mathbf{x}_b))  \quad\quad (4)</script><p>​    由于质量是由粒子携带的，这种形式正好保持了质量。然而，由于自由表面中的表面粒子具有较少的邻居，因此公式(4)为等间距粒子计算了表面附近的错误(较低)密度。</p><p>​    有几种方法可以解决这个问题。例如，[SDD06]使用自适应的核半径h，在表面强制执行恒定密度，并在表面模拟小规模效果。莫纳汉[Mon94]引入了另一种方法，并在[SAC*99]中通过求解连续性方程来使用，这导致了SPH形式：</p><script type="math/tex; mode=display">\frac{dρ_a}{dt} = \sum_b m_b \mathbf{v}_{ab} \nabla_a W_{ab} \quad\quad (5)</script><p>with $\mathbf{v}_{ab} = \mathbf{v}_a - \mathbf{v}_b$ </p><p>​    每个粒子都以密度ρ0初始化，密度变化只是由于粒子的相对运动。微分更新(5)保证了自由表面的正确密度。虽然使用(5)初始化更容易，但求和方法(4)更稳定，并已在我们的实验中使用。</p><p><strong>Momentum equation</strong></p><p>在SPH形式中，动量方程写成：</p><script type="math/tex; mode=display">\frac{d\mathbf{v}_a}{dt} = -\sum_b m_b \left( \frac{P_a}{ρ_a^2} + \frac{P_b}{ρ_b^2} \right) \nabla_a W_{ab} + \mathbf{g} \quad\quad (6)</script><p>这个对称的版本保持了线动量和角动量。</p><script type="math/tex; mode=display">\frac{Dv}{Dt} = \frac{dv}{dt}|_{v_0=v}=\frac{∂v}{∂t}+v\cdot \nabla v=\frac{∂v}{∂t} + u\frac{∂v}{∂x}+v\frac{∂v}{∂y}+w\frac{∂v}{∂z}</script><p><strong>Equation of state</strong></p><p>​    压力和密度有不同的联系形式。如果需要不可压缩性，泊松方程$\nabla^2 P = ρ\frac{\nabla \mathbf{v}}{∆t}$通常在欧拉方法中求解。然而，求解泊松方程是耗时的。相比之下，使用理想气体方程 $P = k_p ρ$ 或 $P = k_p(ρ - ρ_0)$ ，压力常数kp用于SPH，这导致相当高的可压缩性。</p><p>​    与这两种方法相比，我们使用泰特方程，该方程强制要求非常低的密度变化，并且计算效率高。忽略可以简单地作为恒压项添加的大气压力，泰特方程具有以下形式：</p><script type="math/tex; mode=display">P = B \left( \left(\frac{ρ}{ρ_0} \right)^{\gamma} -1 \right) \quad\quad (7)</script><p>with γ = 7</p><p>​    压力常数B控制相对密度波动 $\frac{|∆ρ|}{ρ_0}$，其中 ∆ρ=ρ - ρ<sub>0</sub> 。为了确定B的值，我们考虑可压缩性效应与$O(M^2)$成比例，M表示流动的马赫数。这导致以下关系：</p><script type="math/tex; mode=display">\frac{|∆ρ|}{ρ_0} \sim \frac{|\mathbf{v}_f|^2}{c_s^2} \quad\quad (8)</script><p>​    马赫数：流体力学中表征流体可压缩程度的一个重要的无量纲参数，记为Ma，定义为流场中某点的速度<em>v</em>同该点的当地声速c之比，即Ma=v/c。</p><p>​    因此，如果假设声速足够大，使得 $\frac{\mathbf{v}_f}{c_s} &lt; \sqrt{\eta}$，我们可以保证 $\frac{|∆ρ|}{ρ_0} \sim \eta$。通常，η设置为0.01，即允许1%数量级的密度变化。为了实施这一条件，选择B作为：</p><script type="math/tex; mode=display">B = \frac{ρ_0 c_s^2}{\gamma} \quad\quad (9)</script><p>​    假设声速很高以保持低密度波动，与不可压缩粒子方法相比，泰特方程需要更小的时间步长。但是我们避免了求解泊松方程，每个时间步长需要的计算时间要少得多。对于100k粒子，一个时间步长的计算速度可以比MPS快二十倍。</p><h3 id="Viscosity"><a href="#Viscosity" class="headerlink" title="Viscosity"></a>Viscosity</h3><p>​    为了提高数值稳定性并考虑到冲击现象，采用了人工粘度：</p><script type="math/tex; mode=display">\frac{d\mathbf{v}_a}{dt} =         \begin{cases}        -\sum_b m_b \Pi_{ab}\nabla_a W_{ab} & \mathbf{v}_{ab}^T\mathbf{x}_{ab}<0\\        0 & \mathbf{v}_{ab}^T\mathbf{x}_{ab}\geq 0        \end{cases} \quad\quad(10)</script><script type="math/tex; mode=display">\Pi_{ab} = -v \left(\frac{\mathbf{v}_{ab}^T \mathbf{x}_{ab}}{|\mathbf{x}_{ab}^2| + \varepsilon h^2} \right) \quad\quad (11)</script><p>​    粘性项：$v = \frac{2αhc_s}{ρ_a + ρ_b}$ ，粘性常数α，对于我们的实验，α在0.08和0.5之间。线动量和角动量在(11)中是守恒的。</p><h3 id="Surface-Tension"><a href="#Surface-Tension" class="headerlink" title="Surface Tension"></a>Surface Tension</h3><p>​    当前的表面张力模型通常基于分配给粒子a的颜色值ca，一个相位的所有粒子都具有相同的颜色值，根据颜色值进行插值：</p><script type="math/tex; mode=display">c = \sum_b \frac{m_b c_b}{ρ_b} W_{ab} \quad\quad (12)</script><p>​    表面法线计算为：$\mathbf{n} = \nabla c$  ，表面张力计算：</p><script type="math/tex; mode=display">\mathbf{f}^{tension} = -k \nabla^2 c \frac{\mathbf{n}}{|\mathbf{n}|} \quad\quad(13)</script><p>​    k是表面张力系数。</p><p>​    由于归一化，法线只有在它们的长度超过某个阈值时才会被考虑。</p><p>​    这种模式有几个缺点。在粒子只有几个邻居的表面附近，计算曲率 $-\nabla^2c$ 容易出错。此外，计算二阶导数对粒子无序很敏感。</p><p>​    胡和亚当斯提出了修改版本。将表面张力表示为应力张量π的散度，应力张量π由颜色场c唯一定义:</p><script type="math/tex; mode=display">\Pi = k \frac{1}{|\nabla c|} \left(\frac{1}{3} \mathbf{I} |\nabla c|^2 - \nabla c \nabla c^T \right) \quad\quad (14)</script><p>​    这个表达式得出加速度方程：</p><script type="math/tex; mode=display">\frac{d\mathbf{v}_a}{dt} = \frac{1}{m_a} \sum_b \nabla W_{ab} \left(\frac{\Pi_a}{\sigma_a^2} + \frac{\Pi_b}{\sigma_b^2} \right) \quad\quad (15)</script><p>​    with $\sigma_a = \sum_b W(r_a -r_b)$ ，此方法解决了上述问题，因为他们没有明确计算曲率，对于|∇c| → 0，张量自然趋于零。</p><p>​    虽然上述两种方法已经应用于自由表面问题，但这两种方法最初都是针对多相场景的。因此，在没有第二相的情况下，它们无法计算出正确的表面张力。它们缺少适当数量的相邻粒子，特别是在高曲率的表面区域。</p><p>​    本文提出了一个新的表面张力模型，它依赖于内聚力。由于以前的方法采用了模型的宏观视角，本文的方法受到微观视角的启发，因为在分子水平上，表面张力是由于分子之间的吸引力而产生的。本文使用光滑核W作为加权函数来缩放吸引力:</p><script type="math/tex; mode=display">\frac{d\mathbf{v}_a}{dt} = -\frac{κ}{m_a}\sum_b{m_b}W(\mathbf{x}_a - \mathbf{x}_b) \quad\quad (16)</script><p>​    此方法不依赖于第二相，适用于高曲率的自由表面问题。吸引力可以有效地计算出来。通过只对同相粒子施加吸引力，所提出的方法可以很容易地推广到多相问题。</p><h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><p>​    粒子方法的一些可视化技术基于显式表面重建。使用移动立方体(Marching Cubes)，从特征函数重建等值面。然而，捕捉小细节需要对底层空间进行非常精细或自适应的离散化。</p><p>​    粒子水平集不仅使用等值面，而且还引入了与速度场平流的示踪粒子。它们可以使用示踪粒子处理小液滴。然而，这些液滴不一定能捕捉模拟的分辨率。对于大变形，必须重新播种示踪粒子。在[KCC * 06]中，示踪粒子是用拉格朗日方法平流的。</p><p>​    受Zwicker等人[ZPvBG01]和Adams等人[ALD06]的表面喷溅算法启发，我们采用了一种光线追踪方法。小水花和单滴的可视化受到[KCC * 06]和[TRS06]的启发。该方法保证了适当地捕捉到小到单个粒子大小的特征。每个像素的法线计算类似于[Mor99]如下：</p><script type="math/tex; mode=display">\mathbf{n}_a = \sum_b\frac{m_b}{ρ_b}\nabla W(\mathbf{x}_a - \mathbf{x}_b) \quad\quad(17)</script><p>​    我们对所有被射线击中的粒子求和。在3.4GHz的奔腾4上，可视化130k粒子大约需要1-2秒。</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>​    在本节中，我们将说明SPH实现的一些属性。我们首先讨论模拟时间步长、边界条件和方法的初始化。随后，说明使用泰特方程与理想气体方程相比的效果，并讨论我们的表面张力模型的性质。最后，我们给出了一个带有碎波的示例场景。</p><p>​    邻域搜索通过均匀的空间细分来实现。集成是通过蛙跳方案实现的。所有实验均采用水的密度ρ<sub>0</sub>=  1000kg/m<sup>3</sup>进行。</p><h3 id="Time-step"><a href="#Time-step" class="headerlink" title="Time step"></a>Time step</h3><p>​    时间步长的适当选择对于稳定性和收敛性至关重要。在我们的例子中，时间步长由CFL条件、粘性项和力项[Mon92]导出:</p><script type="math/tex; mode=display">∆t = min\left(0.25\cdot \min\limits_a\ \left(\frac{h}{|\mathbf{f}_a|}\right), 0.4\cdot \frac{h}{c_s\cdot(1+0.6α)}\right) \quad\quad(18)</script><p>​    尽管就数值稳定性而言，时间步长可能更大，但我们使用建议的时间步长来确保收敛。</p><h3 id="Boundary-conditions"><a href="#Boundary-conditions" class="headerlink" title="Boundary conditions"></a>Boundary conditions</h3><p>​    在流体粒子与边界碰撞的地方插入边界粒子。根据[Mon05]，计算流体粒子a与边界粒子k碰撞的力$\mathbf{f}_{ak}$为：</p><script type="math/tex; mode=display">\mathbf{f}_{ak} = \frac{m_k}{m_a + m_k}\Gamma(\mathbf{x}_a,\mathbf{x}_b)\frac{\mathbf{x}_a - \mathbf{x}_k}{|\mathbf{x}_a-\mathbf{x}_k|} \quad\quad(19)</script><p>​    函数$\Gamma$定义为：</p><script type="math/tex; mode=display">\Gamma(\mathbf{x}_a,\mathbf{x}_b) = 0.02\frac{c_s^2}{|\mathbf{x}_a-\mathbf{x}_b|}        \begin{cases}            \frac{2}{3} & 0<q<\frac{2}{3}\\            (2q-\frac{3}{2}q^2) & \frac{2}{3}<q<1\\            \frac{1}{2}(2-q)^2 & 1<q<2\\            0 & otherwise        \end{cases} \quad\quad (20)</script><p>with $q = \frac{|\mathbf{x}_a - \mathbf{x}_b|}{h}$</p><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>​    为了获得近似恒定密度的有效状态我们使用求和方法(4)，用(6)的强阻尼版本将粒子演化一百步。在简单的初始几何图形的情况下，这种初始化可能会导致小的视觉伪影。</p><h3 id="Volume-preservation"><a href="#Volume-preservation" class="headerlink" title="Volume preservation"></a>Volume preservation</h3><p>​    为了比较基于Tait方程和理想气体方程的实现，我们进行了两个实验。在这两个实验中，我们测量最大密度和初始密度的比率，以评估体积保持。</p><p>​    在第一个实验中，我们用130k个粒子模拟了一个溃坝场景。大坝的高度是H =5。对于Tait方程，密度波动η设置为0.01。对于气体方程，压力常数Kp设置为300。密度波动和压力常数分别最小化和最大化，以便在两种方法中使用相同的时间步长。在两个版本中，粒子半径和初始间距为0.1，粘性项α为0.1，计算时间约为每时间步4.5s。气体方程测得的密度比是4.06，泰特方程测得的密度比是1.01，如图1所示。</p><p><img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_1.png" alt="Figure_1" style="zoom:80%;" /></p><p>​    the Tait equation (left) and the ideal gas equation (right). The gas equation  leads to high compressibility.</p><p>​    在第二个实验中，我们模拟了两个高度为H = 2、总粒子数为16k、粘度为α = 0.5的溃坝在一个矩形盆地中相互碰撞。气体方程的压力常数Kp设置为200，密度波动参数η设置为0.01。使用气体方程测得的最大密度比是1.2。由参数确定，对于泰特方程，测得的密度比是1.01。</p><p>​    两个实验都是以相同的密度和相同的粒子质量初始化。实验表明，对于恒定的初始密度和粒子半径，气体方程的密度比随着模拟流体的体积而增加，即随着粒子的数量而增加。与弱可压缩方法相比，气体方程观察到相当大的体积变化。当大坝坍塌时，这一点尤其明显。使用我们的弱可压缩方法，密度波动可以对越来越多的粒子保持不变。就体积保持而言，泰特方程因此适用于处理大型粒子系统。</p><h3 id="Surface-tension"><a href="#Surface-tension" class="headerlink" title="Surface tension"></a>Surface tension</h3><p>​    为了将我们的表面张力方法与[HA06]进行比较，我们使用了一个具有27k粒子的流体立方体，假设它在失重情况下会变形成一个水滴。对于可比结果，我们的方法的表面张力为0.8，而[HA06]的表面张力为30.6。可选参数设置主要影响收敛到平衡状态的速度。只要参数在合理范围内，定性结果不受影响。结果如图2所示。</p><p><img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_2.png" alt="Figure_2" style="zoom:80%;" /></p><p>​    The effect of surface tension. Initial state (left), resulting equilibrium using [HA06] (middle) and our surface tension approach (right).</p><p>​    由于[HA06]最初用于多相情况，它不太适合自由表面情况下的高曲率。与我们的方法相反，初始状态的高曲率基本上被保留。</p><p>​    在另一个实验中，我们研究了表面张力模型的参数设置。因此，我们模拟了具有两种不同表面张力的溃坝。表面张力0.01接近水，值3.4是此设定中最大的稳定值。如图3所示，选择较大的表面张力值会导致液体飞溅较大。</p><p><img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_3.png" alt="Figure_3" style="zoom:80%;" /></p><p>​    Two corner-breaking dams using a surface tension of 0.01 (left) and 3.4 (right).</p><h3 id="Breaking-waves"><a href="#Breaking-waves" class="headerlink" title="Breaking waves"></a>Breaking waves</h3><p>​    我们设计了一个场景来说明碎波的处理。我们在一个26×5的水池中使用了200k个粒子，其地面坡度为12°。半径和初始间距设置为0.1。密度波动设置为0.01。粘度项为α = 0.08。为了产生波，我们使用平面波发生器。计算时间为每个时间步长7.5s。从图4中可以看出，飞溅和碎波可以用我们的方法来模拟。</p><p><img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_4.png" alt="Figure_4" style="zoom:80%;" /></p><p>​    A breaking wave is generated using a wave generator</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>​    我们提出了一种用于自由表面流体的弱可压缩SPH方法。通过允许小的用户定义的密度波动，与严格执行不可压缩性的方法相比，Tait方程是一种有效的替代方法。与气体方程相比，即使有大量粒子，密度波动仍然很小。已经在各种场景中说明了体积保持。使用我们的方法可以模拟具有飞溅的低粘性流体的碎波等自然现象。</p><p>​    此外，我们还提出了一种基于内聚力的表面张力改进算法。与以前的方法相比，我们的模型可以处理单相自由表面流体的高曲率。</p><p>​    目前正在进行的工作重点是多相表面张力和自适应粘度方案，如[MM97]中所建议的。</p>]]></content>
    
    
    <categories>
      
      <category>scientific research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>SPH方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>交互式应用中基于粒子的流体模拟</title>
    <link href="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/"/>
    <url>/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Realistically animated fluids can <span class="hljs-keyword">add</span> substantial realism <span class="hljs-keyword">to</span> interactive applications such <span class="hljs-keyword">as</span> virtual surgery simulators <span class="hljs-keyword">or</span> computer games. <span class="hljs-keyword">In</span> this paper we propose an interactive <span class="hljs-keyword">method</span> based <span class="hljs-keyword">on</span> Smoothed Particle Hydrodynamics(SPH) <span class="hljs-keyword">to</span> simulate fluids <span class="hljs-keyword">with</span> free surfaces. The <span class="hljs-keyword">method</span> <span class="hljs-keyword">is</span> an <span class="hljs-keyword">extension</span> <span class="hljs-keyword">of</span> the SPH-based technique <span class="hljs-keyword">by</span> Desbrun <span class="hljs-keyword">to</span> animate highly deformable bodies. We gear the <span class="hljs-keyword">method</span> towards fluid simulation <span class="hljs-keyword">by</span> deriving the force density fields directly <span class="hljs-keyword">from</span> the Navier-Stokes equation <span class="hljs-keyword">and</span> <span class="hljs-keyword">by</span> adding a term <span class="hljs-keyword">to</span> model surface tension effects. <span class="hljs-keyword">In</span> contrast <span class="hljs-keyword">to</span> Eulerian grid-based approaches, the particle-based approach makes mass conservation equations <span class="hljs-keyword">and</span> convection terms dispensable which reduces the complexity <span class="hljs-keyword">of</span> the simulation. <span class="hljs-keyword">In</span> addition, the particles can directly be used <span class="hljs-keyword">to</span> render the surface <span class="hljs-keyword">of</span> the fluid. We propose methods <span class="hljs-keyword">to</span> track <span class="hljs-keyword">and</span> visualize the free surface <span class="hljs-keyword">using</span> <span class="hljs-type">point</span> splatting <span class="hljs-keyword">and</span> marching cubes-based surface reconstruction. Our animation <span class="hljs-keyword">method</span> <span class="hljs-keyword">is</span> fast enough <span class="hljs-keyword">to</span> be used <span class="hljs-keyword">in</span> interactive systems <span class="hljs-keyword">and</span> <span class="hljs-keyword">to</span> allow <span class="hljs-keyword">for</span> <span class="hljs-keyword">user</span> interaction <span class="hljs-keyword">with</span> models consisting <span class="hljs-keyword">of</span> up <span class="hljs-keyword">to</span> <span class="hljs-number">5000</span> particles.<br></code></pre></td></tr></table></figure><p><strong>Smoothed Particle Hydrodynamics (SPH)</strong></p><p>​        光滑粒子流体动力学。拉格朗日视角，一种无网格方法。该方法的基本思想是将连续的流体(或固体)用相互作用的质点组来描述，各个物质点上承载各种物理量，包括质量、速度等，通过求解质点组的动力学方程和跟踪每个质点的运动轨道，求得整个系统的力学行为。</p><p>​        对于流体的研究，有两种不同的坐标系，分别是欧拉法和拉格朗日法。欧拉视角的坐标系是固定的，如同站在河边观察河水的流动一样，用这种视角分析流体需要建立网格单元，还会涉及到有限元等复杂的工程方法，一般用在离线的应用中。而拉格朗日视角则将流体视为流动的单元，例如将一片羽毛放入风中，那么羽毛的轨迹可以帮我们指示空气的流动规律。SPH算法是典型的拉格朗日视角，它的基本原理就是通过粒子模拟流体的运动规律，然后再转换成网格进行流体渲染。</p><p><strong>force density</strong></p><p>​        力密度</p><p><strong>Navier-Stokes equation</strong></p><p>​        纳维-斯托克斯方程，描述粘性不可压缩流体动量守恒的运动方程。简称N-S方程。粘性流体的运动方程首先由Navier在1827年提出，只考虑了不可压缩流体的流动。Poisson在1831年提出可压缩流体的运动方程。Saint-Venant在1845年，Stokes在1845年独立提出粘性系数为一常数的形式，都称为Navier-Stokes方程，简称N-S方程。</p><p><strong>surface tension</strong></p><p>​        表面张力。水等液体会产生使表面尽可能缩小的力，这个力称为“表面张力”。液体具有内聚性和吸附性，这两者都是分子引力的表现形式。内聚性使液体能抵抗拉伸应力，而吸附性则使液体可以黏附在其他物体上面。在液体和气体的分界处，即液体表面及两种不能混合的液体之间的界面处，由于分子之间的吸引力，产生了极其微小的拉力。假想在表面处存在一个薄膜层，它承受着此表面的拉伸力，液体的这一拉力称为表面张力。</p><p><strong>Eulerian</strong></p><p>​        欧拉法。是以流体质点流经流场中各空间点的运动即以流场作为描述对象研究流动的方法——流场法。它不直接追究质点的运动过程，而是以充满运动液体质点的空间——流场为对象。研究各时刻质点在流场中的变化规律。将个别流体质点运动过程置之不理，而固守于流场各空间点。通过观察在流动空间中的每一个空间点上运动要素随时间的变化，把足够多的空间点综合起来而得出的整个流体的运动情况。</p><p><strong>流体运动的数学描述</strong></p><p>​        <strong>拉格朗日（Lagrange ）法——随体法</strong></p><p>​        拉格朗日法着眼于研究各个流体质点的运动，描述的流体质点至始至终的运动过程以及它们的物理量随时间t的变化规律。</p><p>​        <strong>欧拉（Euler ）法——当地法</strong></p><p>​        欧拉法着眼于空间点，描述的是各个时刻，各个空间点（场论的概念）中流体质点物理量的变化情况。物理量在空间中的分布称为物理场，如速度场、压力场、密度场等，这些所有的物理量场统称为流场。</p><p><strong>mass conservation</strong></p><p>​        质量守恒。</p><p><strong>convection terms</strong></p><p>​        对流项。速度运输动量。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><strong>1.1 Motivation</strong></p><p>​        不太精确的方法允许实时模拟流体效应，这开辟了各种新的应用。实时方法有助于在设计阶段测试某个概念是否有前途。流体实时模拟技术的其他应用包括医学模拟器、计算机游戏或任何类型的虚拟环境。</p><p><strong>1.2 Related Work</strong></p><p>​        Computational Fluid Dynamics (CFD) 计算流体力学 历史：</p><p>​        1822年Claude Navier和1845年George Stokes建立了著名的Navier-Stokes方程，描述了流体动力学；</p><p>​        描述质量守恒的连续性方程和描述能量守恒的状态方程；</p><p>​        1983年，T. Reeves引入了粒子系统作为一种建模一类模糊对象的技术。此后，基于粒子的拉格朗日方法和基于网格的欧拉方法被用于计算机图形学中流体的模拟；</p><p>​        Desbrun和Cani和Tonnesen使用粒子使软物体产生动画效果；</p><p>​        本文提出了一种基于光滑粒子流体动力学的基于质点的方法来实现任意流体运动的动画。</p><p><strong>1.3. Our Contribution</strong></p><p>​        提出了一种基于光滑粒子流体动力学(SPH)的方法来模拟具有自由表面的流体。Stam和Fiume首先将SPH引入图形界，以描述火和其他气体现象。后来，德斯布伦使用SPH动画高度可变形的物体。我们将他的方法扩展到流体的模拟上。为此，我们直接从Navier-Stokes方程推导出粘性力场和压力场，并提出了一种表面张力的建模方法。为了实现交互性，我们设计了新的专用平滑核。在交互速率下的表面跟踪和表面绘制是一个困难的问题，我们描述了可能的解决方案。</p><h2 id="2-Smoothed-Particle-Hydrodynamics"><a href="#2-Smoothed-Particle-Hydrodynamics" class="headerlink" title="2. Smoothed Particle Hydrodynamics"></a>2. Smoothed Particle Hydrodynamics</h2><p>​        SPH是粒子系统的一种插值方法。有了SPH，仅在离散粒子位置定义的场量可以在空间的任何地方计算。为此，SPH在每个粒子的局部邻域分布数量使用径向对称平滑核。</p><p>​        “平滑核”可以这样理解这个概念，粒子的属性都会“扩散”到周围，并且随着距离的增加影响逐渐变小，这种随着距离而衰减的函数被称为“平滑核”函数，最大影响半径为“平滑核半径”。</p><p>​        根据SPH，在<strong>r</strong>位置，平滑核半径h范围内有数个粒子，位置为<strong>r<sub>0</sub></strong>到<strong>r<sub>j</sub></strong>，用所有粒子贡献的加权和表示插值标量A:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F1.png" alt="公式1"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F1.png" class="" title="This is image1"><p><em>其中A<sub>j</sub>是在r<sub>j</sub>位置要迭代的某种属性，m<sub>j</sub>和ρ<sub>j</sub>是粒子j的质量和密度，<strong>r<sub>j</sub></strong>是该粒子的位置，h是平滑核半径。函数W就是平滑核函数。</em></p><p>​        函数W(r,h)称为核半径为h的平滑核，由于我们只使用有限支撑集（support，也就是函数值不为0的点所组成的集合）的核，因此在公式中我们使用h作为支撑集半径。如果W为偶函数(即W(r,h) =W(−r,h))并归一化，插值具有二阶精度。平滑核函数是标准化的：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F2.png" alt="公式2"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F2.png" class="" title="This is image2"><p>​        粒子质量和密度出现在公式(1)中，每个粒子i的体积V<sub>i</sub> = m<sub>i</sub> /ρ<sub>i</sub> ，在整个模拟过程中质量m<sub>i</sub> 是恒定的，密度ρ<sub>i</sub> 是变化的，并且需要在每个时间步长进行评估。通过代入公式(1)得到位置r处的密度:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F3.png" alt="公式3"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F3.png" class="" title="This is image3"><p>​        在大多数流体方程中，出现了场量的导数，并需要计算。在SPH方法中，这些导数只影响平滑核。A的梯度：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F4.png" alt="公式4"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F4.png" class="" title="This is image4"><p>​        A的拉普拉斯式求值是：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F5.png" alt="公式5"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F5.png" class="" title="This is image5"><p>​        SPH存在一些固有的问题。当用SPH推导粒子的流体方程时，这些方程不能保证满足某些物理原理，如力的对称性和动量守恒。</p><h2 id="3-Modelling-Fluids-with-Particles"><a href="#3-Modelling-Fluids-with-Particles" class="headerlink" title="3. Modelling Fluids with Particles"></a>3. Modelling Fluids with Particles</h2><p>​        这部分介绍基于SPH的模型和技术，以解决这些SPH相关的问题。</p><p>​        在基于网格的欧拉公式中，等温流体由速度场v、密度场ρ和压力场p来描述。这些量随时间的变化由两个方程给出。第一个方程保证了质量守恒：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F6.png" alt="公式6"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F6.png" class="" title="This is image6"><p>​        Navier-Stokes方程则表示动量守恒：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F7.png" alt="公式7"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F7.png" class="" title="This is image7"><p><em>g为重力加速度，μ为流体的粘度（粘性系数）。公式(7)表示不可压缩流体的简化形式。</em></p><p>​        使用粒子而不是静止网格大大简化了这两个方程。首先，因为粒子的数量是恒定的，每个粒子的质量恒定，质量守恒是有保证的，公式(6)可以完全省略。第二，公式(7)左边的 <u>∂v/∂t+v·∇v</u> 可以用随体导数Dv/Dt代替。由于粒子随流体运动，速度的随体导数仅仅是粒子速度的时间导数，这意味着粒子系统不需要对流项v·∇v。</p><p>​        在公式(7)的右边有三个力密度场。建模压力(−∇p)、外力(ρ<strong>g</strong>)、粘度(μ∇<sup>2</sup><strong>v</strong>)。这些力密度场<strong>f</strong> =−∇p+ρ<strong>g</strong>+μ∇<sup>2</sup><strong>v</strong>的和决定了左边粒子的动量变化量ρDv/Dt。对于粒子i的加速度，则有:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F8.png" alt="公式8"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F8.png" class="" title="This is image8"><p>下面使用SPH来建模力密度项</p><h3 id="3-1-Pressure"><a href="#3-1-Pressure" class="headerlink" title="3.1 Pressure"></a>3.1 Pressure</h3><p>​        将SPH规则应用到压力项−∇p：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F9.png" alt="公式9"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F9.png" class="" title="This is image9"><p>​        不幸的是，当只有两个粒子相互作用时，这种力是不平衡的。由于核函数在中心的梯度为零，粒子i只使用粒子j的压力来计算其压力，反之亦然。由于两个粒子位置上的压力一般不相等，所以压力不会是平衡的。文献中提出了公式(9)不同的平衡方法。我们建议了一个非常简单的解决方案，发现它最适合我们的速度和稳定的目的：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F10.png" alt="公式10"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F10.png" class="" title="This is image10"><p>​        这样计算出来的压力是平衡的，因为它使用了相互作用粒子压力的算术平均值。</p><p>​        由于粒子只携带质量、位置和速度三个量，因此必须首先评估粒子位置处的压力。这需要两个步骤。公式(3)产生粒子所在位置的密度。然后，通过理想气体状态方程计算压强：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F11.png" alt="公式11"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F11.png" class="" title="This is image11"><p><em>k是一个气体常数，它只与温度有关</em></p><p>​        改进：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F12.png" alt="公式12"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F12.png" class="" title="This is image12"><p>​        ρ<sub>0</sub>是流体的静态密度（标准密度）。</p><p>​        由于压力依赖于压力场的梯度，从数学上讲，偏移量对压力没有影响。然而，偏移量对SPH平滑场的梯度有一定的影响，使数值模拟更加稳定。</p><h3 id="3-2-Viscosity"><a href="#3-2-Viscosity" class="headerlink" title="3.2 Viscosity"></a>3.2 Viscosity</h3><p>​        将SPH规则应用到粘度项μ∇<sup>2</sup><strong>v</strong>，得到不平衡的作用力：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F13.png" alt="公式13"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F13.png" class="" title="This is image13"><p><em>速度场随粒子而变化。</em></p><p>​        由于粘滞力只依赖于速度差而不依赖于绝对速度，因此有一种利用速度差来对称粘滞力的自然方法:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F14.png" alt="公式14"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F14.png" class="" title="This is image14"><p>​        公式(14)的一种可能的解释是从粒子i自身的运动参照系观察粒子i的邻域。那么粒子i就会朝着它周围环境的相对速度方向加速。</p><h3 id="3-3-Surface-Tension"><a href="#3-3-Surface-Tension" class="headerlink" title="3.3 Surface Tension"></a>3.3 Surface Tension</h3><p>​        基于Morris的思想模拟表面张力。流体中的分子受到邻近分子的引力。在流体内部，这些分子间的力在各个方向上是相等的，并且相互平衡。相反，作用在自由表面分子上的力是不平衡的。净力(即表面张力)作用于表面垂直于流体的方向。他们也倾向于最小化表面的曲率。曲率越大，力就越大。表面张力还取决于张力系数σ，该系数取决于形成表面的两种流体。</p><p>​        流体的表面可以通过使用一个附加的场量来找到，这个场量在存在粒子的位置上为1，不存在粒子的位置为0。这个场称为色场。对于平滑的色场，我们得到:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F15.png" alt="公式15"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F15.png" class="" title="This is image15"><p>​        平滑的色场的梯度：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F16.png" alt="公式16"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F16.png" class="" title="This is image16"><p>​        产生指向流体的表面法向场，n的散度测量表面的曲率：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F17.png" alt="公式17"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F17.png" class="" title="This is image17"><p>​        对于凸面的流体体积，负曲率是得到正曲率的必要条件。综上所述，我们得到了表面牵引力:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F18.png" alt="公式18"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F18.png" class="" title="This is image18"><p>​        为了在表面附近的粒子之间分配表面牵引力，并获得力密度，我们乘以一个归一化标量场δs=| <strong>n</strong> |，该场仅在表面附近是非零的。对于作用在表面附近的力密度，我们得到：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F19.png" alt="公式19"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F19.png" class="" title="This is image19"><p>​        在|<strong>n</strong>|较小的位置计算<strong>n</strong>/|<strong>n</strong>|会造成数值问题。我们只在|<strong>n</strong>|超过某个阈值时计算力。</p><h3 id="3-4-External-Forces"><a href="#3-4-External-Forces" class="headerlink" title="3.4 External Forces"></a>3.4 External Forces</h3><p>​        我们的模拟器支持外力，如重力，碰撞力和用户交互引起的力。这些力直接施加在粒子上，而不使用SPH。在我们的例子中，当粒子与固体物体（如玻璃）碰撞时，我们只需将它们推出物体，并反射垂直于物体表面的速度分量。</p><h3 id="3-5-Smoothing-Kernels"><a href="#3-5-Smoothing-Kernels" class="headerlink" title="3.5 Smoothing Kernels"></a>3.5 Smoothing Kernels</h3><p>​        SPH方法的稳定性、精度和速度在很大程度上取决于平滑核的选择。由于核函数都是偶函数且归一化的，所以我们使用的核函数有二阶插值误差（见图1）。</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%9B%BE1.png" alt="图1"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%9B%BE1.png" class="" title="This is image_1"><p><em>我们在模拟中使用的三个平滑核W<sub>poly6</sub>、W<sub>spiky</sub>和W<sub>viscosity</sub>（从左到右）。粗线表示核函数，细线表示向中心方向的梯度，虚线表示拉普拉斯函数。请注意，这些图的比例不同。曲线显示沿一个轴通过平滑长度h=1的中心的三维核函数。</em></p><p>​        此外，在边界处导数为零的核有利于稳定性。除了这些约束，人们还可以自由地为特殊目的设计核函数。我们设计了下面的核函数：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F20.png" alt="公式20"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F20.png" class="" title="This is image20"><p>​    除了两种情况外，所有情况下都使用它。这个简单核函数的一个重要特征是r只出现平方，这意味着在距离计算中不需要计算平方根。然而，如果用这个核函数来计算压力，粒子往往会在高压下形成团簇。当粒子彼此非常接近时，斥力消失，Poly6核的梯度在中心变为0，因此它不适用于插值压力，为了使粒子接近时具有较大的压力，必须使用另一种梯度在0点有较大取值的平滑核来插值压力，称为Spiky核，该内核在中心附近有一个非消失的梯度。对于压力的计算，我们使用Debrun的Spiky核：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F21.png" alt="公式21"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F21.png" class="" title="This is image21"><p>​        这产生了必要的斥力。在边界处，一阶导数和二阶导数都为零。</p><p>​        粘性是一种由摩擦引起的现象，通过将流体加热来降低流体的动能。因此，粘性只对速度场有平滑作用。然而，如果用一个标准核来计算粘度，则产生的粘性力并不总是具有这种性质。对于两个相互靠近的粒子，平滑速度场的拉普拉斯系数（粘性力依赖于此）可能会变为负值，从而导致粘性力增加其相对速度。在粗采样的速度场中会出现伪影。在粒子数相对较少的实时应用中，这种影响会导致稳定性问题。因此需要使用另一种平滑核插值粘性力，称为粘度核：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F22.png" alt="公式22"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F22.png" class="" title="This is image22"><p>​        它的拉普拉斯方程处处为正，并具有以下附加性质:</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cproperties.png" alt="properties"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/properties.png" class="" title="This is image_2"><p>​        使用此核来进行黏性力计算，大大提高了模拟的稳定性，可以省略任何类型的附加阻尼。</p><h3 id="3-6-Simulation"><a href="#3-6-Simulation" class="headerlink" title="3.6 Simulation"></a>3.6 Simulation</h3><p>​        对于公式(8)的积分，我们采用蛙跳法。作为一个只需计算一次力的二阶方案，它最适合我们的目的，在我们的例子中允许时间步长达10毫秒。对于这些例子，我们使用恒定的时间步长。如果基于Courant-Friedrichs-Lewy条件使用自适应时间步长，我们预计会有更好的性能。</p><p><strong>蛙跳差分格式</strong></p><p>​        蛙跳格式是一个很常用的差分格式，它在时间和空间上都采用中心差分。（通过解差分方程来求微分方程的近似解，是连续问题离散化）假设离散化如下图所示：</p><img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog1.png" alt="leap_frog1" style="zoom:80%;" /><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog1.png" class="" title="This is image_3"><img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog2.png" alt="leap_frog2" style="zoom:80%;" /><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog2.png" class="" title="This is image_4"><p>​        蛙跳格式是时间和空间上均为二阶精度的，三层一步显式差分格式。因而，为了计算(n+1)层的值，需要(n-1)层和n层的已知值。另外，还可以看出，后一偶数层的值实际上等于前一偶数层的值加上一个变化量，而跳过其间的奇数层，这就是蛙跳式这个名称的来历。</p><img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog3.png" alt="leap_frog3" style="zoom:80%;" /><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog3.png" class="" title="This is image_5"><p><strong>CFL收敛条件判断数</strong></p><p>​        CFL数是计算流体力学中，判断计算的收敛条件，具体是差分方程的依赖域必须包含相应微分方程的依赖域，最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。Time stepping technique是指时间推进技术，一般有统一时间步长和当地时间步长，而选择当地时间步长也就是当地CFL条件允许的最大时间步长，采用这种方法能够加速收敛，节省计算时间。</p><h2 id="4-Surface-Tracking-and-Visualization"><a href="#4-Surface-Tracking-and-Visualization" class="headerlink" title="4. Surface Tracking and Visualization"></a>4. Surface Tracking and Visualization</h2><p>​        第3.3节中定义的色场c<sub>S</sub>及其梯度<strong>n</strong>=∇c<sub>S</sub>可用于识别表面粒子和计算表面法线。</p><p>​        我们把粒子i定义为表面粒子，如果：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F23.png" alt="公式23"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F23.png" class="" title="This is image23"><p>​        其中l是阈值参数。粒子i位置处的表面法线方向由下式给出：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F24.png" alt="公式24"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F24.png" class="" title="This is image24"><h3 id="4-1-Point-Splatting"><a href="#4-1-Point-Splatting" class="headerlink" title="4.1 Point Splatting"></a>4.1 Point Splatting</h3><p>​        我们现在有一组法线但没有连通性信息的点。这正是point splatting（把点变成有面积的简单几何形状渲染）所需的信息类型。然而，这些方法被设计用于处理从通常至少包含10,000到100,000个点的扫描仪获得的点云。我们只使用了几千个粒子，其中一小部分被确定存在于表面。如结果部分所示，静止表面飞溅会产生似乎合理的结果。我们目前正在研究提高液体表面采样率的方法。因此，插值表面粒子的颜色场信息，在仅用于渲染的表面上寻找附加粒子的位置。</p><h3 id="4-2-Marching-Cubes"><a href="#4-2-Marching-Cubes" class="headerlink" title="4.2 Marching Cubes"></a>4.2 Marching Cubes</h3><p>​        另一种可视化自由表面的方法是绘制色场c<sub>S</sub>的等值面。我们使用移动立方体算法对等值面进行三角剖分。在空间固定的网格中，首先识别包含表面的单元格。我们从包含表面粒子的所有单元格开始搜索，然后沿着表面递归地遍历网格。使用哈希表，我们可以确保单元格不会被访问超过一次。对于识别出包含表面的每个单元格，三角形是通过快速查表生成的。</p><p><strong>Marching Cubes算法</strong></p><p>​        Marching Cubes算法是三维离散数据场中提取等值面的经典算法。算法主要的思想是在三维离散数据场中通过线性插值来逼近等值面，具体如下：三维离散数据场中每个栅格单元作为一个体素，体素的每个顶点都存在对应的标量值。如果体素顶点上的值大于或等于等值面值，则定义该顶点位于等值面之外，标记为“0”；而如果体素顶点上的值小于等值面值，则定义该顶点位于等值面之内，标记为“1”。由于每个体素单元有8个顶点，每个顶点有2种状态，那么共存在2<sup>8</sup> = 256种情形。但由于反转状态不变，所以可以减少一半，为128种。再根据旋转不变形，又可以减少到15种情况。</p><p>​        如图所示：</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/MC_15%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="MC_15种情况"></p><p>​        每个体素单元上顶点和边的索引规则如下图左所示，假如体素下方的顶点3的值小于等值面值，其他顶点上的值都大于等值面值（如下图右所示），那么我们可以生成一个与体素边2，3，11相交的三角面片，而三角面片顶点的具体位置则需要根据等值面值和边顶点3-2，3-0，3-7的值线性插值计算得到。</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E7%AD%89%E5%80%BC%E9%9D%A2.png" alt="等值面"></p><p>​        对于与等值面存在交点的体素边，交点坐标用P表示，P1、P2代表边上两个端点的坐标，V1、V2代表这两个端点上的值，V代表等值面值，那么交点坐标的计算公式：P = P1 + (V – V1)·(P2 – P1)/(V2 – V1)</p><p><strong>算法第一步：</strong>通过edgeTable表判断等值面和体素单元哪一条边相交</p><p>​        体素单元顶点状态的索引号定义规则如下：</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E9%A1%B6%E7%82%B9%E7%8A%B6%E6%80%81%E7%B4%A2%E5%BC%95.png" alt="顶点状态索引"></p><p>​        以上图所示为例，仅顶点3标记为“1”，其他顶点标记为“0”，那么体素单元的顶点状态为0000 1000或者8，通过查找表得到edgeTable[8] = 1000 0000 1100，意味着体素单元的边2，3，11和等值面相交，然后通过线性插值计算各个交点的位置。</p><p><strong>算法第二步：</strong>通过triTable表生成对应三角面片的组成情况</p><p>　　还是以上图所示为例，通过查找表得到triTable[8] = {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}，意味着该种顶点状态可以生成三角面片(3, 11, 2)，代表三角面片的3个顶点为边3，11，2和等值面相交的交点。</p><p>　　经过上述步骤之后，我们可以得到等值面的点面信息。为了进一步完善显示效果，需要调整顶点法向。假设顶点(i, j, k)上的值为f(i, j, k)，采用中心差分方法可以计算该点处的梯度矢量：</p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95.png" alt="中心差分法" style="zoom:90%;" /><p>​        对G进行归一化，得到顶点(i, j, k)上的单位法向量，然后对体素单元上8个顶点的法向量进行线性插值就可得到三角面片各个顶点的显示法向量。</p><h2 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h2><p>​        由于SPH中使用的平滑核具有有限的支持集h，降低计算复杂度的一种常用方法是使用h大小的网格，然后只需在粒子自己的单元和所有相邻的单元中搜索粒子i的潜在交互伙伴。该技术将力计算步骤的时间复杂度从O（n<sup>2</sup>）降低到O（nm），m是每个网格单元的平均粒子数。</p><p>​        通过一个简单的附加技巧，我们可以将模拟速度提高10倍。我们将粒子对象的副本存储在网格单元中(使内存消耗加倍)，而不是存储对粒子的引用。加速的原因是内存中接近插值所需的信息，这大大提高了cash命中率。通过使用希尔伯特空间填充曲线进行更好的聚类，可能进一步加速。快速近邻搜索的数据结构也用于曲面跟踪和渲染。</p><p><strong>SPH的求解过程</strong></p><p>​        标准SPH的求解过程可以由下图概括（[Kelager2006] ）</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/SPH%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.png" alt="SPH求解过程"></p><p>详细的算法过程如下：</p><ol><li>对于全部的粒子建立空间索引；</li><li>对于全部的粒子计算粘性力、合外力，压强，密度，并根据这些力的作用计算粒子的加速度；</li><li>根据粒子的加速度与时间步长得到下一时刻的速度和位置（时间积分, Time integration），并处理必要的碰撞。</li></ol><p>需要注意的是：</p><ol><li>对于步骤1，由于SPH是考察一个粒子被周围粒子影响效应的叠加，我们需要在整个粒子空间中遍历多次，时间复杂度为<strong>O</strong>(<strong>n</strong>)。加速方法可以采用快速最近邻查找算法（原始文献参见[Teschner2003]）。[Kelager2006] 给这个算法做了一个简单的概括；</li><li>对于步骤2，对于某些确定的物理量，我们需要决定哪些粒子对我们考察的粒子产生影响。这些粒子的范围是由核函数的支撑集长度决定的；流体的不可压缩性是由我们人为引入的压强所保证的；</li><li>对于步骤3，我们可以使用很多时间积分方法，比如前向欧拉（Forward Euler），蛙跳（Leap Frog）等。蛙跳法的具体形式如下：</li></ol><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog4.png" alt="leap_frog4"></p><p>​        其中：</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog5.png" alt="leap_frog5"></p><h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h2><p>​        图R1所示，用2200个粒子对玻璃中的水进行采样。外部旋转力使流体形成漩涡。第一张图（a）显示了单个粒子。对于第二幅图像（b），仅用point splatting渲染自由表面。在这两种模式下，动画以每秒20帧的速度在1.8GHz的Pentium IV PC上运行，并带有Gforce4显卡。当使用marching cubes算法将颜色场的等值面可视化时，会产生最令人信服的结果，如图（c）所示。但是，在这种模式下，帧速率下降到每秒5帧。尽管如此，这种帧速率仍然明显高于大多数离线流体模拟技术，而且随着下一代图形硬件的发展，实时性能将成为可能。</p><p>​        图R2所示的图像序列演示了与流体的交互作用。通过鼠标移动，用户产生一个使水飞溅的外力场。自由表面使用point splatting进行渲染，而孤立的粒子绘制为单个液滴。对1300个粒子的模拟以每秒25帧的速度运行。</p><p>​        对于图R3中所示的动画，我们使用了3000个粒子，并以每秒5帧的速度用marching cubes技术渲染了表面。</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult1.png" alt="result1"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result1.png" class="" title="This is image_result1"><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult2.png" alt="result2"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result2.png" class="" title="This is image_result2"><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult3.png" alt="result3"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result3.png" class="" title="This is image_result3"><h2 id="7-Conclusions-and-FutureWork"><a href="#7-Conclusions-and-FutureWork" class="headerlink" title="7. Conclusions and FutureWork"></a>7. Conclusions and FutureWork</h2><p>​        提出了一种基于粒子的交互式流体模拟与绘制方法。物理模型基于平滑粒子流体力学，并使用特殊用途的核来提高稳定性和速度。我们介绍了跟踪和渲染流体自由表面的技术。结果还不如离线计算的动画那样逼真。然而，考虑到仿真模拟是以交互速率运行的，而不是像今天的离线方法那样每帧花费几分钟或几小时，结果是相当有希望的。</p><p>​        在满足物理模型要求的前提下，流体表面的实时跟踪与渲染仍然是一个有待研究的课题。在未来，我们将研究提高采样技术以及提高基于marching cubes算法性能的方法。</p><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>​        <strong>哈密顿算子𝛁</strong></p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5CNabla.png" alt="Nabla"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/Nabla.png" class="" title="This is Hamiltonian"><p>​        𝛁在运算中既有微分又有矢量的双重运算性质。</p><p>​        与梯度、散度、旋度的关系：</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct2.png" alt="t2"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t2.png" class="" title="This is image_t2"><p>​        把它作用在一个标量场A=f(x,y,z)上，那么：</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/grad.png" alt="grad"></p><p>​        这个运算可以视为一个矢量和标量的乘法，得到的∇A是一个矢量场，称为A的“梯度”，表示标量场A在某处的变化快慢和方向。</p><p>​        而如果把哈密顿算子作用在一个矢量场A上，得到的∇·A称为矢量场A的“散度”，散度的计算和矢量的点积运算相似，得到的是一个标量场。</p><p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/div.png" alt="div"></p><p>​        <strong>拉普拉斯算子</strong></p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct3.png" alt="t3"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t3.png" class="" title="This is image_t3"><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct4.png" alt="t4"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t4.png" class="" title="This is image_t4"><p>​        </p><p>​        在一个时空连续变化的物理场φ(<strong>r</strong>,t)中，运动的观察点观察到的物理量φ的时间变化可以写</p><p>为（式中 𝜹𝒓为观察点在微元时间 𝛿𝑡中的矢量位移， 𝜹𝒓=𝛿𝑡 𝒗<sub>𝑂</sub> ，𝛁是哈密顿算子）</p><p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct1.png" alt="t1"></p><img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t1.png" class="" title="This is image_t1">]]></content>
    
    
    <categories>
      
      <category>scientific research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paper</tag>
      
      <tag>SPH方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（7）L R分析程序及其自动构造</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="7-1-LR分析概述"><a href="#7-1-LR分析概述" class="headerlink" title="7.1 LR分析概述"></a>7.1 LR分析概述</h2><p>shift 移进</p><p>reduce 归约</p><p>acc 接受</p><p>空格 error</p><p><strong>LR（K）</strong></p><ul><li>L  从左至右扫描输入符号串</li><li>R 构造一个最右推导的逆过程</li><li>K 向右顺序查看输入串的K个符号</li><li>LR（0）:在分析过程中不需向右查看输入符号。</li></ul><p>四种分析器： LR(0)  SLR(1)  LR(1)  LALR(1)</p><p>SLR(1)和LALR(1)分别是LR(0)和LR(1)的一种改进。</p><h3 id="LR分析器模型"><a href="#LR分析器模型" class="headerlink" title="LR分析器模型"></a>LR分析器模型</h3><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614142419341.png" alt="image-20200614142419341" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614142419341.png" class="" title="This is image_a"><h3 id="LR分析算法"><a href="#LR分析算法" class="headerlink" title="LR分析算法"></a>LR分析算法</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gauss">置ip指向输入串w的第一个符号<br>令S为栈顶状态<br>   a是ip指向的符号<br>重复 begin<br><span class="hljs-keyword">if</span>  ACTION[S,a]=Sj<br>       then   begin  <span class="hljs-keyword">PUSH</span> j,<span class="hljs-built_in">a</span>(进栈)<br>                     ip 前进(指向下一输入符号)<br>               <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ACTION[S,a]=<span class="hljs-built_in">rj</span>     (第j条产生式为A→B)<br>then begin<br>    <span class="hljs-keyword">pop</span>  |β|  项<br>    令当前栈顶状态为S’<br>    <span class="hljs-keyword">push</span> <span class="hljs-keyword">GOTO</span>[S’,A]和<span class="hljs-built_in">A</span>(进栈)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ACTION[s,a]=acc<br>        then <span class="hljs-keyword">return</span> (成功）<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">error</span><br>    <span class="hljs-keyword">end</span>.重复<br><br>其中，Sj=<span class="hljs-keyword">GOTO</span>[Si,X]表示当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj<br></code></pre></td></tr></table></figure><h3 id="LR分析程序"><a href="#LR分析程序" class="headerlink" title="LR分析程序"></a>LR分析程序</h3><p>例：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">G[S]: S → a A c B e   [1]   <br>      A → b           [2] <br>      A → Ab          [3]<br>      B → d           [4]<br>w=abbcde<span class="hljs-comment">#</span><br><br>Step   states.   Syms.   The rest of inputaction goto<br>1       <span class="hljs-number"> 0 </span>       <span class="hljs-comment">#            abbcde#           s2</span><br>2       <span class="hljs-number"> 02 </span>      <span class="hljs-comment">#a           bbcde#            s4</span><br>3       <span class="hljs-number"> 024 </span>     <span class="hljs-comment">#ab          bcde#             r2   goto(2,A)</span><br>4       <span class="hljs-number"> 023 </span>     <span class="hljs-comment">#aA          bcde#             s6</span><br>5       <span class="hljs-number"> 0236 </span>    <span class="hljs-comment">#aAb         cde#              r3</span><br>6       <span class="hljs-number"> 023 </span>     <span class="hljs-comment">#aA          cde#              s5</span><br>7       <span class="hljs-number"> 0235 </span>    <span class="hljs-comment">#aAc         de#               s8</span><br>8       <span class="hljs-number"> 02358 </span>   <span class="hljs-comment">#aAcd        e#                r4 </span><br>9       <span class="hljs-number"> 02357 </span>   <span class="hljs-comment">#aAcB        e#                s9</span><br>10      <span class="hljs-number"> 023579 </span>  <span class="hljs-comment">#aAcBe       #                 r1</span><br>11      <span class="hljs-number"> 01 </span>      <span class="hljs-comment">#S           #                 acc</span><br></code></pre></td></tr></table></figure><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143324736.png" alt="image-20200614143324736" style="zoom:90%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143324736.png" class="" title="This is image_b"><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143850915.png" alt="image-20200614143850915" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143850915.png" class="" title="This is image_c"><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143916188.png" alt="image-20200614143916188" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143916188.png" class="" title="This is image_d"><h3 id="构造LR分析表的预备知识"><a href="#构造LR分析表的预备知识" class="headerlink" title="构造LR分析表的预备知识"></a>构造LR分析表的预备知识</h3><p><strong>ＬＲ文法</strong></p><ul><li>对于一个上下文无关文法, 如果能够构造一张 LR 分析表, 使得它的每一个入口均是唯一的（Sj,rj,acc,空白），则称该上下文无关是LR 文法．</li></ul><p><strong>活前缀</strong></p><ul><li>规范句型的前缀，若不含句柄以后的任何符号，则称它为该规范句型的活前缀。</li></ul><h2 id="7-2-LR（0）分析"><a href="#7-2-LR（0）分析" class="headerlink" title="7.2 LR（0）分析"></a>7.2 LR（0）分析</h2><p> <strong>LR(0)文法</strong></p><pre><code>能力最弱，理论上最重要</code></pre><ul><li>存在FA 识别活前缀</li><li>识别活前缀的DFA如何构造（LR(0)项目集规范族的构造）</li><li>LR(0)分析表的构造</li></ul><p><strong>活前缀</strong></p><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614145819899.png" alt="image-20200614145819899" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614145819899.png" class="" title="This is image_e"><p><strong>LR分析需要构造识别活前缀的有穷自动机</strong></p><p>​        我们可以把文法的终结符和非终结符都看成有穷自动机的输入符号，每次把一个符号进栈看成已识别过了该符号，同时状态进行转换，当识别到可归前缀时，相当于在栈中形成句柄，认为达到了识别句柄的终态。</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0%5Cimage-20200614150627057.png" alt="f"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614150627057.png" class="" title="This is image_f"><h3 id="构造识别文法活前缀DFA的三种方法"><a href="#构造识别文法活前缀DFA的三种方法" class="headerlink" title="构造识别文法活前缀DFA的三种方法"></a>构造识别文法活前缀DFA的三种方法</h3><ol><li>根据形式定义求出活前缀的正规表达式，然后由此正规表达式构造NFA再确定化为DFA</li><li>求出文法的所有项目，按一定规则构造识别活前缀的NFA再确定化为DFA</li><li><strong>使用闭包函数（CLOSURE）和转向函数(GOTO(I,X))构造文法G’的LR(0)的项目集规范族，再由转换函数建立状态之间的连接关系得到识别活前缀的DFA</strong></li></ol><h3 id="构造LR（0）项目集规范族"><a href="#构造LR（0）项目集规范族" class="headerlink" title="构造LR（0）项目集规范族"></a>构造LR（0）项目集规范族</h3><p>LR(0)项目集规范族(构成识别一个文法的活前缀的DFA的状态的全体) 。 </p><p>LR（0）项目或配置（ <em>item</em> or <em>configuration）</em>.</p><p>—在右端某一位置有圆点的G的产生式</p><p>   A → xyz   A → .xyz </p><p>​                    A → x.yz</p><p>​                    A → xy.z</p><p>​                    A → xyz.</p><h3 id="活前缀和句柄的关系"><a href="#活前缀和句柄的关系" class="headerlink" title="活前缀和句柄的关系"></a>活前缀和句柄的关系</h3><ol><li>活前缀已含有句柄的全部符号，表明产生式A→β的 右部β已出现在栈顶</li><li>活前缀只含句柄的一部分符号表明A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li><li>活前缀不含有句柄的任何符号，此时期望A→β的右部所推出的符号串</li></ol><h3 id="活前缀-与句柄-与-LR-0-项目"><a href="#活前缀-与句柄-与-LR-0-项目" class="headerlink" title="活前缀,与句柄 ,与 LR(0)项目"></a>活前缀,与句柄 ,与 LR(0)项目</h3><p>​        为刻划这种分析过程中的文法G的每一个产生式的右部符号已有多大一部分被识别（出现在栈顶）的情况，分别用标有圆点的产生式来指示位置。</p><ul><li>A→β．刻划产生式A→β的 右部β已出现在栈顶</li><li>A→β1．β2 刻划A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li><li>A→．β 刻划没有句柄的任何符号在栈顶，此时期望A→β的右部所推出的符号串</li><li>对于A→ε的LR(0)项目只有A→．</li></ul><p><strong>LR（0）项目</strong></p><p>根据圆点所在的位置和圆点后是终结符还是非终结符或为空把项目分为以下几种：</p><ul><li>移进项目，形如 A →a • ab  a是终结符, a ,b ∈V* 以下同</li><li>待约项目，形如 A →a • Bb</li><li>归约项目，形如 A →a • </li><li>接受项目，形如 S’ →S • </li></ul><p>A→ε的LR(0)项目只有A→ •  是归约项目</p><p><strong>例子：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">例：文法G:<br>（<span class="hljs-number">0</span>）S`→E     <span class="hljs-comment">(1)</span> E→aA     <span class="hljs-comment">(2)</span> E→bB<br> <span class="hljs-comment">(3)</span> A→cA    <span class="hljs-comment">(4)</span> A→d      <span class="hljs-comment">(5)</span> B→cB<br> <span class="hljs-comment">(7)</span> B→d <br></code></pre></td></tr></table></figure><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153148449.png" alt="image-20200614153148449" style="zoom:50%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153148449.png" class="" title="This is image_g"><h3 id="LR（0）分析表的构造"><a href="#LR（0）分析表的构造" class="headerlink" title="LR（0）分析表的构造"></a>LR（0）分析表的构造</h3><p>如果每个入口不含多重定义，则称它为文法G的一张LR(0)表。具有LR(0)表的文法G称为一个LR（0）文法。</p><p>LR(0)文法是无二义的。</p><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153440192.png" alt="image-20200614153440192" style="zoom:90%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153440192.png" class="" title="This is image_h"><p>若含有移进/归约冲突，则文法不是LR(0)的</p><h2 id="7-3-SLR（1）分析"><a href="#7-3-SLR（1）分析" class="headerlink" title="7.3 SLR（1）分析"></a>7.3 SLR（1）分析</h2><p>若 LR(0) 项目集规范族中有项目集IK含 移进/归约、 归约/归约冲突：</p><p>IK   :{ …A→ α .bβ , P ® α . ,   Q ® α .  , …}</p><p>存在“移进-归约”和“归约-归约”冲突。</p><p>解决冲突的方法是分析含P和Q的句型即考察FOLLOW(P)和FOLLOW(Q)</p><p><strong>则解决冲突的SLR(1)技术：</strong></p><p>当状态K面临当前输入符号a时：</p><ul><li>若a=b，则移进</li><li>对a ∈ FOLLOW (P) 则  action [ K,a ] =用 P → α  归约 </li><li>对a ∈ FOLLOW (Q) 则  action [ K,a ] =用 Q → α 归约</li><li>能用SLR(1)技术解决冲突的文法称为SLR(1)文法。</li></ul><p><strong>SLR(1)文法是无二义的。</strong></p><p>数字1的意思是，在分析过程中顶多只要向前看一个符号。</p><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614154824752.png" alt="image-20200614154824752" style="zoom:50%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614154824752.png" class="" title="This is image_i">]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（6）自底向上的优先分析法</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="6-1-自底向上语法分析概述"><a href="#6-1-自底向上语法分析概述" class="headerlink" title="6.1 自底向上语法分析概述"></a>6.1 自底向上语法分析概述</h2><ul><li>自底向上语法分析试图将一个字符串归约至开始符号。</li><li>自下而上语法分析比自顶向下语法分析更有效率，对语法的限制更少</li><li>“移进-归约”：从输入字符串开始，逐步进行归约直到归约到文法的开始符号。</li></ul><img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613225725172.png" alt="image-20200613225725172" style="zoom:50%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225725172.png" class="" title="This is image_a"><ul><li>归约过程恰好是最右推导（规范推导）的逆过程：</li></ul><img src="编译原理（6）自底向上的优先分析法\image-20200613225824198.png" alt="image-20200613225824198" style="zoom:60%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225824198.png" class="" title="This is image_b"><ul><li><p>规范归约定义：</p><p>假定α是文法G的一个句子，我们称序列αn, αn-1,… α0是α的一个规范归约。如果此序列满足：</p><p>​      1、 αn= α</p><p>​      2、 α0为开始符号。</p><pre><code>3、对任何 i, 0&lt;i&lt;=n, αi-1是从αi经把句柄替换为相应产生式的左部符号而得到的。</code></pre></li><li><p>规范归约也称最左归约，最右推导称为规范推导。规范推导得到的句型成为规范句型。</p></li><li><p>如果文法G无二义，则规范推导的逆过程一定是规范归约。</p></li></ul><h3 id="“移进—归约”法的栈实现"><a href="#“移进—归约”法的栈实现" class="headerlink" title="“移进—归约”法的栈实现"></a>“移进—归约”法的栈实现</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">自顶向下：初始：分析栈：#S    输入串:a1a2…an#<br>        结束：      #            #（成功）<br>   分析过程：用产生式的右部替换左部。<br>   <br>自底向上：初始：分析栈：#     输入串:a1a2…an#<br>        结束：      #S           #（成功）<br>   分析过程：自左至右把输入符号串W的符号一一移进栈里，一旦发现栈顶的一部分符号形成一个可归约串，就把栈中这个子串用相应的归约符号替换。<br><br>四类操作：移进，归约，接受，出错处理。<br>缺点<br></code></pre></td></tr></table></figure><p>例：</p><p>文法G[E]：<br> E → T + E | T</p><p>T → int * T | int | (E)</p><img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613231423602.png" alt="image-20200613231423602" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613231423602.png" class="" title="This is image_c"><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs excel">|<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> + <span class="hljs-built_in">int</span>移进<br><span class="hljs-built_in">int</span> | * <span class="hljs-built_in">int</span> + <span class="hljs-built_in">int</span>    移进<br><span class="hljs-built_in">int</span>  * | <span class="hljs-built_in">int</span> + <span class="hljs-built_in">int</span>    移进<br><span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> | + <span class="hljs-built_in">int</span>       规约 <span class="hljs-built_in">T</span>→<span class="hljs-built_in">int</span><br><span class="hljs-built_in">int</span> * <span class="hljs-built_in">T</span> | + <span class="hljs-built_in">int</span>规约 <span class="hljs-built_in">T</span>→<span class="hljs-built_in">int</span> * <span class="hljs-built_in">T</span><br><span class="hljs-built_in">T</span> | + <span class="hljs-built_in">int</span>移进<br><span class="hljs-built_in">T</span> + | <span class="hljs-built_in">int</span>移进<br><span class="hljs-built_in">T</span> + <span class="hljs-built_in">int</span> | 规约<span class="hljs-built_in">T</span> → <span class="hljs-built_in">int</span><br><span class="hljs-built_in">T</span> + <span class="hljs-built_in">T</span> |规约E → <span class="hljs-built_in">T</span><br><span class="hljs-built_in">T</span> + E |规约E → <span class="hljs-built_in">T</span> + E<br>E |<br></code></pre></td></tr></table></figure><h2 id="6-2-自底向上的优先分析算法"><a href="#6-2-自底向上的优先分析算法" class="headerlink" title="6.2 自底向上的优先分析算法"></a>6.2 自底向上的优先分析算法</h2><h3 id="6-2-1-简单优先分析法"><a href="#6-2-1-简单优先分析法" class="headerlink" title="6.2.1 简单优先分析法"></a>6.2.1 简单优先分析法</h3><ul><li>按照文法符号（包括终结符和非终结符）的优先关系确定句柄。</li><li>例：</li></ul><img src="编译原理（6）自底向上的优先分析法\image-20200613235831008.png" alt="image-20200613235831008" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613235831008.png" class="" title="This is image_d"><h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>•优先关系</p><p>​    –X=Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XY…</p><p>​    –X&lt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XB…， </p><p>​                     且 B=+&gt; Y…</p><p>​    –X&gt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…BD…， </p><p>​                     且B =+&gt; …X,D =*&gt; Y…</p><p>•#的优先级&lt;所有符号，所有符号的优先级&gt;#，这里仅对与#相邻的文法符号而言。</p><h4 id="简单优先文法的定义"><a href="#简单优先文法的定义" class="headerlink" title="简单优先文法的定义"></a>简单优先文法的定义</h4><p>满足以下条件的文法是简单优先文法：</p><p>（1）在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。（简单优先关系矩阵不含多重入口）</p><p>（2）在文法中任意两个产生式没有相同的右部。（例如：F–&gt;a ; B–&gt;a）</p><h4 id="简单优先分析法的算法步骤"><a href="#简单优先分析法的算法步骤" class="headerlink" title="简单优先分析法的算法步骤"></a>简单优先分析法的算法步骤</h4><ul><li>将输入符号串a1a2…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性&gt;下一个待输入符号aj为止。</li><li>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;ak为止。</li><li>由句柄ak…ai在文法的产生式中查找右部为ak…ai的产生式，若找到则用相应左部代替句柄，若找不到则为出错。</li><li>重复1，2，3步，直到栈中只剩开始符。</li></ul><h3 id="6-2-2-算符优先分析法"><a href="#6-2-2-算符优先分析法" class="headerlink" title="6.2.2 算符优先分析法"></a>6.2.2 算符优先分析法</h3><ul><li><p>某些文法具有“算符”特性</p><p>​        –表达式运算符（优先级、结合性）</p><p>​        –人为地规定其算符的优先顺序，即给出优先级别和同一级别的结合性</p></li><li><p>只考虑算符之间的优先关系</p></li></ul><p><img src="F:%5Cblog%5Csource_posts%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602175422247.png" alt="image-20200602175422247"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602175422247.png" class="" title="This is image_e"><h4 id="如何确定算符优先关系"><a href="#如何确定算符优先关系" class="headerlink" title="如何确定算符优先关系"></a>如何确定算符优先关系</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">（<span class="hljs-number">1</span>）i的优先级最高<br>（<span class="hljs-number">1</span>）↑优先级次于i，右结合<br>（<span class="hljs-number">2</span>）*和/优先级次之，左结合<br>（<span class="hljs-number">3</span>）+和-优先级最低，左结合<br>（<span class="hljs-number">4</span>）括号‘(’,‘)’的优先级大于括号外的运算符，小于括号内的运算符，内括号的优先性大于外括号<br>（<span class="hljs-number">5</span>）<span class="hljs-meta">#的优先性低于与其相邻的算符</span><br></code></pre></td></tr></table></figure><h4 id="算符文法的定义"><a href="#算符文法的定义" class="headerlink" title="算符文法的定义"></a>算符文法的定义</h4><ul><li>定义  如果不含空产生式的上下文无关文法 G 中没有形如 U→…VW…的产生式，其中V,W∈VN则称G 为算符文法（OG）。</li><li>性质1：在算符文法中任何句型都不包含两个相邻的非终结符.(数学归纳法)</li><li>性质2：如 Vx 或 xV 出现在算符文法的句型 a 中，其中V∈VN,x∈VT, 则 a 中任何含 x 的短语必含有V.（反证法）（&lt;+&gt;归约，归约时把E带上&lt;E+E&gt;）</li></ul><h4 id="算符优先关系的定义"><a href="#算符优先关系的定义" class="headerlink" title="算符优先关系的定义"></a>算符优先关系的定义</h4><p>在OG中 定义 （算符优先关系）</p><ul><li><p>x = y    G中有形如.U→…xy…或U –&gt; …xVy…的产生式。    </p></li><li><p>x &lt; y     G中有形如.U →…xW…的产生式,而       W =+&gt; y….或W =+&gt; Vy…</p></li><li><p>x &gt; y     G中有形如.U → …Wy…的产生式,而        W =+&gt; …x或W =+&gt; … xV</p></li></ul><ul><li><p>规定 若 S =+&gt; x… 或  S =+&gt; Vx…  则  # &lt; x</p><p>​             S =+&gt; …x  或 S =+&gt; …xV  则  x &gt; #</p></li></ul><h4 id="算符优先文法的定义"><a href="#算符优先文法的定义" class="headerlink" title="算符优先文法的定义"></a>算符优先文法的定义</h4><ul><li><p>在 OG文法 G 中，若任意两个终结符间至多有一种算符优先关系存在，则称G 为算符优先文法(OPG)。</p><p><strong>–结论 算符优先文法是无二义的。</strong></p></li></ul><h4 id="算符优先关系表的构造"><a href="#算符优先关系表的构造" class="headerlink" title="算符优先关系表的构造"></a>算符优先关系表的构造</h4><ul><li>由定义直接构造</li><li>由关系图法构造算符优先关系表</li></ul><p><strong>FIRSTVT</strong> 和 <strong>LASTVT</strong></p><img src="编译原理（6）自底向上的优先分析法\image-20200614112149299.png" alt="image-20200614112149299" style="zoom:40%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614112149299.png" class="" title="This is image_f"><p><strong>如何计算算符优先关系</strong></p><p>（1） ‘=‘关系</p><p>​        –直接看产生式的右部，若出现了  A →…ab…或A →…aBb,则a=b</p><p>（2）’&lt;‘关系</p><p>​        –求出每个非终结符B的FIRSTVT(B)</p><p>​        –若A→…aB…,则”b∈FIRSTVT(B),a&lt;b</p><p>（3）’&gt;’关系</p><p>​        –求出每个非终结符B的LASTVT(B)</p><p>​        –若A→…Bb…,则”a∈LASTVT(B),a&gt;b</p><p>例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs r">文法G[E]：(<span class="hljs-number">0</span>) E’→<span class="hljs-comment">#E#                         FIRSTVT(E’)=&#123;#&#125;</span><br> (<span class="hljs-number">1</span>) E→E+<span class="hljs-built_in">T</span>FIRSTVT(E)=&#123;+,*,↑,(,i&#125;<br> (<span class="hljs-number">2</span>) E→<span class="hljs-built_in">T</span>FIRSTVT(<span class="hljs-built_in">T</span>)=&#123;*,↑,(,i&#125;<br> (<span class="hljs-number">3</span>) <span class="hljs-built_in">T</span>→<span class="hljs-built_in">T</span>*<span class="hljs-built_in">F</span>FIRSTVT(<span class="hljs-built_in">F</span>)=&#123;↑,(,i&#125;<br> (<span class="hljs-number">4</span>) <span class="hljs-built_in">T</span>→<span class="hljs-built_in">F</span>FIRSTVT(P)=&#123;(,i&#125;<br> (<span class="hljs-number">5</span>) <span class="hljs-built_in">F</span>→P↑<span class="hljs-built_in">F</span>|PLASTVT(E’)=&#123;<span class="hljs-comment">#&#125;</span><br> (<span class="hljs-number">6</span>) P→(E)LASTVT(E)=&#123;+,*,↑,),i&#125;   LASTVT(<span class="hljs-built_in">F</span>)=&#123;↑,),i&#125;<br> (<span class="hljs-number">7</span>) P→iLASTVT(<span class="hljs-built_in">T</span>)=&#123;*,↑,),i&#125;     LASTVT(P)=&#123;),i&#125;<br><br>1)‘=’关系<br>由产生式(<span class="hljs-number">0</span>)和(<span class="hljs-number">6</span>),得<span class="hljs-comment">#=#，（=）</span><br>2）‘&lt;’关系<br>    找形如：A→…aB…的产生式<br>    <span class="hljs-comment">#E：则#&lt;FIRSTVT(E)</span><br>    +<span class="hljs-built_in">T</span>: 则+&lt;FIRSTVT(<span class="hljs-built_in">T</span>)  <br>    *<span class="hljs-built_in">F</span>: 则*&lt;FIRSTVT(<span class="hljs-built_in">F</span>)<br>    ↑<span class="hljs-built_in">F</span>: 则↑&lt;FIRSTVT(<span class="hljs-built_in">F</span>)<br>    (E: 则(&lt;FIRSTVT(E)<br>3)‘&gt;’关系<br>    找形如：A→…Bb…的产生式<br>    E<span class="hljs-comment"># ,则 LASTVT(E)&gt;#</span><br>    E+ ,则 LASTVT(E)&gt;+ <br>    <span class="hljs-built_in">T</span>* ,则 LASTVT(<span class="hljs-built_in">T</span>)&gt;* <br>    P↑ ,则 LASTVT(P)&gt;↑ <br>    E) ,则 LASTVT(E)&gt;)<br></code></pre></td></tr></table></figure><img src="编译原理（6）自底向上的优先分析法\image-20200614113542961.png" alt="image-20200614113542961" style="zoom:75%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614113542961.png" class="" title="This is image_g"><h4 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h4><ul><li>归约过程中，只考虑终结符之间的优先关系来确定句柄，而与非终结符无关。这样去掉了对非终结符的归约，所以用算符优先分析法的规约过程与规范归约是不同的，P110.</li><li>为解决在算符优先分析过程中如何寻找可归约串，引进<strong>最左素短语</strong>的概念</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">算符文法的任一句型有如下形式：<br><span class="hljs-comment">#N1a1N2a2......NnanNn+1#</span><br>若Niai......NjajNj+<span class="hljs-number">1</span>为句柄，则有ai<span class="hljs-number">-1</span>&lt;ai=ai+<span class="hljs-number">1</span>=...= aj<span class="hljs-number">-1</span> = aj&gt; ai+<span class="hljs-number">1</span><br><br>对于算符优先文法，如果aNb(或ab)出现在句型r中<br>    若<span class="hljs-keyword">a</span>&lt;b，则在r中必含有b而不含<span class="hljs-keyword">a</span>的短语存在<br>    若<span class="hljs-keyword">a</span>&gt;b，则在r中必含有<span class="hljs-keyword">a</span>而不含b的短语存在<br>    若<span class="hljs-keyword">a</span>=b，则在r中含有<span class="hljs-keyword">a</span>的短语必含有b，反之亦然<br></code></pre></td></tr></table></figure><p>定义  </p><p>cfg G 的句型的素短语是一个短语，它<strong>至少包含一个终结符</strong>，且除自身外<strong>不再包含其他素短语</strong>。处于句型最左边的素短语为<strong>最左素短语</strong>。</p><p>例如：</p><img src="编译原理（6）自底向上的优先分析法\image-20200614114837340.png" alt="image-20200614114837340" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614114837340.png" class="" title="This is image_h"><h4 id="优先函数"><a href="#优先函数" class="headerlink" title="优先函数"></a>优先函数</h4><ul><li>优先函数比优先矩阵节省空间</li><li>优先函数:从终结符号映射到整数的函数。</li><li>若a&lt;b,则f(a)&lt;g(b)</li><li>若a=b,则f(a)=g(b)</li><li>若a&gt;b,则f(a)&gt;g(b)</li></ul><p>例如：</p><img src="编译原理（6）自底向上的优先分析法\image-20200614115252192.png" alt="image-20200614115252192" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614115252192.png" class="" title="This is image_i"><p>​    f( * )&lt;g( i ) =&gt; *&lt;i，但f( i )&gt;g( i ) =&gt; i&gt;i是不存在的，所以错误检查能力损失。</p><p>​    可通过检查栈顶和输入符号a来发现那些不可比较的情形。</p><h4 id="构造优先函数"><a href="#构造优先函数" class="headerlink" title="构造优先函数"></a>构造优先函数</h4><p>（如果有环路则没有优先函数）</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602185248232.png" alt="j"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602185248232.png" class="" title="This is image_j"><ol><li>设a是一个终结符或#，对每一个a建立两个符号fa和ga.</li><li>将所有fa和ga组成的集合分为若干组，办法是若a=b则fa和gb在同一组。</li><li>画图，结点是2建立的组。对任何a和b，若a&lt;b，则从gb所在的组画一箭弧到fa所在的组；若a&gt;b，则从fa 所在的组画一箭弧到gb所在的组.</li><li>若第3步构造的图中有环路，则没有优先函数。若没有环路，令f(a)是从fa 所在的组出发的沿箭弧前进的最长路径的长度。 g(a)是从ga 所在的组出发的沿箭弧前进的最长路径的长度。</li></ol><h4 id="算符优先分析法的局限性"><a href="#算符优先分析法的局限性" class="headerlink" title="算符优先分析法的局限性"></a>算符优先分析法的局限性</h4><p>很难避免把错误的句子得到正确的归约</p>]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（5）自顶向下语法分析方法</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>句型的分析——分析算法分类：</p><p><strong>自上而下分析法：</strong></p><p> 从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p><p><strong>自下而上分析法：</strong></p><p>从输入符号串开始，逐步进行归约（最右推导的逆过程），直至归约到文法的开始符号。</p><h2 id="5-1-自上而下语法分析的一般过程"><a href="#5-1-自上而下语法分析的一般过程" class="headerlink" title="5.1 自上而下语法分析的一般过程"></a>5.1 自上而下语法分析的一般过程</h2><p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">文法G：    S → cAd    A → ab |a                  <br>识别输入串  w=cad<br>试探：推导过程：S =&gt; cAd =&gt; cabd<br>回溯:试探推导过程：S =&gt; cAd =&gt; cad<br></code></pre></td></tr></table></figure><h3 id="一、自上而下语法分析的问题"><a href="#一、自上而下语法分析的问题" class="headerlink" title="一、自上而下语法分析的问题"></a>一、自上而下语法分析的问题</h3><h4 id="5-1-1-左递归问题"><a href="#5-1-1-左递归问题" class="headerlink" title="5.1.1 左递归问题"></a>5.1.1 左递归问题</h4><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tp">定义：一个文法是含有左递归的，如果存在非终结符<span class="hljs-keyword">P</span><br>                            <span class="hljs-keyword">P</span> =&gt; <span class="hljs-keyword">P</span>α <br>含有左递归的文法使上述的自上而下分析过程陷入无限循环。<br></code></pre></td></tr></table></figure><p>直接左递归 若 P –&gt; Pα | β     （α、β ∈V*且β不以P开头）</p><p>间接左递归 若 P =&gt; Pα           S –&gt; Aa     A–&gt;Sb      A–&gt;b</p><h4 id="5-1-2-消除左递归"><a href="#5-1-2-消除左递归" class="headerlink" title="5.1.2 消除左递归"></a>5.1.2 消除左递归</h4><p><strong>消除直接左递归：</strong></p><p>​        形如：P –&gt; Pα | β         （ α非ε， β不以P打头）</p><p>​        改写为：P –&gt; β P’         P’  –&gt;  α P’ | ε</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例： E --&gt; E+T|T<br><span class="hljs-code">    T --&gt; T*F|F</span><br><span class="hljs-code">    F --&gt; (E)|i</span><br><span class="hljs-code">G[E]: (1)E --&gt; TE&#x27;  (2)E&#x27; --&gt; +TE&#x27;|ε  </span><br><span class="hljs-code">      (2)T --&gt; FT&#x27;  (4)T&#x27; --&gt; *FT&#x27;|ε </span><br><span class="hljs-code">      (5)F --&gt; (E)|i</span><br></code></pre></td></tr></table></figure><p>一般情况：</p><p>A –&gt; Aα1 | Aα2| …| Aαm|β1|β2|…|βn</p><p>消除左递归后：</p><p>A  –&gt;  β1A’|β2A’|…|βnA’</p><p>A’ –&gt;  α1A’ | α2A’| …|αmA’|ε</p><p><strong>消除间接左递归</strong></p><p>间接左递归定义：给定文法G(S) :<br>            S→Qc∣c        Q→Rb∣b          R→Sa∣a</p><p>虽然不存在直接左递归，但S、Q、R 都是左递归的，例如有  S⇒Qc⇒Rbc⇒Sabc </p><p>要求文法：1. 无回路（A=&gt;A）   2. 无空产生式（不含以ε为右部的产生式）</p><p>消除左递归的算法：</p><ol><li>把文法G的所有非终结符按任一种顺序排列P1, P2, P3…. Pn;</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：S--&gt;Ac|c  A--&gt;Bb|b   B--&gt;Sa|a<br>（1）排序：B  A  S<br>（2）将B代入A： A--&gt;Sab|ab|b<br><span class="hljs-code">    将A代入S： S--&gt;Sabc|abc|bc|c</span><br><span class="hljs-code"> 消除S的直接左递归，得到文法：</span><br><span class="hljs-code">    S--&gt;abcS&#x27;|bcS&#x27;|cS&#x27;</span><br><span class="hljs-code">    S&#x27;--&gt;abcS&#x27;|ε</span><br><span class="hljs-code">    A--&gt;Sab|ab|b</span><br><span class="hljs-code">    B--&gt;Sa|a</span><br><span class="hljs-code">（3）化简，最终得到结果：</span><br><span class="hljs-code">S--&gt;abcS&#x27;|bcS&#x27;|cS&#x27;</span><br><span class="hljs-code">    S&#x27;--&gt;abcS&#x27;|ε</span><br><span class="hljs-code">    </span><br><span class="hljs-code">（1）排序：S  A  B</span><br><span class="hljs-code">（2）将S代入A： A--&gt;Bb|b</span><br><span class="hljs-code">将S、A代入B： B--&gt;Aca|ca|a</span><br><span class="hljs-code">            B--&gt;Bbca|bca|ca|a</span><br><span class="hljs-code">消除B的直接左递归，得到文法：</span><br><span class="hljs-code">S--&gt;Ac|c</span><br><span class="hljs-code">A--&gt;Bb|b</span><br><span class="hljs-code">B--&gt;bcaB&#x27;|caB&#x27;|aB&#x27;</span><br><span class="hljs-code">B&#x27;--&gt;bcaB&#x27;|ε</span><br></code></pre></td></tr></table></figure><h4 id="5-1-3-回溯问题"><a href="#5-1-3-回溯问题" class="headerlink" title="5.1.3 回溯问题"></a>5.1.3 回溯问题</h4><p>定义：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“<strong>回溯</strong>”。</p><h4 id="5-1-4-提取左公因子"><a href="#5-1-4-提取左公因子" class="headerlink" title="5.1.4 提取左公因子"></a>5.1.4 提取左公因子</h4><p>提取左公因子：A →αβ1|αβ2</p><p>变为： A →αA’         A’ →β1 |β2</p><p>若A →αβ1|αβ2 |…|αβn|r</p><p>变为：A →αA’          A’ →β1|β2|…|βn</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">例：S → iEtS|iEtSeS|a      E→b<br>提取左公因子： S -→ iEtSS’|a <br><span class="hljs-code">            S’-→ eS|ε</span><br><span class="hljs-code">            E -→ b</span><br></code></pre></td></tr></table></figure><h2 id="5-2-递归下降分析法"><a href="#5-2-递归下降分析法" class="headerlink" title="5.2 递归下降分析法"></a>5.2 递归下降分析法</h2><p>递归下降分析器：在消除了左递归和提取左公因子后，可以构造一个不带回溯的自上而下的分析程序。</p><p>这个程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">例：G[ E]:    <br>   (<span class="hljs-number">1</span>)   E → TE’    (<span class="hljs-number">2</span>)  E’ → +TE’| ε<br>   (<span class="hljs-number">3</span>)   T → FT’    (<span class="hljs-number">4</span>)  T’ → *FT’ |ε<br>   (<span class="hljs-number">5</span>)   F → (E)|i<br><br>Procedure E;<br>     Begin<br>         T;E’<br>     End;<br>Procedure T;<br>     Begin<br>         F;T’<br>     End;<br>Procedure F;<br>   IF sym=‘i’ then advance<br>   <span class="hljs-keyword">else</span><br>       IF sym=‘(’ then<br>           Begin<br>              advance;<br>              E<br>       IF sym=‘)’ then advance<br>              <span class="hljs-keyword">else</span>  ERROR<br>           End;<br>    <span class="hljs-keyword">else</span> ERROR;<br>Procedure E’;<br>   IF sym=‘+’ then<br>     Begin<br>         advance;<br>         T;E’<br>     End;<br>Procedure T’;<br>   IF sym=‘*’ then<br>     Begin<br>         advance;<br>         F;T’<br>     End;<br></code></pre></td></tr></table></figure><h2 id="5-3-非递归的预测分析方法（LL-1-）"><a href="#5-3-非递归的预测分析方法（LL-1-）" class="headerlink" title="5.3 非递归的预测分析方法（LL(1)）"></a>5.3 非递归的预测分析方法（LL(1)）</h2><h3 id="一、总控程序"><a href="#一、总控程序" class="headerlink" title="一、总控程序"></a>一、总控程序</h3><img src="编译原理（5）自顶向下语法分析方法\image-20200601224211773.png" alt="image-20200601224211773" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/image-20200601224211773.png" class="" title="This is image_a"><p>分析算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">BEGIN<br>   首先把‘#’，然后把文法开始符号推入栈；把第一个输入符号读进a;    FLAG：=TRUE；<br>WHILE FLAG  DO      <br>BEGIN<br>   把栈顶符号上托出去并放在Ｘ中；<br>   IF X ∈ Vt  <br>   THEN  <br>       IF X=a  <br>       THEN<br>       把下一个输入符号读进a<br>　        ELSE ERROR      <br>   ELSE  IF X=‘#’ <br>   THEN<br>            IF X=a  <br>        THEN  <br>        FLAG:=FALSE<br>            ELSE ERROR<br>   ELSE IF M[X,a]=&#123;X-&gt;X1X2..XK&#125;<br>          THEN   <br>              把XK，X K<span class="hljs-number">-1</span>,..,X1一一推进栈 <br>          ELSE　ERROR<br>   END OF WHILE;<br>STOP<span class="hljs-comment">/*分析成功，过程完毕*／</span><br><span class="hljs-comment">END</span><br></code></pre></td></tr></table></figure><h3 id="二、预测分析表M的构造"><a href="#二、预测分析表M的构造" class="headerlink" title="二、预测分析表M的构造"></a>二、预测分析表M的构造</h3><p>​                                                            ——LL（1）文法及其分析程序</p><p>FIRST集和FOLLOW集 </p><p>设G=(VT, VN, S, P)是上下文无关文法</p><p>FIRST（α）= {a|α =&gt; aβ, a∈VT, α, β∈V*}</p><p>FOLLOW（A）= {a|S =&gt;…Aa…, a ∈VT}</p><h4 id="5-3-1-first集"><a href="#5-3-1-first集" class="headerlink" title="5.3.1 first集"></a>5.3.1 first集</h4><p>（1）为什么要引入first集的概念？</p><ul><li>因为有公共左因子的问题，公共左公因子是指在文法的产生式集合中，某个非终结符的多个候选式具有相同的前缀。</li><li>一般来说，公共左公因子的产生式为 </li></ul><p>$$<br>A→αβ1│αβ2<br>$$</p><ul><li><p>如果有公共左因子的问题，那么只能采取试探的方法来分析每一个候选式，分析的过程很可能产生回溯，回溯分析法是一种不确定的方法。</p></li><li><p>若所有候选式都没有公共左因子就可以选择惟一匹配的候选式，不会产生(公共左公因子引起的)回溯。</p></li><li><p>为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望 </p><p>​        要么只有一个候选式可用</p><p>​        要么没有候选式可用</p><p>因此引入以下FIRST集合的概念:</p></li><li><p>对α∈(VT⋃VN)∗,有<br>$$<br>FIRST(α)＝ { {a|α⟹a⋅⋅⋅,a∈VT} }<br>$$<br>特别地，若α⟹ε,  则ε∈FIRST(α)</p></li></ul><p>（2）推导算法</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tp">对每一文法<span class="hljs-keyword">X</span>∈V，计算first（<span class="hljs-keyword">X</span>）：<br>①<span class="hljs-keyword">X</span>∈Vt，则first（<span class="hljs-keyword">X</span>）=&#123;<span class="hljs-keyword">X</span>&#125; <br>    ②<span class="hljs-keyword">X</span>∈Vn（非终结符），且有<span class="hljs-keyword">X</span>-&gt;a , 则a∈first（<span class="hljs-keyword">X</span>）<br>    ③<span class="hljs-keyword">X</span>∈Vn（非终结符），且有<span class="hljs-keyword">X</span>-&gt;# , 若#∈first（<span class="hljs-keyword">X</span>）<br>    ④若有<span class="hljs-keyword">X</span>，<span class="hljs-keyword">Y</span><span class="hljs-number">1</span>,<span class="hljs-keyword">Y</span><span class="hljs-number">2</span>,<span class="hljs-keyword">Y</span><span class="hljs-number">3</span>...∈Vn，且有产生式<span class="hljs-keyword">X</span>-&gt;<span class="hljs-keyword">Y</span><span class="hljs-number">1</span>,<span class="hljs-keyword">Y</span><span class="hljs-number">2</span>,<span class="hljs-keyword">Y</span><span class="hljs-number">3</span>=&gt;#,则first（<span class="hljs-keyword">Y</span><span class="hljs-number">1</span>）-&#123;#&#125;，first（<span class="hljs-keyword">Y</span><span class="hljs-number">2</span>）-&#123;#&#125;...first（Yi）都属于first（<span class="hljs-keyword">X</span>）找中<br>重复②-④<br>⑤当所有Yi=&gt;#   则first（<span class="hljs-keyword">X</span>）= first（<span class="hljs-keyword">Y</span><span class="hljs-number">1</span>）-&#123;#&#125; ∪ first（<span class="hljs-keyword">Y</span><span class="hljs-number">2</span>）-&#123;#&#125;..... ∪ first（Yi）<br>当有<span class="hljs-keyword">X</span>-&gt;# ，才能说#∈first（<span class="hljs-keyword">X</span>）<br></code></pre></td></tr></table></figure><h4 id="5-3-2-follow集"><a href="#5-3-2-follow集" class="headerlink" title="5.3.2 follow集"></a>5.3.2 follow集</h4><p>（1）为什么要引入follow集的概念？</p><p>​        当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了一个文法符号的<strong>后跟符号</strong>集合。 </p><p>（2）推导算法（PS：求follow集，都是从开始符号S开始推导）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">计算follow集:<br>①设S为起始，&#123;<span class="hljs-comment">#&#125;加入follow（S）</span><br>    ②要求follow（B），若A-&gt;aBb是一个产生式，则把first（b）的非空元素加入follow（B）中<br>③若b-&gt;<span class="hljs-comment">#,则把follow（A）加入follow（B）中</span><br>解释：因为若D-&gt;xAy,A-&gt;aBb, 则 D-&gt;xaBby,且b=<span class="hljs-comment">#，则first（y）或者说是follow(A)∈follow(B)</span><br>就是所求符号的右边如果等于<span class="hljs-comment"># 则不停找上一级</span><br></code></pre></td></tr></table></figure><h4 id="5-3-3-select集"><a href="#5-3-3-select集" class="headerlink" title="5.3.3 select集"></a>5.3.3 select集</h4><p>select(X-&gt;Y)，先求first（Y），如果first（Y）存在#∈first（Y）的情况，则再求follow（X），最后求两者的并集即可</p><p>例：</p><table><thead><tr><th align="left"></th><th>是否</th><th>Frist集</th><th>Follow集</th></tr></thead><tbody><tr><td align="left">S</td><td>否</td><td>{ a, ^, ( }</td><td>{ #,   ’,’ ,  )  }</td></tr><tr><td align="left">T</td><td>否</td><td>{ a, ^, ( }</td><td>{ ) }</td></tr><tr><td align="left">N</td><td>是</td><td>{ ‘,’  ,  # }</td><td>{ ) }</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(S-&gt;a)</span></span> =first（a）= &#123;a&#125;<br><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(S-&gt;^)</span></span> =first（^）=&#123;^&#125;<br><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(S-&gt;(T)</span></span>) =first（ （T）  ）=&#123; ( &#125;<br><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(T-&gt;SN)</span></span> = first(S)=&#123;<span class="hljs-selector-tag">a</span>,^,(&#125;<br><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(N-&gt;,SN)</span></span>=first( , ) =&#123; , &#125;<br><span class="hljs-function"><span class="hljs-title">Select</span><span class="hljs-params">(N-&gt;#)</span></span> =follow(N) = &#123; ) &#125;<br></code></pre></td></tr></table></figure><h4 id="5-3-4-预测分析表构造算法"><a href="#5-3-4-预测分析表构造算法" class="headerlink" title="5.3.4 预测分析表构造算法"></a>5.3.4 预测分析表构造算法</h4><p>1.对文法G的每个产生式Ａ→a执行第二步和第三步；</p><p>2.对每个终结符a∈FIRST(α)，把Ａ→α加至M[A,a]中，</p><p>3.若ε∈FIRST(α)，则对任何b∈FOLLOW(A)， 把Ａ→α加至M[A,b]中，</p><p>4.把所有无定义的M[A,a]标上“出错标志”。</p><h3 id="三、LL（1）文法"><a href="#三、LL（1）文法" class="headerlink" title="三、LL（1）文法"></a>三、LL（1）文法</h3><p>一个文法G，若它的分析表M不含多重定义入口，则称为LL（1）文法。</p><p>例：</p><p>文法S→iEtS|iEtSeS|a     E→b</p><p>不是LL（1）文法。</p><p>一个LL（1）文法是无二义的。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">一个文法G是LL（<span class="hljs-number">1</span>）的，当且仅当对于G的每一个非终结符Ａ的任何两个不同产生式Ａ→α|<span class="hljs-type">β，下面的条件成立：</span><br><span class="hljs-type">1</span>.FIRST（α）∩ FIRST(β) = φ<br>也就是，α和β推导不出以同一个终结符a为首的符号串；它们不应该都能推出空字ε．<br><span class="hljs-number">2.</span>假若β=&gt;ε，那么FIRST（α) ∩ FOLLOW（A）＝ φ<br>也就是，若β=&gt;ε.则α所能推出的串的首符号不应在FOLLOW(A）中．<br>  结论：<br>  LL(<span class="hljs-number">1</span>)文法是无二义的．<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（4）词法分析</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>词法分析程序亦称为扫描器。</p><p>扫描器的任务是识别基本的语法单位——单词；</p><p>扫描器的输出是语法分析程序的输入。</p><p><strong>词法分析程序的设计和实现</strong>：</p><p>首先需要描述和刻画语言中的原子单位——单词，其次需要识别单词和执行某些相关的动作。描述程序设计语言的词法的机制是3型文法和正则表达式，识别机制是有穷状态自动机。</p><h2 id="4-1-词法分析程序"><a href="#4-1-词法分析程序" class="headerlink" title="4.1 词法分析程序"></a>4.1 词法分析程序</h2><p><strong>词法分析（lexical analysis）</strong></p><p>–逐个读入源程序字符并按照构词规则切分成一系列单词。   </p><p>–单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。</p><p>–词法分析是编译过程中的一个阶段，在语法分析前进行 。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" alt="a"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" class="" title="This is image_a"><ul><li><p>主要任务：</p><p>–读源程序，产生单词符号，并转换为token表示</p></li><li><p>其他任务：</p><p>–滤掉空格，删除注释、换行符</p><p>–对行列计数</p><p>–发现并定位词法错误，并尽量改正</p><p>–建立符号表、常数表等表格，……</p></li></ul><h3 id="4-1-1-词法分析器的输入缓冲区"><a href="#4-1-1-词法分析器的输入缓冲区" class="headerlink" title="4.1.1 词法分析器的输入缓冲区"></a>4.1.1 词法分析器的输入缓冲区</h3><h3 id="4-1-2-词法分析器的输出"><a href="#4-1-2-词法分析器的输出" class="headerlink" title="4.1.2 词法分析器的输出"></a>4.1.2 词法分析器的输出</h3><ul><li><p>单词符号一般可分为下列五种：</p><p>–基本字，关键字</p><p>–标识符</p><p>–常数（量）</p><p>–运算符</p><p>–界符</p></li><li><p>输出的二元式（token）表示：（单词种别，单词自身的值）</p></li><li><p>Token的种类：</p><p>​    1、有些单词，只需要值，如基本字；</p><p>​    2、有些单词，还需要其他信息，如标示符。</p></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">例： A:=B<span class="hljs-number">+2</span>                                                            <br><span class="hljs-comment">(Id的整数码,指向A的符号表的入口指针）   ($28, Aaddr)</span>       <br><span class="hljs-comment">(运算符的整数码,’:=’)</span>                                                     <br><span class="hljs-comment">(Id的整数码,指向B的符号表的入口指针)</span>        <br><span class="hljs-comment">(运算符的整数码,’+’)</span>                                            <br><span class="hljs-comment">(常数的整数码, 2)</span>  <br></code></pre></td></tr></table></figure><h3 id="4-1-3-以状态转换图为例设计词法分析器"><a href="#4-1-3-以状态转换图为例设计词法分析器" class="headerlink" title="4.1.3 以状态转换图为例设计词法分析器"></a>4.1.3 以状态转换图为例设计词法分析器</h3><img src="编译原理（4）词法分析/image-20200613110111799.png" alt="image-20200613110111799" style="zoom:60%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613110111799.png" class="" title="This is image_b"><h2 id="4-2-正规表达式与正规集（正规语言）"><a href="#4-2-正规表达式与正规集（正规语言）" class="headerlink" title="4.2 正规表达式与正规集（正规语言）"></a>4.2 正规表达式与正规集（正规语言）</h2><ul><li><p>正规表达式（regular expression）是描述单词符号的一种方便工具，也是定义正规集的工具。</p></li><li><p>定义（正规式和它所表示的正规集）：</p><p>–设字母表为Σ，辅助字母表Σ`={Ф，ε，|，·，*，(，)}。</p><p>–1) ε和Ф都是Σ上的正规式，它们所表示的正规集分别为{ε}和{ }；</p><p>–2) 任何a∈Σ，a是Σ上的一个正规式，它所表示的正规集为{a}；</p><p>–3) 假定e1和e2都是Σ上的正规式，它们所表示的正规集分别为L(e1)和L(e2)，那么，(e1), e1| e2, e1·e2, e1* 也都是正规式，它们所表示的正规集分别为L(e1), L(e1)∪L(e2), L(e1)L(e2)和(L(e1))*。</p><p>–4) 仅由有限次使用上述三步骤而定义的表达式才是Σ上的正规式，仅由这些正规式所表示的字集才是Σ上的正规集。</p><img src="编译原理（4）词法分析/image-20200613112425500.png" alt="image-20200613112425500" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613112425500.png" class="" title="This is image_c"></li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gcode">例<span class="hljs-number">1</span>  令Σ=&#123;a，b&#125;， Σ上的正规式和相应的正规集的例子有：<br>    正规式 正规集<br>    a   &#123;a&#125;<br>    a|b   &#123;a,b&#125;<br>    ab   &#123;ab&#125;<br>    <span class="hljs-comment">(a|b)</span><span class="hljs-comment">(a|b)</span>   &#123;aa,ab,ba,bb&#125;<br>    a*    &#123;ε,a,aa, ……任意个a的串&#125;<br>    <span class="hljs-comment">(a|b)</span>*   &#123;ε,a,b,aa,ab ……所有由a和b组成的串&#125;<br><span class="hljs-comment">(a|b)</span>*<span class="hljs-comment">(aa|bb)</span><span class="hljs-comment">(a|b)</span>*    &#123;Σ*上所有含有两个相继的a或两个相继的b组成的串&#125;<br><br>例<span class="hljs-number">3</span> Σ=&#123;d，.，e，+，-&#125;,则Σ上的正规式 d*<span class="hljs-comment">(.dd*|ε)</span><span class="hljs-comment">(e(+|-|ε)</span>dd*|ε )<br>表示的是无符号数的集合。其中d为<span class="hljs-number">0</span>~<span class="hljs-number">9</span>的数字。<br></code></pre></td></tr></table></figure><ul><li>若两个正规式e1和e2所表示的正规集相同,则说e1和e2等价,写作e1=e2。</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">例如： e<span class="hljs-number">1</span>= <span class="hljs-comment">(a|b)</span>， e<span class="hljs-number">2</span> = b|a<br><br>又如： e<span class="hljs-number">1</span>= b<span class="hljs-comment">(ab)</span>* ,  e<span class="hljs-number">2</span> =<span class="hljs-comment">(ba)</span>*b<br>  e<span class="hljs-number">1</span>= <span class="hljs-comment">(a|b)</span>* ,  e<span class="hljs-number">2</span> =<span class="hljs-comment">(a*|b*)</span>*<br></code></pre></td></tr></table></figure><ul><li><p>设r,s,t为正规式，正规式服从的代数规律有：</p><p>–1、r|s=s|r                    “或”服从交换律</p><p>–2、r|(s|t)=(r|s)|t        “或”的可结合律</p><p>–3、(rs)t=r(st)                “连接”的可结合律</p><p>–4、r(s|t)=rs|rt      (s|t)r=sr|tr    分配律 </p><p>–5、εr=r, rε=r                 ε是“连接”的恒等元素 零一律</p><p>–6、 r|r=r    <strong>r* =ε|r+    r+=rr*</strong> </p></li><li><p>文法的定义</p><p>–G={VN,VT,P,S}</p><p>–VN：非终结符的非空有穷集</p><p>–VT：终结符的非空有穷集</p><p>–P： 产生式的非空有穷集</p><p>​         a→b  a∈( VN∪VT )* 且至少含一个非终结符， b∈( VN∪VT )*</p><p>–S：∈VN，称为开始符号</p></li><li><p>正规文法： G的任何产生式为A→aB或A→a，其中a∈VT ∪ ε ，A，B∈VN</p></li></ul><p><strong>对任意一个正规文法，存在一个定义同一个语言的正规式；反之亦然。</strong></p><p>Σ上的<strong>正规式=&gt;正规文法</strong></p><p>初始VT= Σ, S∈VN ，生成正规产生式(或定义式) :S→r （r为正规式）     </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-built_in">R1</span>) 对形如 A→r1r2的正规产生式： A→<span class="hljs-built_in">r1B</span>           <br> B→<span class="hljs-built_in">r2</span>               <br> B∈VN                   <br>(<span class="hljs-built_in">R2</span>)对形如A→r*<span class="hljs-built_in">r1</span>的正规产生式：   A→rB          <br> A→<span class="hljs-built_in">r1</span>          <br> B→rB          <br> B→<span class="hljs-built_in">r1</span>   B∈VN                                <br>(<span class="hljs-built_in">R3</span>)对形如A→<span class="hljs-built_in">r1</span>|<span class="hljs-built_in">r2</span>的正规产生式:  A→<span class="hljs-built_in">r1</span>        <br> A→<span class="hljs-built_in">r2</span>                   <br></code></pre></td></tr></table></figure><p>不断应用R做变换，直到每个产生式右端只含一个VN</p><p><strong>正规文法=&gt;正规式</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">正规文法                      正规式<br>A→xB, B→<span class="hljs-symbol">y</span>      转换成：   A=xy <br>A→xA|<span class="hljs-symbol">y</span>         转换成：       A=<span class="hljs-symbol">x</span>*<span class="hljs-symbol">y</span> <br>A→<span class="hljs-symbol">x</span>|<span class="hljs-symbol">y</span>          转换成：       A=<span class="hljs-symbol">x</span>|<span class="hljs-symbol">y</span> <br></code></pre></td></tr></table></figure><h2 id="4-3-有穷自动机"><a href="#4-3-有穷自动机" class="headerlink" title="4.3 有穷自动机"></a>4.3 有穷自动机</h2><h3 id="4-3-1-确定的有穷自动机DFA"><a href="#4-3-1-确定的有穷自动机DFA" class="headerlink" title="4.3.1 确定的有穷自动机DFA"></a>4.3.1 确定的有穷自动机DFA</h3><p><strong>DFA定义：</strong></p><p>一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中</p><p>​    1、K是一个有穷集，它的每个元素称为一个状态；</p><p>​    2、Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号字母表；</p><p>​    3、f是转换函数，是在K×Σ→K上的映射，即，如f（ki，a）=kj，（ki∈K，kj∈K）就意味着，当前状态为ki，输入符为a时，将转换为下一个状态kj，我们把kj称作ki的一个后继状态；</p><p>​    4、S∈K是唯一的一个初态；</p><p>​    5、Z 包含于 K是一个终态集，终态也称可接受状态或结束状态。</p><p><strong>DFA例：</strong></p><img src="编译原理（4）词法分析/image-20200613160754459.png" alt="image-20200613160754459" style="zoom:75%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160754459.png" class="" title="This is image_d"><p><strong>DFA的状态转换图表示：</strong></p><img src="编译原理（4）词法分析\image-20200613160815782.png" alt="image-20200613160815782" style="zoom:75%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160815782.png" class="" title="This is image_e"><p><strong>DFA</strong> <strong>的矩阵表示</strong></p><img src="编译原理（4）词法分析\image-20200613160908110.png" alt="image-20200613160908110" style="zoom:70%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160908110.png" class="" title="This is image_f"><p><strong>DFA M的作用：</strong></p><p> 对于∑*中的任何字符串t，若存在一条从初态结到某一终态结的道路，且这条路上所有弧的标记符连接成的字符串等于t，则称t可为DFA M所接受（识别）。若M的初态结同时又是终态结，则空字可为M所识别（接受）。</p><ul><li><p>∑*上的符号串t被M接受的形式叙述：</p><p>若t∈∑*，f (S，t)=P，其中S为 M的开始状态，P ∈ Z，Z为终态集。</p><p>则称t为DFA M所<strong>接受</strong>（<strong>识别</strong>）。</p></li><li><p>∑*上的符号串t在M上运行的定义：</p><p>一个输入符号串t，（我们将它表示成 t1tx的形式，其中t1 ∈∑，tx∈ ∑<em>）在DFA M上*</em>运行**的定义为：</p><p>f（Q， t1 tx ）=f（f（Q， t1 ），tx） 其中Q∈K                         </p></li></ul><p>例：证明t=baab被前例中的DFA所接受</p><img src="编译原理（4）词法分析\image-20200613183717517.png" alt="image-20200613183717517" style="zoom:55%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613183717517.png" class="" title="This is image_g"><p>所识别的语言：含有相继两个a或相继两个b的串。</p><p>DFA M所能接受的符号串的全体记为 L(M)(语言)</p><p><strong>结论：</strong></p><p>– Σ上一个符号串集V 包含于 Σ*是正规的，当且仅当存在一个Σ上的确定有穷自动机M，使得V=L(M)。</p><h3 id="4-3-2-不确定的有穷自动机NFA"><a href="#4-3-2-不确定的有穷自动机NFA" class="headerlink" title="4.3.2 不确定的有穷自动机NFA"></a>4.3.2 不确定的有穷自动机NFA</h3><p>NFA定义：</p><p>N={K，Σ，f，S，Z}，其中K为状态的有穷非空集，Σ为有穷输入字母表，f为Kx Σ*到K的子集（2^K）的一种映射，S 包含于 K是初始状态集，Z 包含于 K为终止状态集。</p><ul><li><p>例子</p><p>NFA N=（{S，P，Z}，{0，1}，f，{S，P}，{Z}）</p><p>其中 f（S，0）={P}</p><p>​        f（S，1）={S，Z}</p><p>​        f（P，1）={Z}</p><p>​        f（Z，0）={P}</p><p>​        f（Z，1）={P}</p><p>状态图表示：</p></li></ul><img src="编译原理（4）词法分析\image-20200613184408840.png" alt="image-20200613184408840" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613184408840.png" class="" title="This is image_h"><ul><li>∑*上的符号串t在NFA N上运行</li><li>∑*上的符号串t被NFA N接受</li><li>具有ε转移的不确定的有穷自动机NFA… f为 K x（Σ ∪{ε}）到K的子集（2^K）的一种映射</li><li>对任何一个具有ε转移的不确定的有穷自动机NFA　N，一定存在一个不具有ε转移的不确定的有穷自动机NFA　Ｍ ，使得L(M)=L(N)。</li></ul><h3 id="4-3-3-NFA的确定化"><a href="#4-3-3-NFA的确定化" class="headerlink" title="4.3.3 NFA的确定化"></a>4.3.3 NFA的确定化</h3><p>DFA是NFA的特例。对每个NFA N一定存在一个DFA M ，使得L(M)=L(N)。对每个NFA N存在着与之等价的DFA M。与某一NFA等价的DFA不唯一。</p><p><strong>定义对状态集合I的几个有关运算：</strong></p><ol><li>状态集合 I 的 ε- 闭包，表示为 ε-closure(I)，定义为一状态集，是状态集 I 中的任何状态S经任意条ε弧而能到达的状态的集合。状态集合 I 的任何状态S都属于 ε-closure(I)。</li><li>状态集合 I 的a弧转换，表示为 move(I,a) 定义为状态集合 J，其中 J 是所有那些可从 I 的某一状态经过一条a弧而到达的状态的全体。定义 Ia = ε-closure(J)</li></ol><p>例：</p><img src="编译原理（4）词法分析\image-20200613190857433.png" alt="image-20200613190857433" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190857433.png" class="" title="This is image_i"><img src="编译原理（4）词法分析\image-20200613190905154.png" alt="image-20200613190905154" style="zoom:90%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190905154.png" class="" title="This is image_j"><p>假设NFA N=(K, Σ, f, K0, Kt)按如下办法构造一个DFA M=(S, Σ, d, S0, St)，使得L(M)=L(N)：</p><ol><li><p>M的状态集S由K的一些子集组成。用[S1 S2… Sj ]表示S的元素，其中S1, S2,,… Sj是K的状态。并且约定，状态S1, S2,… Sj 是按某种规则排列的，即对于子集{S1, S2}={ S2, S1,}来说，S的状态就是[S1 S2]；</p></li><li><p>M和N的输入字母表是相同的，即是 Σ ；</p></li><li><p>转换函数是这样定义的：                    </p><p> d([S1 S2,… Sj],a)= [R1R2… Rt]  其中   {R1,R2,… , Rt} = ε-closure(move({S1, S2,,… Sj},a)) </p></li><li><p>S0=ε-closure(K0)为M的开始状态；</p></li><li><p>St={[Si Sk… Se]，其中[Si  Sk… Se]∈S且{Si , Sk,,… Se}∩Kt≠Φ}</p></li></ol><p><strong>NFA确定化例子：</strong></p><img src="编译原理（4）词法分析\image-20200613192154391.png" alt="image-20200613192154391" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192154391.png" class="" title="This is image_k"><img src="编译原理（4）词法分析\image-20200613192229903.png" alt="image-20200613192229903" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192229903.png" class="" title="This is image_l"><img src="编译原理（4）词法分析\image-20200613205712090.png" alt="image-20200613205712090" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613205712090.png" class="" title="This is image_m"><h2 id="4-4-有穷自动机和正规表达式"><a href="#4-4-有穷自动机和正规表达式" class="headerlink" title="4.4 有穷自动机和正规表达式"></a>4.4 有穷自动机和正规表达式</h2><p><strong>有穷自动机和正规表达式的等价性：</strong>   </p><ul><li>对于∑上的一个NFA M，可以构造一个∑上的正规式R,使得L(R)=L(M)。</li><li>对于∑上的一个正规式R，可以构造一个∑上的NFA M，使的L(M)=L(R)。</li></ul><p><strong>正规式 =&gt;有穷自动机</strong></p><p>设给定正规式W，则构造相应自动机的方法如下：</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" alt="n"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" class="" title="This is image_n"><p>然后利用以下规则加入结点和箭弧，直到得到自动机为止。</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" alt="o"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" class="" title="This is image_o"><p><strong>有穷自动机=&gt;正规式</strong></p><p>首先检查是否只有一个终态结点，若有多个，则引入新结点T，从所有终态结点引ε边到T结点，并令T为唯一的终态结点。</p><p>然后按以下规则消除结点与箭弧：</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" alt="p"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" class="" title="This is image_p"><h2 id="4-5-有穷自动机和正规文法"><a href="#4-5-有穷自动机和正规文法" class="headerlink" title="4.5 有穷自动机和正规文法"></a>4.5 有穷自动机和正规文法</h2><p><strong>有穷自动机和正规文法的等价性：</strong>     </p><ul><li>对于一个NFA M，都存在 一个正规文法G，使得L(G)=L(M).               </li><li>对于一个正规文法G,都存在一个NFA M，使得L(M)=L(G). </li></ul><p><strong>正规文法=&gt;自动机</strong></p><ul><li>字母表与G的终结符集相同；</li><li>G中的非终结符对应状态，开始符对应开始状态</li><li>增加一个新的终结状态Z。</li><li>G中的A-&gt;tB构造转换函数f(A,t)=B</li><li>G中的A-&gt;t构造转换函数f(A,t)=Z</li></ul><p><strong>自动机=&gt;正规文法</strong></p><ul><li>对转换函数f(A,t)=B，对应产生式：   A-&gt;tB</li><li>对终态Z，增加一产生式： Z-&gt;ε</li><li>NFA的初态对应文法的开始符号；</li><li>NFA的字母表对应文法的终结符号集。</li></ul>]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（2）文法和语言</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="2-1-符号、符号串及其集合的运算"><a href="#2-1-符号、符号串及其集合的运算" class="headerlink" title="2.1 符号、符号串及其集合的运算"></a>2.1 符号、符号串及其集合的运算</h2><p>任何一种语言都是由该语言的基本符号组成的符号串的集合。</p><ul><li>​    基本符号集</li><li>​    任何语言的单词符号就是定义在它的字符集上的字符串</li><li>​    该语言的任何语句就是定义在其单词符号集上的单词串(符号串)</li></ul><h3 id="2-1-1-字母表和符号串"><a href="#2-1-1-字母表和符号串" class="headerlink" title="2.1.1 字母表和符号串"></a>2.1.1 字母表和符号串</h3><p>字母表：是元素的非空有穷集合，把字母表中的元素称为符号，因此字母表也称符号集。</p><p>符号串：字母表中的符号串组成的任何有穷序列。</p><h3 id="2-1-2-符号串及其集合的运算"><a href="#2-1-2-符号串及其集合的运算" class="headerlink" title="2.1.2 符号串及其集合的运算"></a>2.1.2 符号串及其集合的运算</h3><p>① 符号串的长度：如果某符号串x中有m个符号，则其长度为m，记为|x|=m。例</p><p>② 符号串的联接：设x和y是符号串，它们的联接xy是把y的符号写在x的符号之后得到的符号串。</p><p>③ 符号串的方幂：设x是符号串，把x自身连接n次得到符号串z，即z=xxx….xx，称为符号串x的方幂。</p><p>④ 符号串集合：若集合A中的一切元素都是某字母表上的符号串，则称A为字母表上的符号串集合。</p><ul><li>语言：表示某个确定的字母表上的符号串的任何集合。</li></ul><p>⑤ 集合的乘积：AB={xy|x∈A且y∈B}。</p><p>⑥ 集合A的闭包A*和正闭包A+：</p><img src="编译原理（2）文法和语言/a.png" alt="a" style="zoom:80%;" /><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/a.png" class="" title="This is image_a"><h2 id="2-2-文法的直观概念"><a href="#2-2-文法的直观概念" class="headerlink" title="2.2 文法的直观概念"></a>2.2 文法的直观概念</h2><p>文法的定义∶对语言结构的描述和定义，即在形式上用来描述和规定语言结构的称为“文法”(或“语法”)。</p><p><strong>规则</strong></p><p>​    句子的语法结构，可以用一组规则来描述。</p><p>​    规则也称为“产生式”，规则中的“∷=”也常用“→”表示。</p><p>​    注意∶文法中，描述某个特定的语法成分的规则可能不只一条。</p><p><strong>由规则推导句子</strong></p><p>如果用一组规则来描述句子的结构，就可以利用这组规则按照一定的方式去推导产生句子。</p><p>推导方法∶使用一条规则，代替=&gt;左边的某个符号，产生=&gt;右端的符号串</p><h2 id="2-3-文法和语言的形式定义"><a href="#2-3-文法和语言的形式定义" class="headerlink" title="2.3 文法和语言的形式定义"></a>2.3 文法和语言的形式定义</h2><h3 id="2-3-1-文法的形式定义"><a href="#2-3-1-文法的形式定义" class="headerlink" title="2.3.1 文法的形式定义"></a>2.3.1 文法的形式定义</h3><p>① 规则、产生式(或重写规则)∶形如α→β或α∷=β的（α，β）有序对，且α∈V+，β∈V* ， V为某字母表。</p><ul><li>α称为规则的左部(或产生式的左部)。</li><li>β称为规则的右部(或产生式的右部)。</li></ul><p>②文法的定义</p><p>（1）文法G定义为四元组（VN，VT，P，S）</p><p>​        –VN：非终结符集</p><p>​        –VT ：终结符集</p><p>​        –P：产生式（规则）集合</p><p>​        –S：开始符号</p><p>​    VN ∩ VT = φ，S∈VN</p><p>​    V=VN∪VT，称为文法G的文法符号集合</p><p>（2）习惯上只将产生式写出。并有如下约定：</p><p>​        –第一条产生式的左部是开始符号</p><p>​        –用尖括号括起的是非终结符，否则为终结符。或者大写字母表示非终结符，小写字母表示终结符</p><p>​        –G可写成G[S]，S是开始符号</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">G：S→aAb      <span class="hljs-keyword">A</span>→ab    <span class="hljs-keyword">A</span>→aAb    <span class="hljs-keyword">A</span>→ε <br>G[S]： <span class="hljs-keyword">A</span>→ab    <span class="hljs-keyword">A</span>→aAb    <span class="hljs-keyword">A</span>→ε  S→aSb <br>缩写形式 G[S]：<span class="hljs-keyword">A</span>→ab|aAb|ε      S→aSb<br>注意：元符号“|”读作“或”<br></code></pre></td></tr></table></figure><h3 id="2-3-2-推导的形式定义"><a href="#2-3-2-推导的形式定义" class="headerlink" title="2.3.2 推导的形式定义"></a>2.3.2 推导的形式定义</h3><p>直接推导“=&gt;”</p><p>​         α→β是文法G的产生式，若有v,w满足：</p><p>​         v=γ α δ, w= γ β δ, 其中 γ∈V* , δ∈V*</p><pre><code> 则称v直接推导出w, 记作 v =&gt; w或w直接归约到v</code></pre><p>若存在v=&gt;w0=&gt;w1 =&gt;… =&gt;wn=w, (n&gt;0)，则称v  <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" /> w，v推导出w，或w归约到v。</p><p>若有v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" />  w，或v=w，则记为v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608221128579.png" alt="image-20200608221128579" style="zoom:50%;" />  w</p><p><strong>句型</strong></p><p>​    – 有文法G，若S =*&gt;  x，则称x是文法G的句型。</p><p>​    一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。</p><p><strong>句子</strong></p><p>​    – 有文法G，若S =+&gt; x，且x∈VT*，则称x是文法G的句子。</p><p>​    句子是不包含非终结符的句型。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">如：有下列文法：<br>　　S→AB<br>　　A→aA|a<br>　　B→bB|b<br>用上述文法推导字符串aaabbb过程如下：<br>　　S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbb<br>AB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型<br>只有终结符的句型为句子。<br></code></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs r">例：G[E]：E→E+<span class="hljs-built_in">T</span>|<span class="hljs-built_in">T</span>          <br><span class="hljs-built_in">T</span>→<span class="hljs-built_in">T</span>*<span class="hljs-built_in">F</span>|<span class="hljs-built_in">F</span>          <br><span class="hljs-built_in">F</span>→(E)|a<br>E=&gt;E+<span class="hljs-built_in">T</span>=&gt;<span class="hljs-built_in">T</span>+<span class="hljs-built_in">T</span>=&gt;<span class="hljs-built_in">F</span>+<span class="hljs-built_in">T</span>=&gt;a+<span class="hljs-built_in">T</span>=&gt;a+<span class="hljs-built_in">T</span>*<span class="hljs-built_in">F</span>=&gt;a+<span class="hljs-built_in">F</span>*<span class="hljs-built_in">F</span>=&gt;a+a*<span class="hljs-built_in">F</span>=&gt;a+a*a<br>表示一切能用符号a，+，*，(和)构成的算术表达式<br></code></pre></td></tr></table></figure><h3 id="2-3-3-语言的形式定义"><a href="#2-3-3-语言的形式定义" class="headerlink" title="2.3.3 语言的形式定义"></a>2.3.3 语言的形式定义</h3><p>由文法G生成的语言记为L(G),它是文法G的一切句子的集合:                    </p><p>​        L(G)={x|S =+&gt; x，其中S为文法的开始符号，且x ∈VT*}</p><p><strong>文法的等价</strong></p><p>若L（G1）=L（G2），则称文法G1和G2是等价的。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">如文法G1[<span class="hljs-keyword">A</span>]：<span class="hljs-keyword">A</span>→<span class="hljs-number">0</span>R    与   G2[S]：S→<span class="hljs-number">0</span>S1 等价<br>           <span class="hljs-keyword">A</span>→<span class="hljs-number">01</span>                S→<span class="hljs-number">01</span><br>           R→A1<br></code></pre></td></tr></table></figure><p>练习：已知语言描述，写出文法</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">例：若语言由<span class="hljs-number">0</span>、<span class="hljs-number">1</span>符号串组成，串中<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的个数相同，构造其文法。<br> A → <span class="hljs-number">0</span>B|<span class="hljs-type">1C</span><br> B → <span class="hljs-number">1</span>|<span class="hljs-type">1A</span>|<span class="hljs-type">0BB</span><br> C → <span class="hljs-number">0</span>|<span class="hljs-type">0A</span>|<span class="hljs-type">1CC</span><br></code></pre></td></tr></table></figure><p>练习：已知文法，写出语言描述</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs r">例：G[E]：E→E+<span class="hljs-built_in">T</span>|<span class="hljs-built_in">T</span><br>         <span class="hljs-built_in">T</span>→<span class="hljs-built_in">T</span>*<span class="hljs-built_in">F</span>|<span class="hljs-built_in">F</span><br>         <span class="hljs-built_in">F</span>→(E)|a<br>表示一切能用符号a，+，*，(和)构成的算术表达式<br></code></pre></td></tr></table></figure><h2 id="2-4-文法的类型"><a href="#2-4-文法的类型" class="headerlink" title="2.4 文法的类型"></a>2.4 文法的类型</h2><p><strong>Chomsky</strong> <strong>将文法分为四种类型：</strong></p><p>（1）0型文法（短语文法）：G=(VN,VT,P,S)对任一产生式α→β，都有α∈(VN∪VT) *，且至少含有一个非终结符， β∈(VN∪VT) *</p><p>（2）1型文法（上下文有关文法）：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外，1型文法也可描述为α1Aα2→α1βα2</p><p>（3）2型文法（上下文无关文法）：对任一产生式α→β，都有α∈VN ， β∈(VN∪VT)*</p><p>（4）3型文法（正规文法）：任一产生式α→β的形式都为A→aB或A→a，其中A∈VN，B∈VN，a∈VT</p><p>例：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-number">1</span>型（上下文有关）文法：<br>   文法G[S]： S→CDAb→bA<br>   C→aCA  Ba→aB<br>   C→bCB  Bb→bB<br>   AD→aD  C→ε<br>   BD→bD  D→ε<br>   Aa→bD<br>L(G)=&#123;w|<span class="hljs-type">w</span>∈&#123;a,b&#125;*&#125;<br><br><span class="hljs-number">2</span>型（上下文无关）文法：<br>   文法G[S]：S→aB|<span class="hljs-type">bA</span><br>  A→a|<span class="hljs-type">aS</span>|<span class="hljs-type">bAA</span><br>  B→b|<span class="hljs-type">bS</span>|<span class="hljs-type">aBB</span><br>   文法G[S]：S→<span class="hljs-number">0</span>A|<span class="hljs-type">1B</span>|<span class="hljs-type">0</span><br>  A→<span class="hljs-number">0</span>A|<span class="hljs-type">1B</span>|<span class="hljs-type">0S</span><br>  B→<span class="hljs-number">1</span>B|<span class="hljs-type">1</span>|<span class="hljs-type">0</span><br><br>定义标识符的<span class="hljs-number">3</span>型（正规）文法：<br>   文法G[I]：I → iT<br> I → i<br> T → iT<br> T → dT<br> T → i<br>             T → d<br></code></pre></td></tr></table></figure><p><strong>文法和语言</strong></p><p>0型文法产生的语言称为0型语言</p><p>1型文法或上下文有关文法（ CSG ）产生的语言称为1型语言或上下文有关语言（CSL）</p><p>2型文法或上下文无关文法（ CFG ）产生的语言称为2型语言或上下文无关语言（ CF L ） </p><p>3型文法或正则（正规）文法（ RG ）产生的语言称为3型语言正则（正规）语言（ RL ）</p><p><strong>文法和识别系统</strong></p><p>0型文法（短语文法）的能力相当于图灵机，可以表征任何递归可枚举集，而且任何0型语言都是递归可枚举的</p><p>1型文法（上下文有关文法）：产生式的形式为α1Aα2→α1βα2，即只有A出现在α1和α2的上下文中时，才允许β取代A。其识别系统是线性界限自动机。</p><p>2型文法（上下文无关文法、CFG）：产生式的形式为A→β，β取代A时与A的上下文无关。其识别系统是不确定的下推自动机。</p><p>3型文法（正规文法、右线性文法）：产生的语言是有穷自动机（FA）所接受的集合</p><h2 id="2-5-上下文无关文法及其语法树"><a href="#2-5-上下文无关文法及其语法树" class="headerlink" title="2.5 上下文无关文法及其语法树"></a>2.5 上下文无关文法及其语法树</h2><h3 id="2-5-1-上下文无关文法的语法树"><a href="#2-5-1-上下文无关文法的语法树" class="headerlink" title="2.5.1 上下文无关文法的语法树"></a>2.5.1 上下文无关文法的语法树</h3><p>用于描述上下文无关文法的句型推导的直观方法</p><p>叶子结点：树中没有子孙的结点。</p><p>从左到右读出推导树的叶子标记，所得的句型为推导树的结果。也把该推导树称为该句型的语法树。</p><p>定义：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">给定文法G，对于G的任何句型都能构造与之关联的语法树（推导树）。这棵树满足下列<span class="hljs-number">4</span>个条件：<br><span class="hljs-number">1</span>、每个结点都有一个V中的符号作标记<br><span class="hljs-number">2</span>、根的标记是开始符号S<br><span class="hljs-number">3</span>、若一结点n至少有一个它自己除外的子孙，并且n有标记<span class="hljs-keyword">A</span>，则<span class="hljs-keyword">A</span>∈VN<br><span class="hljs-number">4</span>、如果结点n的直接子孙，从左到右的次序是结点n1,n2,…,nk，其标记分别为A1,A2,…,Ak，那么<span class="hljs-keyword">A</span>→A1A2,…,Ak一定是P中的一个产生式<br></code></pre></td></tr></table></figure><p>推导过程中使用产生式的顺序：</p><ul><li>最左（最右）推导：在推导的任何一步α=&gt;β，其中α、β是句型，都是对α中的最左（右）非终结符进行替换</li><li><strong>最右推导被称为规范推导</strong>。 <strong>最左归约–&gt;规范规约</strong></li><li>由规范推导所得的句型称为规范句型</li></ul><h3 id="2-5-2-二义性"><a href="#2-5-2-二义性" class="headerlink" title="2.5.2 二义性"></a>2.5.2 二义性</h3><p><strong>二义文法</strong></p><p>若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是<em>二义</em> 的。</p><p>或者，若一个文法存在某个句子有两个不同的最左（右）推导，则称这个文法是<em>二义</em> 的。</p><p>产生某上下文无关语言的每一个文法都是二义的，则称此语言是<em>先天二义</em>的。</p><p>二义文法改造为无二义文法</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">G</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-operator">:</span> <span class="hljs-built_in">E</span> → <span class="hljs-variable">i</span>         <span class="hljs-variable">G</span><span class="hljs-punctuation">[</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span>：<span class="hljs-built_in">E</span> → <span class="hljs-variable">T</span><span class="hljs-operator">|</span><span class="hljs-built_in">E</span><span class="hljs-operator">+</span><span class="hljs-variable">T</span><br>  <span class="hljs-built_in">E</span> → <span class="hljs-built_in">E</span><span class="hljs-operator">+</span><span class="hljs-built_in">E</span>             <span class="hljs-variable">T</span> → <span class="hljs-variable">F</span><span class="hljs-operator">|</span><span class="hljs-variable">T</span><span class="hljs-operator">*</span><span class="hljs-variable">F</span><br>  <span class="hljs-built_in">E</span> → <span class="hljs-built_in">E</span><span class="hljs-operator">*</span><span class="hljs-built_in">E</span>             <span class="hljs-variable">F</span> →（<span class="hljs-built_in">E</span>）<span class="hljs-operator">|</span><span class="hljs-variable">i</span><br>  <span class="hljs-built_in">E</span> → <span class="hljs-punctuation">(</span><span class="hljs-built_in">E</span><span class="hljs-punctuation">)</span>       规定优先顺序和结合律<br></code></pre></td></tr></table></figure><h2 id="2-6-句型的分析"><a href="#2-6-句型的分析" class="headerlink" title="2.6 句型的分析"></a>2.6 句型的分析</h2><p><strong>句型分析</strong> 就是识别一个符号串是否为某文法的句型，是某个推导的构造过程。</p><p>在语言的编译实现中，把完成句型分析的程序称为<em>分析程序</em> 或<em>识别程序</em>。分析算法又称<em>识别算法</em>。</p><p><em>从左到右的分析算法</em> ，即总是从左到右地识别输入符号串，首先识别符号串中的最左符号，进而依次识别右边的一个符号。</p><p><strong>分析算法可分为：</strong></p><p><strong><em>自上而下分析法</em>：</strong> </p><p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的推导。</p><p><strong><em>自下而上分析法</em>：</strong></p><p> 从输入符号串开始，逐步进行归约，直至归约到文法的开始符号。</p><p>两种方法反映了两种不同的语法树的构造过程</p><p><strong>句型分析的有关问题</strong></p><p>1）如何选择使用哪个产生式进行推导？</p><p>2）如何识别可归约的串？</p><p><strong>句型分析</strong></p><p>短语、直接短语、句柄的定义：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dns">概念：<br>如果 S⇒* α<span class="hljs-keyword">A</span>β 且 <span class="hljs-keyword">A</span> ⇒+ γ，则称γ是句型αγβ的相对于非终结符<span class="hljs-keyword">A</span>的`短语` 。<br>如果 S⇒* α<span class="hljs-keyword">A</span>β 且 <span class="hljs-keyword">A</span> ⇒ γ，则称γ是句型αγβ的相对于规则<span class="hljs-keyword">A</span>→γ的`直接(简单)短语`。<br>直接短语中的最左直接短语为该句型的句柄。<br><br>理解：<br>短语：<br>一个句型的分析树中的每一棵子树的边缘(所有叶节点)所组成的符号串称为该句型的一个短语(phrase)。 <br>直接短语：<br>如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语(immediate phrase)；<br>所有子树中，深度为<span class="hljs-number">2</span>的子树的叶子节点串就是直接短语（因为直接短语必须是由子树根节点用一步推出来的，所以深度为<span class="hljs-number">2</span>）；<br>即如果子树中不再包含其他的子树，即<span class="hljs-keyword">A</span>只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。<br><br>句柄：<br>“可规约串”，句柄对应某个产生式的右部，是某个，但不是任意一个。<br>作为一种规约对象，句柄表示最左直接短语。<br>语法树： 在语法树上，则表示为最左边的只包含相邻父子节点的短语（最左直接短语）<br></code></pre></td></tr></table></figure><p>素短语和最左素短语</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">概念：<br>素短语：<br>是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。<br><br>最左素短语：<br>最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象。<br>语法树：通过语法树分析时，要注意先判断是否为素短语，再找相对最左端的素短语。<br><br>理解：<br>素短语 ：<br>指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。<br>从短语集合中找出所有含有终结符的短语，然后选出除它自身之外不再含更小的素短语。<br>（这个小的概念是集合中没有被包含的元素，如有两个短语<span class="hljs-keyword">aAA</span>和aAAA，<span class="hljs-keyword">aAA</span>含于aAAA，所以<span class="hljs-keyword">aAA</span>比aAAA小）<br><br>最左素短语：<br>从素短语集合中找出最左边的素短语。<br></code></pre></td></tr></table></figure><h2 id="2-7文法实用中的一些说明"><a href="#2-7文法实用中的一些说明" class="headerlink" title="2.7文法实用中的一些说明"></a>2.7文法实用中的一些说明</h2><h3 id="2-7-1-有关文法的实用限制"><a href="#2-7-1-有关文法的实用限制" class="headerlink" title="2.7.1 有关文法的实用限制"></a>2.7.1 有关文法的实用限制</h3><p>文法中不得含有<em>有害规则</em> 和<em>多余规则</em></p><ul><li><p>有害规则：形如U→U的产生式。会引起文法的二义性</p></li><li><p>多余规则：指文法中任何句子的推导都不会用到的规则</p><p>1）文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达</p><p>2）文法中某些非终结符，由它不能推出终结符号串来，称为不可终止的</p></li></ul><p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p><p>​        1）A必须在某句型中出现。</p><p>​        2）必须能从A推出终结符号串t来。</p><h3 id="2-7-2-上下文无关文法中的ε规则"><a href="#2-7-2-上下文无关文法中的ε规则" class="headerlink" title="2.7.2 上下文无关文法中的ε规则"></a>2.7.2 上下文无关文法中的ε规则</h3><p>具有形式A→ε的规则称为ε规则，其中A∈VN</p><p>某些著作和讲义中限制这种规则的出现。因为ε规则会使有关文法的一些讨论和证明变得复杂</p>]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理（1）编译概述</title>
    <link href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-1-程序设计语言"><a href="#1-1-程序设计语言" class="headerlink" title="1.1 程序设计语言"></a>1.1 程序设计语言</h3><p>Machine Code</p><p>Assembly Language</p><p>High-level Language</p><p>如Algol, Fortran, Pascal, C语言等。</p><h3 id="1-2-什么叫编译程序"><a href="#1-2-什么叫编译程序" class="headerlink" title="1.2 什么叫编译程序"></a>1.2 什么叫编译程序</h3><p>翻译程序：就是将源程序转换成目标程序的程序。</p><p>source program —–&gt;  Translator  ——&gt;  target program</p><p>翻译程序和解释程序的区别：</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" alt="1"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" class="" title="This is image1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">解释方式最终不生成目标程序，这是编译方式和解释方式的根本区别。<br>编译方式：是将源程序经编译得到可执行文件后，就可脱离源程序和编译程序单独执行，所以编译方式的效率高，执行速度快；<br>解释方式：在执行时，必须源程序和解释程序同时参与才能运行，其不产生可执行程序文件，效率低，执行速度慢。<br></code></pre></td></tr></table></figure><p>编译程序和汇编程序的区别：</p><p>​        如果源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，这样的一个翻译程序称为编译程序。如果源语言是汇编语言，而目标语言是机器语言，这样的一个翻译程序称为汇编程序。</p><p>解释性语言：</p><p>（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行：  源代码—&gt;中间代码—&gt;机器语言</p><p>（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；</p><p>（3）解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；</p><p>（4）运行效率一般相对比较低，依赖解释器，跨平台性好；</p><p>（5）Java是编译性-解释性语言，因为其同时具备编译性和解释性两种特性。</p><h3 id="1-3-编译程序的组成"><a href="#1-3-编译程序的组成" class="headerlink" title="1.3 编译程序的组成"></a>1.3 编译程序的组成</h3><p>一个典型的编译程序应具有以下的组成：</p><p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" alt="2"></p><img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" class="" title="This is image2"><p>编译程序的两个主要任务：</p><p>一是分析，二是综合。</p><p>编译程序结构(components)</p><ul><li>词法分析程序</li><li>语法分析程序</li><li>语义分析程序</li><li>中间代码生成程序</li><li>代码优化程序</li><li>目标代码生成程序</li><li>符号表管理程序</li><li>出错处理程序</li></ul><p>（1）Scanner （词法分析）</p><p>任务：识别单词符号，是最初级的语法分析。</p><p>依循的规则：语言的构词规则。</p><p>（2）Parser （语法分析）</p><p>任务∶对词法分析的输出即单词符号串进行分析，识别出一个个语法成分，并进行语法检查。</p><p>依循的规则：语法规则。</p><p>（语法单位：算术表达式、短语、句子、子程序……）</p><p>（3）Semantic Analyzer （语义分析）</p><p>任务：对语法分析所识别的各种语法成分的意义(即语义)进行确定并加以处理。</p><p>依循的规则：语义规则</p><p>（4）Intermediate Code Generator</p><p>任务：从源程序的树形或其它形式，产生源程序的中间代码。</p><p>中间代码：四元式、三元式……</p><p>（5）Target Code Generator</p><p>任务：将中间代码转换成汇编程序或者机器语言。</p><p>（6）代码优化</p><p>代码优化程序的功能是将中间代码中重复和冗余部分进行优化，提高目标程序的执行效率。</p><p>（7）符号表管理</p><ul><li>符号表管理是一个贯穿编译全过程的工作。</li><li>编译程序在分析源程序时，需要记录标识符的各种属性信息；</li><li>在语义分析和代码生成阶段，还要对建立的符号表进行检索，提取相应的属性信息。–类型、作用域、分配存储信息</li></ul><p>（8）Error Handler （错误检测及处理）</p><ul><li>错误可发生在编译的各个阶段，错误处理也是贯穿编译全过程。</li><li>词法分析阶段可查出的错误，如标识符的组成不符合词法规则； </li><li>语句结构错误是在语法分析中可查出的错误；</li><li>语义分析阶段可查出的错误，即结构正确，但所涉及的操作无意义或错误。</li><li>在编译时查出的，叫Comple-time error，在运行时表现才表现出来的错误叫Run-time error。</li></ul><p>（9）前端和后端</p><ul><li>前端包括编译逻辑结构中的分析部分，即词法分析、语法分析、语义分析和中间代码生成，除此还包括符号表建造及相应分析中的错误处理以及与机器无关的优化部分。</li><li>后端包括与目标机有关的部分，即综合部分，它包括目标代码生成及生成期间对符号表的相应检索操作和错误处理操作，以及与机器相关的代码优化部分。</li><li>将编译系统划分为前后端，有利于移植编译系统和利用后端为同一目标机配置不同语言的编译系统。</li></ul><p>（10）遍（pass）</p><p>​        对源程序(或其中间形式)从头至尾扫描一次并进行有关加工处理，生成新的中间形式或最终目标程序，称为一遍。</p><p>分遍原则∶</p><ul><li>目标质量高低(高则多遍) </li><li>机器内存大小(小则多遍)</li><li>源语言简繁(繁则多遍)</li><li>设计人员多少(多则多遍)</li></ul><p>多遍扫描编译程序的优缺点∶</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：（1）可以减少内存容量的需求，分便后，以遍为单位分别调用编译的各个子程序，各遍程序可以相互覆盖；<br>（2）可使各遍的编译程序相互独立，结构清晰；<br>（3）能够进行充分的优化，产生高质量的目标程序；<br>（4）可将编译程序分为“前端”和“后端”，有利于编译程序的移植。<br>缺点：每遍都要读符号、送符号，增加了许多重复性工作，降低了编译效率。<br></code></pre></td></tr></table></figure><h3 id="1-4-编译程序的生成"><a href="#1-4-编译程序的生成" class="headerlink" title="1.4 编译程序的生成"></a>1.4 编译程序的生成</h3><p><strong>实现工具：</strong>Low-level Language；</p><p>​                   High-level Language；</p><p>​                   Automatic Builder。</p><p><strong>生成方法：</strong>Self-compiler;</p><p>​                   transplant</p>]]></content>
    
    
    <categories>
      
      <category>computer theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础语法</title>
    <link href="/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><hr><h4 id="python常用数据类型"><a href="#python常用数据类型" class="headerlink" title="python常用数据类型"></a>python常用数据类型</h4><p>1）在python中变量不直接存储值，而是存储值的内存地址或引用</p><p>2）在python中，不需要事先声明变量名及其类型，使用赋值语句可以直接创建任意类型的变量，变量的类型取决于等号右侧表达式值的类型。</p><p>3）赋值（比如a=’ABC’）时，python解释器干了两件事：</p><p>​                在内存中创建一个 ‘ABC’ 的字符串；</p><p>​                在内存中创建一个名为a的变量，并把它指向 ‘ABC’</p><h4 id="python的核心数据类型"><a href="#python的核心数据类型" class="headerlink" title="python的核心数据类型"></a>python的核心数据类型</h4><h5 id="（1）Number（数字）"><a href="#（1）Number（数字）" class="headerlink" title="（1）Number（数字）"></a>（1）Number（数字）</h5><p>python支持int、float、complex三种不同的数字类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = <span class="hljs-number">3</span><br>&gt;&gt;&gt;b = <span class="hljs-number">3.14</span><br>&gt;&gt;&gt;c = <span class="hljs-number">3</span> + <span class="hljs-number">4j</span><br>&gt;&gt;&gt;print(<span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(b), <span class="hljs-built_in">type</span>(c))<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">int</span>&#x27;&gt; &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">float</span>&#x27;&gt; &lt;<span class="hljs-title">class</span> &#x27;<span class="hljs-title">complex</span>&#x27;&gt;</span><br><span class="hljs-class">&gt;&gt;&gt;<span class="hljs-title">isinstance</span>(<span class="hljs-params">a, <span class="hljs-built_in">int</span></span>)</span><br><span class="hljs-class"><span class="hljs-title">True</span></span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br>print(math.factorial(<span class="hljs-number">32</span>))  <span class="hljs-comment">#计算32的阶乘</span><br>print(<span class="hljs-number">0.4</span>-<span class="hljs-number">0.3</span> == <span class="hljs-number">0.1</span>)      <span class="hljs-comment">#false 实数之间尽量避免直接比较大小</span><br>print(math.isclose(<span class="hljs-number">0.4</span>-<span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>)) <span class="hljs-comment">#true 测试两个实数是否足够接近</span><br><br>c = <span class="hljs-number">3</span>+<span class="hljs-number">4j</span><br>print(c+c)   <span class="hljs-comment">#复数相加</span><br>print(c.real)  <span class="hljs-comment">#查看复数的实部</span><br>print(c.imag)  <span class="hljs-comment">#查看复数的虚部</span><br>print(<span class="hljs-number">3</span>+<span class="hljs-number">4j</span>.imag) <span class="hljs-comment">#相当于3+(4j).imag</span><br></code></pre></td></tr></table></figure><h5 id="（2）String（字符串）"><a href="#（2）String（字符串）" class="headerlink" title="（2）String（字符串）"></a>（2）String（字符串）</h5><p>python中的字符串可以使用单引号、双引号和三引号括起来，使用反斜杠 \ 转义特殊字符</p><p>python3源码文件默认以UTF-8编码，所有字符串都是Unicode字符串</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&#x27;&#x27;&#x27;Beautiful is better than ugly.</span><br><span class="hljs-string">Explicit is better than implicit.</span><br><span class="hljs-string">Simple is better than complex.</span><br><span class="hljs-string">Complex is better than complicated.</span><br><span class="hljs-string">Flat is better than nested.&#x27;&#x27;&#x27;</span><br><br>print(<span class="hljs-built_in">len</span>(text))            <span class="hljs-comment">#字符串长度，即所有字符的数量</span><br>print(text.count(<span class="hljs-string">&#x27;is&#x27;</span>))     <span class="hljs-comment">#字符串中单词is出现的次数</span><br>print(<span class="hljs-string">&#x27;beautiful&#x27;</span> <span class="hljs-keyword">in</span> text)  <span class="hljs-comment">#测试字符串中是否包含单词beautiful(大小写敏感)</span><br>print(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">20</span>)   <span class="hljs-comment">#字符串重复</span><br>print(<span class="hljs-string">&#x27;Good &#x27;</span>+<span class="hljs-string">&#x27;Morning&#x27;</span>)    <span class="hljs-comment">#字符串连接</span><br></code></pre></td></tr></table></figure><h5 id="（3）List（列表）"><a href="#（3）List（列表）" class="headerlink" title="（3）List（列表）"></a>（3）List（列表）</h5><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字、字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写在[]之间，用逗号分隔开的元素列表。</p><p>列表索引值以 0 为开始值，-1为从末尾的开始位置。</p><p>列表可以使用+操作符进行拼接，使用*表示重复。</p><h5 id="（4）Tuple（元组）"><a href="#（4）Tuple（元组）" class="headerlink" title="（4）Tuple（元组）"></a>（4）Tuple（元组）</h5><p>tuple 和 list 类似，不同之处在于tuple的元素不能修改。tuple 写在小括号里，元素之间用逗号隔开。（注：定义只有1个元素的tuple，必须加逗号）</p><p>元组的元素不可变，但可以包含可变对象，如 list。</p><h5 id="（5）dict（字典）"><a href="#（5）dict（字典）" class="headerlink" title="（5）dict（字典）"></a>（5）dict（字典）</h5><p>字典是无序的对象集合，使用键-值（key-value）存储，具有极快的查找速度。</p><p>键（key）必须使用不可变类型。</p><p>同一个字典中，键（key）必须是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;Michacl&#x27;</span>: <span class="hljs-number">95</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>: <span class="hljs-number">75</span>, <span class="hljs-string">&#x27;Tracy&#x27;</span>: <span class="hljs-number">65</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;Michacl&#x27;</span>]<br><span class="hljs-number">95</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>language</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/25/hello-world/"/>
    <url>/2020/05/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment">#generate 生成静态文件</span><br>hexo s <span class="hljs-comment">#server 启动服务器。在本地预览效果，默认情况下，访问网址为： http://localhost:4000/</span><br>hexo d <span class="hljs-comment">#deploy 部署网站同步到github。部署网站前，需要预先生成静态文件</span><br>hexo clean <span class="hljs-comment">#clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span><br></code></pre></td></tr></table></figure><h5 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h5><p>删除那篇文章，然后重新运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

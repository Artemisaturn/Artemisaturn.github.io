<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"artemisaturn.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://artemisaturn.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Daphne Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://artemisaturn.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编译原理（2）文法和语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:38:54" itemprop="dateCreated datePublished" datetime="2020-05-31T22:38:54+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:04:12" itemprop="dateModified" datetime="2020-08-01T09:04:12+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="2-1-符号、符号串及其集合的运算"><a href="#2-1-符号、符号串及其集合的运算" class="headerlink" title="2.1 符号、符号串及其集合的运算"></a>2.1 符号、符号串及其集合的运算</h2><p>任何一种语言都是由该语言的基本符号组成的符号串的集合。</p>
<ul>
<li>​    基本符号集</li>
<li>​    任何语言的单词符号就是定义在它的字符集上的字符串</li>
<li>​    该语言的任何语句就是定义在其单词符号集上的单词串(符号串)</li>
</ul>
<h3 id="2-1-1-字母表和符号串"><a href="#2-1-1-字母表和符号串" class="headerlink" title="2.1.1 字母表和符号串"></a>2.1.1 字母表和符号串</h3><p>字母表：是元素的非空有穷集合，把字母表中的元素称为符号，因此字母表也称符号集。</p>
<p>符号串：字母表中的符号串组成的任何有穷序列。</p>
<h3 id="2-1-2-符号串及其集合的运算"><a href="#2-1-2-符号串及其集合的运算" class="headerlink" title="2.1.2 符号串及其集合的运算"></a>2.1.2 符号串及其集合的运算</h3><p>① 符号串的长度：如果某符号串x中有m个符号，则其长度为m，记为|x|=m。例</p>
<p>② 符号串的联接：设x和y是符号串，它们的联接xy是把y的符号写在x的符号之后得到的符号串。</p>
<p>③ 符号串的方幂：设x是符号串，把x自身连接n次得到符号串z，即z=xxx….xx，称为符号串x的方幂。</p>
<p>④ 符号串集合：若集合A中的一切元素都是某字母表上的符号串，则称A为字母表上的符号串集合。</p>
<ul>
<li>语言：表示某个确定的字母表上的符号串的任何集合。</li>
</ul>
<p>⑤ 集合的乘积：AB={xy|x∈A且y∈B}。</p>
<p>⑥ 集合A的闭包A*和正闭包A+：</p>
<img src="编译原理（2）文法和语言/a.png" alt="a" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/a.png" class="" title="This is image_a">

<h2 id="2-2-文法的直观概念"><a href="#2-2-文法的直观概念" class="headerlink" title="2.2 文法的直观概念"></a>2.2 文法的直观概念</h2><p>文法的定义∶对语言结构的描述和定义，即在形式上用来描述和规定语言结构的称为“文法”(或“语法”)。</p>
<p><strong>规则</strong></p>
<p>​    句子的语法结构，可以用一组规则来描述。</p>
<p>​    规则也称为“产生式”，规则中的“∷=”也常用“→”表示。</p>
<p>​    注意∶文法中，描述某个特定的语法成分的规则可能不只一条。</p>
<p><strong>由规则推导句子</strong></p>
<p>如果用一组规则来描述句子的结构，就可以利用这组规则按照一定的方式去推导产生句子。</p>
<p>推导方法∶使用一条规则，代替=&gt;左边的某个符号，产生=&gt;右端的符号串</p>
<h2 id="2-3-文法和语言的形式定义"><a href="#2-3-文法和语言的形式定义" class="headerlink" title="2.3 文法和语言的形式定义"></a>2.3 文法和语言的形式定义</h2><h3 id="2-3-1-文法的形式定义"><a href="#2-3-1-文法的形式定义" class="headerlink" title="2.3.1 文法的形式定义"></a>2.3.1 文法的形式定义</h3><p>① 规则、产生式(或重写规则)∶形如α→β或α∷=β的（α，β）有序对，且α∈V+，β∈V* ， V为某字母表。</p>
<ul>
<li>α称为规则的左部(或产生式的左部)。</li>
<li>β称为规则的右部(或产生式的右部)。</li>
</ul>
<p>②文法的定义</p>
<p>（1）文法G定义为四元组（VN，VT，P，S）</p>
<p>​        –VN：非终结符集</p>
<p>​        –VT ：终结符集</p>
<p>​        –P：产生式（规则）集合</p>
<p>​        –S：开始符号</p>
<p>​    VN ∩ VT = φ，S∈VN</p>
<p>​    V=VN∪VT，称为文法G的文法符号集合</p>
<p>（2）习惯上只将产生式写出。并有如下约定：</p>
<p>​        –第一条产生式的左部是开始符号</p>
<p>​        –用尖括号括起的是非终结符，否则为终结符。或者大写字母表示非终结符，小写字母表示终结符</p>
<p>​        –G可写成G[S]，S是开始符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G：S→aAb      A→ab    A→aAb    A→ε </span><br><span class="line">G[S]： A→ab    A→aAb    A→ε  S→aSb </span><br><span class="line">缩写形式 G[S]：A→ab|aAb|ε      S→aSb</span><br><span class="line">注意：元符号“|”读作“或”</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-推导的形式定义"><a href="#2-3-2-推导的形式定义" class="headerlink" title="2.3.2 推导的形式定义"></a>2.3.2 推导的形式定义</h3><p>直接推导“=&gt;”</p>
<p>​         α→β是文法G的产生式，若有v,w满足：</p>
<p>​         v=γ α δ, w= γ β δ, 其中 γ∈V* , δ∈V*</p>
<pre><code> 则称v直接推导出w, 记作 v =&gt; w

或w直接归约到v</code></pre><p>若存在v=&gt;w0=&gt;w1 =&gt;… =&gt;wn=w, (n&gt;0)，则称v  <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" /> w，v推导出w，或w归约到v。</p>
<p>若有v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" />  w，或v=w，则记为v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608221128579.png" alt="image-20200608221128579" style="zoom:50%;" />  w</p>
<p><strong>句型</strong></p>
<p>​    – 有文法G，若S =*&gt;  x，则称x是文法G的句型。</p>
<p>​    一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。</p>
<p><strong>句子</strong></p>
<p>​    – 有文法G，若S =+&gt; x，且x∈VT*，则称x是文法G的句子。</p>
<p>​    句子是不包含非终结符的句型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如：有下列文法：</span><br><span class="line">　　S→AB</span><br><span class="line">　　A→aA|a</span><br><span class="line">　　B→bB|b</span><br><span class="line">用上述文法推导字符串aaabbb过程如下：</span><br><span class="line">　　S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbb</span><br><span class="line">AB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型</span><br><span class="line">只有终结符的句型为句子。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T          </span><br><span class="line">	T→T*F|F          </span><br><span class="line">	F→(E)|a</span><br><span class="line">E&#x3D;&gt;E+T&#x3D;&gt;T+T&#x3D;&gt;F+T&#x3D;&gt;a+T&#x3D;&gt;a+T*F&#x3D;&gt;a+F*F&#x3D;&gt;a+a*F&#x3D;&gt;a+a*a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-语言的形式定义"><a href="#2-3-3-语言的形式定义" class="headerlink" title="2.3.3 语言的形式定义"></a>2.3.3 语言的形式定义</h3><p>由文法G生成的语言记为L(G),它是文法G的一切句子的集合:                    </p>
<p>​        L(G)={x|S =+&gt; x，其中S为文法的开始符号，且x ∈VT*}</p>
<p><strong>文法的等价</strong></p>
<p>若L（G1）=L（G2），则称文法G1和G2是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如文法G1[A]：A→0R    与   G2[S]：S→0S1 等价</span><br><span class="line">           A→01                S→01</span><br><span class="line">           R→A1</span><br></pre></td></tr></table></figure>

<p>练习：已知语言描述，写出文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：若语言由0、1符号串组成，串中0和1的个数相同，构造其文法。</span><br><span class="line"> A → 0B|1C</span><br><span class="line"> B → 1|1A|0BB</span><br><span class="line"> C → 0|0A|1CC</span><br></pre></td></tr></table></figure>

<p>练习：已知文法，写出语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T</span><br><span class="line">         T→T*F|F</span><br><span class="line">         F→(E)|a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h2 id="2-4-文法的类型"><a href="#2-4-文法的类型" class="headerlink" title="2.4 文法的类型"></a>2.4 文法的类型</h2><p><strong>Chomsky</strong> <strong>将文法分为四种类型：</strong></p>
<p>（1）0型文法（短语文法）：G=(VN,VT,P,S)对任一产生式α→β，都有α∈(VN∪VT) *，且至少含有一个非终结符， β∈(VN∪VT) *</p>
<p>（2）1型文法（上下文有关文法）：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外，1型文法也可描述为α1Aα2→α1βα2</p>
<p>（3）2型文法（上下文无关文法）：对任一产生式α→β，都有α∈VN ， β∈(VN∪VT)*</p>
<p>（4）3型文法（正规文法）：任一产生式α→β的形式都为A→aB或A→a，其中A∈VN，B∈VN，a∈VT</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1型（上下文有关）文法：</span><br><span class="line">   文法G[S]：	 S→CD		Ab→bA</span><br><span class="line">			   C→aCA	  Ba→aB</span><br><span class="line">			   C→bCB	  Bb→bB</span><br><span class="line">			   AD→aD	  C→ε</span><br><span class="line">			   BD→bD	  D→ε</span><br><span class="line">			   Aa→bD</span><br><span class="line">L(G)&#x3D;&#123;w|w∈&#123;a,b&#125;*&#125;</span><br><span class="line"></span><br><span class="line">2型（上下文无关）文法：</span><br><span class="line">   文法G[S]：	S→aB|bA</span><br><span class="line">			  A→a|aS|bAA</span><br><span class="line">			  B→b|bS|aBB</span><br><span class="line">   文法G[S]：	S→0A|1B|0</span><br><span class="line">			  A→0A|1B|0S</span><br><span class="line">			  B→1B|1|0</span><br><span class="line"></span><br><span class="line">定义标识符的3型（正规）文法：</span><br><span class="line">   文法G[I]：	I → iT</span><br><span class="line">			 I → i</span><br><span class="line">			 T → iT</span><br><span class="line">			 T → dT</span><br><span class="line">			 T → i</span><br><span class="line">             T → d</span><br></pre></td></tr></table></figure>

<p><strong>文法和语言</strong></p>
<p>0型文法产生的语言称为0型语言</p>
<p>1型文法或上下文有关文法（ CSG ）产生的语言称为1型语言或上下文有关语言（CSL）</p>
<p>2型文法或上下文无关文法（ CFG ）产生的语言称为2型语言或上下文无关语言（ CF L ） </p>
<p>3型文法或正则（正规）文法（ RG ）产生的语言称为3型语言正则（正规）语言（ RL ）</p>
<p><strong>文法和识别系统</strong></p>
<p>0型文法（短语文法）的能力相当于图灵机，可以表征任何递归可枚举集，而且任何0型语言都是递归可枚举的</p>
<p>1型文法（上下文有关文法）：产生式的形式为α1Aα2→α1βα2，即只有A出现在α1和α2的上下文中时，才允许β取代A。其识别系统是线性界限自动机。</p>
<p>2型文法（上下文无关文法、CFG）：产生式的形式为A→β，β取代A时与A的上下文无关。其识别系统是不确定的下推自动机。</p>
<p>3型文法（正规文法、右线性文法）：产生的语言是有穷自动机（FA）所接受的集合</p>
<h2 id="2-5-上下文无关文法及其语法树"><a href="#2-5-上下文无关文法及其语法树" class="headerlink" title="2.5 上下文无关文法及其语法树"></a>2.5 上下文无关文法及其语法树</h2><h3 id="2-5-1-上下文无关文法的语法树"><a href="#2-5-1-上下文无关文法的语法树" class="headerlink" title="2.5.1 上下文无关文法的语法树"></a>2.5.1 上下文无关文法的语法树</h3><p>用于描述上下文无关文法的句型推导的直观方法</p>
<p>叶子结点：树中没有子孙的结点。</p>
<p>从左到右读出推导树的叶子标记，所得的句型为推导树的结果。也把该推导树称为该句型的语法树。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定文法G，对于G的任何句型都能构造与之关联的语法树（推导树）。这棵树满足下列4个条件：</span><br><span class="line">1、每个结点都有一个V中的符号作标记</span><br><span class="line">2、根的标记是开始符号S</span><br><span class="line">3、若一结点n至少有一个它自己除外的子孙，并且n有标记A，则A∈VN</span><br><span class="line">4、如果结点n的直接子孙，从左到右的次序是结点n1,n2,…,nk，其标记分别为A1,A2,…,Ak，那么A→A1A2,…,Ak一定是P中的一个产生式</span><br></pre></td></tr></table></figure>

<p>推导过程中使用产生式的顺序：</p>
<ul>
<li>最左（最右）推导：在推导的任何一步α=&gt;β，其中α、β是句型，都是对α中的最左（右）非终结符进行替换</li>
<li><strong>最右推导被称为规范推导</strong>。 <strong>最左归约–&gt;规范规约</strong></li>
<li>由规范推导所得的句型称为规范句型</li>
</ul>
<h3 id="2-5-2-二义性"><a href="#2-5-2-二义性" class="headerlink" title="2.5.2 二义性"></a>2.5.2 二义性</h3><p><strong>二义文法</strong></p>
<p>若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是<em>二义</em> 的。</p>
<p>或者，若一个文法存在某个句子有两个不同的最左（右）推导，则称这个文法是<em>二义</em> 的。</p>
<p>产生某上下文无关语言的每一个文法都是二义的，则称此语言是<em>先天二义</em>的。</p>
<p>二义文法改造为无二义文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G[E]: E → i         G[E]：E → T|E+T</span><br><span class="line">	  E → E+E             T → F|T*F</span><br><span class="line">	  E → E*E             F →（E）|i</span><br><span class="line">	  E → (E)       规定优先顺序和结合律</span><br></pre></td></tr></table></figure>

<h2 id="2-6-句型的分析"><a href="#2-6-句型的分析" class="headerlink" title="2.6 句型的分析"></a>2.6 句型的分析</h2><p><strong>句型分析</strong> 就是识别一个符号串是否为某文法的句型，是某个推导的构造过程。</p>
<p>在语言的编译实现中，把完成句型分析的程序称为<em>分析程序</em> 或<em>识别程序</em>。分析算法又称<em>识别算法</em>。</p>
<p><em>从左到右的分析算法</em> ，即总是从左到右地识别输入符号串，首先识别符号串中的最左符号，进而依次识别右边的一个符号。</p>
<p><strong>分析算法可分为：</strong></p>
<p><strong><em>自上而下分析法</em>：</strong> </p>
<p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的推导。</p>
<p><strong><em>自下而上分析法</em>：</strong></p>
<p> 从输入符号串开始，逐步进行归约，直至归约到文法的开始符号。</p>
<p>两种方法反映了两种不同的语法树的构造过程</p>
<p><strong>句型分析的有关问题</strong></p>
<p>1）如何选择使用哪个产生式进行推导？</p>
<p>2）如何识别可归约的串？</p>
<p><strong>句型分析</strong></p>
<p>短语、直接短语、句柄的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒+ γ，则称γ是句型αγβ的相对于非终结符A的&#96;短语&#96; 。</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒ γ，则称γ是句型αγβ的相对于规则A→γ的&#96;直接(简单)短语&#96;。</span><br><span class="line">直接短语中的最左直接短语为该句型的句柄。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">短语：</span><br><span class="line">一个句型的分析树中的每一棵子树的边缘(所有叶节点)所组成的符号串称为该句型的一个短语(phrase)。 </span><br><span class="line">直接短语：</span><br><span class="line">如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语(immediate phrase)；</span><br><span class="line">所有子树中，深度为2的子树的叶子节点串就是直接短语（因为直接短语必须是由子树根节点用一步推出来的，所以深度为2）；</span><br><span class="line">即如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。</span><br><span class="line"></span><br><span class="line">句柄：</span><br><span class="line">“可规约串”，句柄对应某个产生式的右部，是某个，但不是任意一个。</span><br><span class="line">作为一种规约对象，句柄表示最左直接短语。</span><br><span class="line">语法树： 在语法树上，则表示为最左边的只包含相邻父子节点的短语（最左直接短语）</span><br></pre></td></tr></table></figure>

<p>素短语和最左素短语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">素短语：</span><br><span class="line">是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象。</span><br><span class="line">语法树：通过语法树分析时，要注意先判断是否为素短语，再找相对最左端的素短语。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">素短语 ：</span><br><span class="line">指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line">从短语集合中找出所有含有终结符的短语，然后选出除它自身之外不再含更小的素短语。</span><br><span class="line">（这个小的概念是集合中没有被包含的元素，如有两个短语aAA和aAAA，aAA含于aAAA，所以aAA比aAAA小）</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">从素短语集合中找出最左边的素短语。</span><br></pre></td></tr></table></figure>

<h2 id="2-7文法实用中的一些说明"><a href="#2-7文法实用中的一些说明" class="headerlink" title="2.7文法实用中的一些说明"></a>2.7文法实用中的一些说明</h2><h3 id="2-7-1-有关文法的实用限制"><a href="#2-7-1-有关文法的实用限制" class="headerlink" title="2.7.1 有关文法的实用限制"></a>2.7.1 有关文法的实用限制</h3><p>文法中不得含有<em>有害规则</em> 和<em>多余规则</em></p>
<ul>
<li><p>有害规则：形如U→U的产生式。会引起文法的二义性</p>
</li>
<li><p>多余规则：指文法中任何句子的推导都不会用到的规则</p>
<p>1）文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达</p>
<p>2）文法中某些非终结符，由它不能推出终结符号串来，称为不可终止的</p>
</li>
</ul>
<p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p>
<p>​        1）A必须在某句型中出现。</p>
<p>​        2）必须能从A推出终结符号串t来。</p>
<h3 id="2-7-2-上下文无关文法中的ε规则"><a href="#2-7-2-上下文无关文法中的ε规则" class="headerlink" title="2.7.2 上下文无关文法中的ε规则"></a>2.7.2 上下文无关文法中的ε规则</h3><p>具有形式A→ε的规则称为ε规则，其中A∈VN</p>
<p>某些著作和讲义中限制这种规则的出现。因为ε规则会使有关文法的一些讨论和证明变得复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理（1）编译概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:05:01" itemprop="dateCreated datePublished" datetime="2020-05-31T11:05:01+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:00:35" itemprop="dateModified" datetime="2020-08-01T09:00:35+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h3 id="1-1-程序设计语言"><a href="#1-1-程序设计语言" class="headerlink" title="1.1 程序设计语言"></a>1.1 程序设计语言</h3><p>Machine Code</p>
<p>Assembly Language</p>
<p>High-level Language</p>
<p>如Algol, Fortran, Pascal, C语言等。</p>
<h3 id="1-2-什么叫编译程序"><a href="#1-2-什么叫编译程序" class="headerlink" title="1.2 什么叫编译程序"></a>1.2 什么叫编译程序</h3><p>翻译程序：就是将源程序转换成目标程序的程序。</p>
<p>source program —–&gt;  Translator  ——&gt;  target program</p>
<p>翻译程序和解释程序的区别：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" alt="1"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" class="" title="This is image1">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释方式最终不生成目标程序，这是编译方式和解释方式的根本区别。</span><br><span class="line">编译方式：是将源程序经编译得到可执行文件后，就可脱离源程序和编译程序单独执行，所以编译方式的效率高，执行速度快；</span><br><span class="line">解释方式：在执行时，必须源程序和解释程序同时参与才能运行，其不产生可执行程序文件，效率低，执行速度慢。</span><br></pre></td></tr></table></figure>

<p>编译程序和汇编程序的区别：</p>
<p>​        如果源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，这样的一个翻译程序称为编译程序。如果源语言是汇编语言，而目标语言是机器语言，这样的一个翻译程序称为汇编程序。</p>
<p>解释性语言：</p>
<p>（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行：  源代码—&gt;中间代码—&gt;机器语言</p>
<p>（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；</p>
<p>（3）解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；</p>
<p>（4）运行效率一般相对比较低，依赖解释器，跨平台性好；</p>
<p>（5）Java是编译性-解释性语言，因为其同时具备编译性和解释性两种特性。</p>
<h3 id="1-3-编译程序的组成"><a href="#1-3-编译程序的组成" class="headerlink" title="1.3 编译程序的组成"></a>1.3 编译程序的组成</h3><p>一个典型的编译程序应具有以下的组成：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" alt="2"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" class="" title="This is image2">

<p>编译程序的两个主要任务：</p>
<p>一是分析，二是综合。</p>
<p>编译程序结构(components)</p>
<ul>
<li>词法分析程序</li>
<li>语法分析程序</li>
<li>语义分析程序</li>
<li>中间代码生成程序</li>
<li>代码优化程序</li>
<li>目标代码生成程序</li>
<li>符号表管理程序</li>
<li>出错处理程序</li>
</ul>
<p>（1）Scanner （词法分析）</p>
<p>任务：识别单词符号，是最初级的语法分析。</p>
<p>依循的规则：语言的构词规则。</p>
<p>（2）Parser （语法分析）</p>
<p>任务∶对词法分析的输出即单词符号串进行分析，识别出一个个语法成分，并进行语法检查。</p>
<p>依循的规则：语法规则。</p>
<p>（语法单位：算术表达式、短语、句子、子程序……）</p>
<p>（3）Semantic Analyzer （语义分析）</p>
<p>任务：对语法分析所识别的各种语法成分的意义(即语义)进行确定并加以处理。</p>
<p>依循的规则：语义规则</p>
<p>（4）Intermediate Code Generator</p>
<p>任务：从源程序的树形或其它形式，产生源程序的中间代码。</p>
<p>中间代码：四元式、三元式……</p>
<p>（5）Target Code Generator</p>
<p>任务：将中间代码转换成汇编程序或者机器语言。</p>
<p>（6）代码优化</p>
<p>代码优化程序的功能是将中间代码中重复和冗余部分进行优化，提高目标程序的执行效率。</p>
<p>（7）符号表管理</p>
<ul>
<li>符号表管理是一个贯穿编译全过程的工作。</li>
<li>编译程序在分析源程序时，需要记录标识符的各种属性信息；</li>
<li>在语义分析和代码生成阶段，还要对建立的符号表进行检索，提取相应的属性信息。–类型、作用域、分配存储信息</li>
</ul>
<p>（8）Error Handler （错误检测及处理）</p>
<ul>
<li>错误可发生在编译的各个阶段，错误处理也是贯穿编译全过程。</li>
<li>词法分析阶段可查出的错误，如标识符的组成不符合词法规则； </li>
<li>语句结构错误是在语法分析中可查出的错误；</li>
<li>语义分析阶段可查出的错误，即结构正确，但所涉及的操作无意义或错误。</li>
<li>在编译时查出的，叫Comple-time error，在运行时表现才表现出来的错误叫Run-time error。</li>
</ul>
<p>（9）前端和后端</p>
<ul>
<li>前端包括编译逻辑结构中的分析部分，即词法分析、语法分析、语义分析和中间代码生成，除此还包括符号表建造及相应分析中的错误处理以及与机器无关的优化部分。</li>
<li>后端包括与目标机有关的部分，即综合部分，它包括目标代码生成及生成期间对符号表的相应检索操作和错误处理操作，以及与机器相关的代码优化部分。</li>
<li>将编译系统划分为前后端，有利于移植编译系统和利用后端为同一目标机配置不同语言的编译系统。</li>
</ul>
<p>（10）遍（pass）</p>
<p>​        对源程序(或其中间形式)从头至尾扫描一次并进行有关加工处理，生成新的中间形式或最终目标程序，称为一遍。</p>
<p>分遍原则∶</p>
<ul>
<li>目标质量高低(高则多遍) </li>
<li>机器内存大小(小则多遍)</li>
<li>源语言简繁(繁则多遍)</li>
<li>设计人员多少(多则多遍)</li>
</ul>
<p>多遍扫描编译程序的优缺点∶</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：（1）可以减少内存容量的需求，分便后，以遍为单位分别调用编译的各个子程序，各遍程序可以相互覆盖；</span><br><span class="line">（2）可使各遍的编译程序相互独立，结构清晰；</span><br><span class="line">（3）能够进行充分的优化，产生高质量的目标程序；</span><br><span class="line">（4）可将编译程序分为“前端”和“后端”，有利于编译程序的移植。</span><br><span class="line">缺点：每遍都要读符号、送符号，增加了许多重复性工作，降低了编译效率。</span><br></pre></td></tr></table></figure>

<h3 id="1-4-编译程序的生成"><a href="#1-4-编译程序的生成" class="headerlink" title="1.4 编译程序的生成"></a>1.4 编译程序的生成</h3><p><strong>实现工具：</strong>Low-level Language；</p>
<p>​                   High-level Language；</p>
<p>​                   Automatic Builder。</p>
<p><strong>生成方法：</strong>Self-compiler;</p>
<p>​                   transplant</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">python基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-30T00:00:00+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-31 11:03:35" itemprop="dateModified" datetime="2020-05-31T11:03:35+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><hr>
<h4 id="python常用数据类型"><a href="#python常用数据类型" class="headerlink" title="python常用数据类型"></a>python常用数据类型</h4><p>1）在python中变量不直接存储值，而是存储值的内存地址或引用</p>
<p>2）在python中，不需要事先声明变量名及其类型，使用赋值语句可以直接创建任意类型的变量，变量的类型取决于等号右侧表达式值的类型。</p>
<p>3）赋值（比如a=’ABC’）时，python解释器干了两件事：</p>
<p>​                在内存中创建一个 ‘ABC’ 的字符串；</p>
<p>​                在内存中创建一个名为a的变量，并把它指向 ‘ABC’</p>
<h4 id="python的核心数据类型"><a href="#python的核心数据类型" class="headerlink" title="python的核心数据类型"></a>python的核心数据类型</h4><h5 id="（1）Number（数字）"><a href="#（1）Number（数字）" class="headerlink" title="（1）Number（数字）"></a>（1）Number（数字）</h5><p>python支持int、float、complex三种不同的数字类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;b = <span class="number">3.14</span></span><br><span class="line">&gt;&gt;&gt;c = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line">&gt;&gt;&gt;print(type(a), type(b), type(c))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; &lt;<span class="title">class</span> '<span class="title">float</span>'&gt; &lt;<span class="title">class</span> '<span class="title">complex</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">isinstance</span><span class="params">(a, int)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">print(math.factorial(<span class="number">32</span>))  <span class="comment">#计算32的阶乘</span></span><br><span class="line">print(<span class="number">0.4</span><span class="number">-0.3</span> == <span class="number">0.1</span>)      <span class="comment">#false 实数之间尽量避免直接比较大小</span></span><br><span class="line">print(math.isclose(<span class="number">0.4</span><span class="number">-0.3</span>, <span class="number">0.1</span>)) <span class="comment">#true 测试两个实数是否足够接近</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">3</span>+<span class="number">4j</span></span><br><span class="line">print(c+c)   <span class="comment">#复数相加</span></span><br><span class="line">print(c.real)  <span class="comment">#查看复数的实部</span></span><br><span class="line">print(c.imag)  <span class="comment">#查看复数的虚部</span></span><br><span class="line">print(<span class="number">3</span>+<span class="number">4j</span>.imag) <span class="comment">#相当于3+(4j).imag</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）String（字符串）"><a href="#（2）String（字符串）" class="headerlink" title="（2）String（字符串）"></a>（2）String（字符串）</h5><p>python中的字符串可以使用单引号、双引号和三引号括起来，使用反斜杠 \ 转义特殊字符</p>
<p>python3源码文件默认以UTF-8编码，所有字符串都是Unicode字符串</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'''Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.'''</span></span><br><span class="line"></span><br><span class="line">print(len(text))            <span class="comment">#字符串长度，即所有字符的数量</span></span><br><span class="line">print(text.count(<span class="string">'is'</span>))     <span class="comment">#字符串中单词is出现的次数</span></span><br><span class="line">print(<span class="string">'beautiful'</span> <span class="keyword">in</span> text)  <span class="comment">#测试字符串中是否包含单词beautiful(大小写敏感)</span></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">20</span>)   			<span class="comment">#字符串重复</span></span><br><span class="line">print(<span class="string">'Good '</span>+<span class="string">'Morning'</span>)    <span class="comment">#字符串连接</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）List（列表）"><a href="#（3）List（列表）" class="headerlink" title="（3）List（列表）"></a>（3）List（列表）</h5><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字、字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在[]之间，用逗号分隔开的元素列表。</p>
<p>列表索引值以 0 为开始值，-1为从末尾的开始位置。</p>
<p>列表可以使用+操作符进行拼接，使用*表示重复。</p>
<h5 id="（4）Tuple（元组）"><a href="#（4）Tuple（元组）" class="headerlink" title="（4）Tuple（元组）"></a>（4）Tuple（元组）</h5><p>tuple 和 list 类似，不同之处在于tuple的元素不能修改。tuple 写在小括号里，元素之间用逗号隔开。（注：定义只有1个元素的tuple，必须加逗号）</p>
<p>元组的元素不可变，但可以包含可变对象，如 list。</p>
<h5 id="（5）dict（字典）"><a href="#（5）dict（字典）" class="headerlink" title="（5）dict（字典）"></a>（5）dict（字典）</h5><p>字典是无序的对象集合，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p>键（key）必须使用不可变类型。</p>
<p>同一个字典中，键（key）必须是唯一的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michacl'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">65</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michacl'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 16:22:53" itemprop="dateCreated datePublished" datetime="2020-05-25T16:22:53+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-30 23:19:06" itemprop="dateModified" datetime="2020-07-30T23:19:06+08:00">2020-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#generate 生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#server 启动服务器。在本地预览效果，默认情况下，访问网址为： http://localhost:4000/</span></span><br><span class="line">hexo d <span class="comment">#deploy 部署网站同步到github。部署网站前，需要预先生成静态文件</span></span><br><span class="line">hexo clean <span class="comment">#clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span></span><br></pre></td></tr></table></figure>

<h5 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h5><p>删除那篇文章，然后重新运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Daphne Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daphne Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"artemisaturn.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://artemisaturn.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Daphne Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://artemisaturn.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/09/20/%E9%87%8D%E7%87%83project/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/20/%E9%87%8D%E7%87%83project/" class="post-title-link" itemprop="url">重燃project</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-20 09:34:14" itemprop="dateCreated datePublished" datetime="2020-09-20T09:34:14+08:00">2020-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-29 18:17:07" itemprop="dateModified" datetime="2020-10-29T18:17:07+08:00">2020-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><em>没接触过diango啊，从零开始学起吧，边解决问题边学习。</em></p>
<h3 id="部署时连不到数据库"><a href="#部署时连不到数据库" class="headerlink" title="部署时连不到数据库"></a>部署时连不到数据库</h3><p>把MySQL服务关掉可以解决。猜测是127.0.0.1连接问题。</p>
<h2 id="task1：前端用户注册改为手机号验证"><a href="#task1：前端用户注册改为手机号验证" class="headerlink" title="task1：前端用户注册改为手机号验证"></a>task1：前端用户注册改为手机号验证</h2><h3 id="源代码学习"><a href="#源代码学习" class="headerlink" title="源代码学习"></a>源代码学习</h3><p><em>urls.py</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'login'</span>, views.LoginView.as_view()),</span><br><span class="line">    path(<span class="string">'register'</span>, views.RegisterView.as_view()),</span><br><span class="line">    path(<span class="string">'index'</span>, views.IndexView.as_view()),</span><br><span class="line">    path(<span class="string">'mypage'</span>, views.UpdateView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>urlpatterns</strong> 在url文件中是一个url映射列表。系统会自动遍历url文件中的urlpatterns列表然后进行对应的处理函数查找。当url有重复的情况则以找到的第一个为准。</p>
<p><strong>Django怎么处理请求：</strong></p>
<ul>
<li>一旦生成url页面请求，请求传递到urls.py；</li>
<li>Django去urlpatterns中匹配链接（Django会在匹配到的第一个就停下来）；</li>
<li>一旦匹配成功，就会去执行，path后面的方法，Django便会给出相应的view页面（该页面可以为一个Python的函数，或者基于view（Django内置的）的类），也就是用户看到的页面；</li>
<li>若匹配失败，则出现错误的页面。</li>
</ul>
<p><strong>as_view()方法：</strong></p>
<ol>
<li>前端发送请求，方法可能是post或get</li>
<li>url()定位到类(view)方法as_view()</li>
<li>as_view()返回一个view方法，view转到dispatch()</li>
<li>dispatch()会自动判断当前的请求方式</li>
</ol>
<p><em>models.py</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebUser</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""网站用户表，主要用于衡量职工是否可以注册自己的账户并访问数据库网站"""</span></span><br><span class="line">    nickname = models.CharField(max_length=<span class="number">64</span>, verbose_name=<span class="string">'昵称'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    realname = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">'真实姓名'</span>, help_text=<span class="string">'员工的名字'</span>, db_index=<span class="literal">True</span>)</span><br><span class="line">    gender_choices = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'未知'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'男'</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">'女'</span>),</span><br><span class="line">    )</span><br><span class="line">    gender = models.IntegerField(choices=gender_choices, verbose_name=<span class="string">'性别'</span>, default=<span class="number">0</span>)</span><br><span class="line">    idcard = models.CharField(max_length=<span class="number">18</span>, verbose_name=<span class="string">'身份证号'</span>, help_text=<span class="string">'18位的身份证号码'</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">11</span>, verbose_name=<span class="string">'手机号'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">64</span>, verbose_name=<span class="string">'密码'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    email = models.EmailField(max_length=<span class="number">64</span>, verbose_name=<span class="string">'邮箱'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    birthday = models.DateField(verbose_name=<span class="string">'生日'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    department = models.ForeignKey(to=Department, on_delete=models.CASCADE, blank=<span class="literal">False</span>, null=<span class="literal">True</span>, verbose_name=<span class="string">'部门'</span>, db_index=<span class="literal">True</span>)</span><br><span class="line">    enable = models.BooleanField(verbose_name=<span class="string">'状态'</span>, default=<span class="literal">True</span>)</span><br><span class="line">    create_time = models.DateTimeField(verbose_name=<span class="string">'创建时间'</span>, auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    update_time = models.DateTimeField(verbose_name=<span class="string">'更新时间'</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">"员工"</span></span><br><span class="line">        verbose_name_plural = <span class="string">"员工管理"</span></span><br><span class="line">        db_table = <span class="string">"T_WebUser"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.realname</span><br></pre></td></tr></table></figure>

<p><strong>表字段及说明</strong></p>
<table>
<thead>
<tr>
<th>表字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>models.AutoField</td>
<td>默认会生成一个名为id的字段并未int类型</td>
</tr>
<tr>
<td>models.CharField</td>
<td>字符串类型</td>
</tr>
<tr>
<td>models.BooleanField</td>
<td>布尔类型</td>
</tr>
<tr>
<td>models.DateField</td>
<td>日期（Date）类型</td>
</tr>
<tr>
<td>models.DateTimeField</td>
<td>日期（datetime）类型</td>
</tr>
<tr>
<td>models.EmailField</td>
<td>字符串类型（正则表达式邮箱）</td>
</tr>
<tr>
<td>models.FloatField</td>
<td>浮点类型</td>
</tr>
<tr>
<td>models.IntegerField</td>
<td>整数类型</td>
</tr>
<tr>
<td>models.TextField</td>
<td>长文本类型</td>
</tr>
<tr>
<td>models. TimeField</td>
<td>时间类型， 显示时分秒HH:MM[:ss[ .uuuuuu]]</td>
</tr>
<tr>
<td>models. URLField</td>
<td>字符串， 地址为正则表达式</td>
</tr>
<tr>
<td>models.FilePathField</td>
<td>Django Admin以及ModelForm中提供读取文件夹下文件的功能<br />参数：<br />        path：文件夹路径<br />        match=None：正则匹配<br />        recursive=False：递归下面的文件夹<br />        allow_files=True：允许文件<br />        allow_folders=False：允许文件夹</td>
</tr>
<tr>
<td>models.FileField</td>
<td>路径保存在数据库，文件上传到指定目录<br />参数：<br />        upload_to = “”          上传文件的保存路径<br />        storage = None         存储组件，默认django.core.files.storage.FileSystemStorage</td>
</tr>
<tr>
<td>models.ForeignKey(other_table)</td>
<td>创建外键(即创建一对多的表的关联)<br />参数:<br />        to=:          要进行关联的表名<br />        to_field=:     要关联的表中的字段名称<br />        on_delete=:   当删除关联表中的数据时，当前表与其关联的行的行为<br />        on_delete的参数:<br />               - models.CASCADE          删除关联数据，与之关联也删除<br />               - models.DO_NOTHING       删除关联数据，引发错误IntegrityError<br />               - models.PROTECT          删除关联数据，引发错误ProtectedError<br />               - models.SET_NULL          删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）<br />               - models.SET_DEFAULT      删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）<br />               - models.SET               删除关联数据</td>
</tr>
</tbody></table>
<p><strong>表字段参数及说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>数据库中字段是否可以为空</td>
</tr>
<tr>
<td>db_column</td>
<td>数据库中字段的列名</td>
</tr>
<tr>
<td>db_tablespace</td>
<td>表空间，如果该字段已经创建了索引，那么数据库表空间的名称将作为该字段的索引名。</td>
</tr>
<tr>
<td>default</td>
<td>数据库中字段的默认值</td>
</tr>
<tr>
<td>primary_key</td>
<td>数据库中字段是否为主键</td>
</tr>
<tr>
<td>db_index</td>
<td>数据库中字段是否可以建立索引</td>
</tr>
<tr>
<td>unique</td>
<td>数据库中字段是否可以建立唯一索引</td>
</tr>
<tr>
<td>verbose_name</td>
<td>Admin中显示的字段名称</td>
</tr>
<tr>
<td>blank</td>
<td>Admin中是否允许用户输入为空</td>
</tr>
<tr>
<td>editable</td>
<td>Admin中是否可以编辑</td>
</tr>
<tr>
<td>help_text</td>
<td>Admin中该字段的提示信息</td>
</tr>
<tr>
<td>choices</td>
<td>Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作</td>
</tr>
<tr>
<td>error_messages</td>
<td>自定义错误信息(字典类型)从而,定制想要显示的错误信息</td>
</tr>
</tbody></table>
<p><strong>class Meta</strong></p>
<p>通过一个内嵌类 “class Meta” 给你的 model 定义元数据</p>
<ul>
<li>verbose_name：给你的模型类起一个更可读的名字</li>
<li>verbose_name_plural：模型的复数形式</li>
<li>db_table：用于指定自定义数据库表名</li>
</ul>
<p><em>views.py</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""注册"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        res = BaseResponse()</span><br><span class="line">        <span class="comment">#nickname = request.data.get('nickname')</span></span><br><span class="line">        realname = request.data.get(<span class="string">'realname'</span>)</span><br><span class="line">        idcard = request.data.get(<span class="string">'idcard'</span>)</span><br><span class="line">        <span class="comment">#password = request.data.get('password')</span></span><br><span class="line">        user_obj = models.WebUser.objects.filter(realname=realname)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> user_obj.exists():</span><br><span class="line">            <span class="comment">#返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">10020</span>, <span class="string">'message'</span>: <span class="string">'您没有注册权限！请联系管理员申请！'</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> user <span class="keyword">in</span> user_obj:</span><br><span class="line">                <span class="keyword">if</span> user.idcard[<span class="number">-6</span>:] == idcard:</span><br><span class="line">                    serializer = serializers.RegisterSerializer(user, data=request.data)</span><br><span class="line">                    <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">                        user = serializer.save()</span><br><span class="line">                    <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'message'</span>: <span class="string">''</span>, <span class="string">'data'</span>: res.data&#125;)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment">#返回错误信息</span></span><br><span class="line">                    <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">10050</span>, <span class="string">'message'</span>: <span class="string">'您的身份证后六位输入错误，请重新输入！'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>先判断数据库中是否有该员工，是否有注册权限。</p>
<p>然后根据身份证后6位验证。</p>
<p>调用serializers.RegisterSerializer，update实例。</p>
<p>判断serializer是否实例化，修改user实例。</p>
<p><strong>表操作</strong></p>
<p>增</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method1</span></span><br><span class="line">models.Host.objects.create(hostname=<span class="string">'xx'</span>,ip=<span class="string">'xx'</span>,...)  <span class="comment">#增加一条数据，可以接受字典类型数据 **kwargs</span></span><br><span class="line"><span class="comment"># method2</span></span><br><span class="line">obj = models.Host(hostname=<span class="string">'xx'</span>,ip=<span class="string">'xx'</span>,...)</span><br><span class="line">obj.save()</span><br></pre></td></tr></table></figure>

<p>删</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">models.Host.objects.filter(hostname=<span class="string">'xxx'</span>).delete()       <span class="comment">#删除指定条件的数据</span></span><br></pre></td></tr></table></figure>

<p>改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">models.Host.objects.filter(hostname=<span class="string">'xx'</span>).update(ip=<span class="string">'xxx'</span>)  <span class="comment">#将指定条件的数据更新，均支持 **kwargs</span></span><br><span class="line">obj = models.Host.objects.get(id=<span class="number">1</span>)</span><br><span class="line">obj.ip = <span class="string">'xx'</span></span><br><span class="line">obj.save()                                                  <span class="comment">#修改单条数据</span></span><br></pre></td></tr></table></figure>

<p>查</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">models.Tb1.objects.get(id=<span class="number">1</span>)                         <span class="comment"># 获取单条数据，不存在则报错(不建议使用)</span></span><br><span class="line">models.Tb1.objects.all()                             <span class="comment"># 获取全部</span></span><br><span class="line">models.Tb1.objects.filter(name=<span class="string">'seven'</span>).first()      <span class="comment"># 获取指定条件的数据</span></span><br></pre></td></tr></table></figure>

<p><em>serializers.py</em></p>
<h3 id="改动"><a href="#改动" class="headerlink" title="改动"></a>改动</h3><p>首先修改前端</p>
<p>后端：</p>
<p><em>views.py</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idcard = request.data.get(<span class="string">'idcard'</span>)</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone = request.data.get(<span class="string">'phone'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.idcard[<span class="number">-6</span>:] == idcard:</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.phone[<span class="number">-4</span>:] == phone:</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证电话号码是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_phone</span><span class="params">(value)</span>:</span></span><br><span class="line">    p = re.compile(<span class="string">r'^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d&#123;8&#125;$'</span>)</span><br><span class="line">    <span class="keyword">if</span> p.match(value) == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(message=<span class="string">"电话号码不合法"</span>)</span><br><span class="line">    exists = WebUser.objects.filter(phone=value).exists()</span><br><span class="line">    <span class="keyword">if</span> exists:</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(message=<span class="string">"此手机号码已经被注册"</span>)</span><br><span class="line">        </span><br><span class="line">phone = models.CharField(max_length=<span class="number">11</span>, verbose_name=<span class="string">'手机号'</span>, validators=[validate_phone])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.phone[<span class="number">-4</span>:] == phone:</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    serializer = serializers.RegisterSerializer(user, data=request.data)</span></span><br><span class="line"><span class="string">    if serializer.is_valid():</span></span><br><span class="line"><span class="string">        user = serializer.save()</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    user.nickname = request.data.get(<span class="string">'nickname'</span>, user.nickname)</span><br><span class="line">    exists = models.WebUser.objects.filter(nickname=user.nickname).exists()</span><br><span class="line">    <span class="keyword">if</span> exists:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">10040</span>, <span class="string">'message'</span>: <span class="string">'该用户名已存在，请重新输入！'</span>&#125;)</span><br><span class="line">    hash_key = <span class="string">'password'</span></span><br><span class="line">    password = request.data.get(<span class="string">'password'</span>) + hash_key</span><br><span class="line">    password_md5 = hashlib.md5(password.encode()).hexdigest()</span><br><span class="line">    user.password = password_md5</span><br><span class="line">    user.save()</span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'message'</span>: <span class="string">''</span>, <span class="string">'data'</span>: res.data&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#返回错误信息</span></span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">10050</span>, <span class="string">'message'</span>: <span class="string">'您的电话号码后四位输入错误，请重新输入！'</span>&#125;)</span><br></pre></td></tr></table></figure>



<p>前端：npm run dev 报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">you can run: npm install --save !!vue-styles-loader!css-loader?</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader --save</span><br><span class="line">npm install node-sass --save</span><br></pre></td></tr></table></figure>

<p>意见反馈表models.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> extra_apps.DjangoUeditor.models <span class="keyword">import</span> UEditorField</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"意见反馈表"</span></span><br><span class="line">    feedback = UEditorField(verbose_name=<span class="string">"反馈意见"</span>, imagePath=<span class="string">"articles/images/"</span>+<span class="string">"/%(basename)s_%(basename)s_%(datetime)s.%(extname)s"</span>, width=<span class="number">1000</span>, height=<span class="number">300</span>,</span><br><span class="line">                            filePath=<span class="string">"articles/files/"</span>, default=<span class="string">''</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">'留言人'</span>, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line">    ip_address = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">'IP地址'</span>, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line">    time = models.DateTimeField(verbose_name=<span class="string">'留言时间'</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">"意见反馈"</span></span><br><span class="line">        verbose_name_plural = <span class="string">"意见反馈"</span></span><br><span class="line">        db_table = <span class="string">"T_Feedback"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.id)</span><br></pre></td></tr></table></figure>

<p>admin.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> FeedbackTable</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(FeedbackTable)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'feedback'</span>, <span class="string">'username'</span>, <span class="string">'ip_address'</span>, <span class="string">'time'</span>)</span><br><span class="line">    search_fields = (<span class="string">'feedback'</span>, <span class="string">'username'</span>)</span><br><span class="line">    list_per_page = <span class="number">20</span></span><br><span class="line">    list_filter = (<span class="string">'ip_address'</span>, <span class="string">'time'</span>)</span><br></pre></td></tr></table></figure>

<p>urls.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'feedback'</span>, views.FeedbackView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> apps.Feedback <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""意见反馈"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        feedback = request.POST.get(<span class="string">'feedback'</span>)</span><br><span class="line">        <span class="keyword">if</span> feedback <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">1010</span>, <span class="string">'message'</span>: <span class="string">'留言不能为空！'</span>&#125;)</span><br><span class="line">        username = request.POST.get(<span class="string">'username'</span>)</span><br><span class="line">        ip_address = self.get_ip(request)</span><br><span class="line">        models.FeedbackTable.objects.create(</span><br><span class="line">            feedback = feedback,</span><br><span class="line">            username = username,</span><br><span class="line">            ip_address = ip_address</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'message'</span>: <span class="string">'留言成功！感谢您的建议'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ip</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="string">'''获取请求者的IP信息'''</span></span><br><span class="line">        x_forwarded_for = request.META.get(<span class="string">'HTTP_X_FORWARDED_FOR'</span>)  <span class="comment"># 判断是否使用代理</span></span><br><span class="line">        <span class="keyword">if</span> x_forwarded_for:</span><br><span class="line">            ip = x_forwarded_for.split(<span class="string">','</span>)[<span class="number">0</span>]  <span class="comment"># 使用代理获取真实的ip</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip = request.META.get(<span class="string">'REMOTE_ADDR'</span>)  <span class="comment"># 未使用代理获取IP</span></span><br><span class="line">        <span class="keyword">return</span> ip</span><br></pre></td></tr></table></figure>

<p>Feedback</p>
<p>models.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> extra_apps.DjangoUeditor.models <span class="keyword">import</span> UEditorField</span><br><span class="line"><span class="keyword">from</span> ckeditor_uploader.fields <span class="keyword">import</span> RichTextUploadingField</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackTable</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"意见反馈表"</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>, verbose_name=<span class="string">"标题"</span>, default=<span class="string">''</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">32</span>, verbose_name=<span class="string">'留言人'</span>, blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line">    content = RichTextUploadingField(verbose_name=<span class="string">'反馈内容'</span>, default=<span class="string">''</span>)</span><br><span class="line">    <span class="comment"># files = models.ManyToManyField(Files, related_name='files')</span></span><br><span class="line">    status_choices = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'已接收'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'已反馈'</span>),</span><br><span class="line">        (<span class="number">2</span>, <span class="string">'处理中'</span>),</span><br><span class="line">        (<span class="number">3</span>, <span class="string">'已完成'</span>),</span><br><span class="line">        (<span class="number">4</span>, <span class="string">'忽视'</span>)</span><br><span class="line">    )</span><br><span class="line">    status = models.IntegerField(choices=status_choices, verbose_name=<span class="string">'状态'</span>, default=<span class="number">0</span>)</span><br><span class="line">    time = models.DateTimeField(verbose_name=<span class="string">'留言时间'</span>, auto_now=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">"意见反馈"</span></span><br><span class="line">        verbose_name_plural = <span class="string">"意见反馈"</span></span><br><span class="line">        db_table = <span class="string">"T_Feedback"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.id)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Files</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    file = models.FileField(upload_to=<span class="string">'feedback/file/%Y-%m-%d/'</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>, verbose_name=<span class="string">"添加附件"</span>)</span><br><span class="line">    feedback = models.ForeignKey(to=FeedbackTable, on_delete=models.CASCADE, verbose_name=<span class="string">"feedback_id"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">"反馈附件"</span></span><br><span class="line">        verbose_name_plural = <span class="string">"反馈附件"</span></span><br><span class="line">        db_table = <span class="string">"T_FeedbackFiles"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.id)</span><br></pre></td></tr></table></figure>

<p>admin.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> FeedbackTable, Files</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesInline</span><span class="params">(admin.TabularInline)</span>:</span></span><br><span class="line">    model = Files</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_extra</span><span class="params">(self, request, obj=None, **kwargs)</span>:</span></span><br><span class="line">        extra = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> extra</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(FeedbackTable)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'content'</span>, <span class="string">'username'</span>, <span class="string">'status'</span>, <span class="string">'time'</span>)</span><br><span class="line">    search_fields = (<span class="string">'title'</span>, <span class="string">'content'</span>, <span class="string">'username'</span>)</span><br><span class="line">    list_per_page = <span class="number">20</span></span><br><span class="line">    list_filter = (<span class="string">'status'</span>, <span class="string">'time'</span>)</span><br><span class="line">    inlines = [FilesInline]</span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(Files)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = (<span class="string">'id'</span>, <span class="string">'file'</span>, <span class="string">'feedback'</span>)</span><br></pre></td></tr></table></figure>

<p>views.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> apps</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> apps.Feedback <span class="keyword">import</span> models, serializers</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> StreamingHttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">"""意见反馈"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>)</span><br><span class="line">        <span class="comment">#if title is None:</span></span><br><span class="line">        <span class="comment">#    return Response(&#123;'code': 1010, 'message': '标题不能为空！'&#125;)</span></span><br><span class="line">        content = request.POST.get(<span class="string">'content'</span>)</span><br><span class="line">        <span class="comment">#if feedback is None:</span></span><br><span class="line">        <span class="comment">#    return Response(&#123;'code': 1011, 'message': '内容不能为空！'&#125;)</span></span><br><span class="line">        username = request.POST.get(<span class="string">'name'</span>, <span class="literal">None</span>)</span><br><span class="line">        files = request.FILES.getlist(<span class="string">'file'</span>)</span><br><span class="line">        <span class="comment"># ip_address = self.get_ip(request)</span></span><br><span class="line">        feedback = models.FeedbackTable()</span><br><span class="line">        feedback.title = title</span><br><span class="line">        feedback.content = content</span><br><span class="line">        feedback.username = username</span><br><span class="line">        feedback.save()</span><br><span class="line">        <span class="keyword">if</span> files <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">                file = models.Files()</span><br><span class="line">                file.file = f</span><br><span class="line">                file.feedback = feedback.id</span><br><span class="line">                file.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'message'</span>: <span class="string">'提交成功！感谢您的建议'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    def get_ip(request):</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')  # 判断是否使用代理</span></span><br><span class="line"><span class="string">        if x_forwarded_for:</span></span><br><span class="line"><span class="string">            ip = x_forwarded_for.split(',')[0]  # 使用代理获取真实的ip</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            ip = request.META.get('REMOTE_ADDR')  # 未使用代理获取IP</span></span><br><span class="line"><span class="string">        return ip</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetBasicInformation</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取意见反馈表中的id，标题，用户名，时间，状态</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        feedback = models.FeedbackTable.objects.all()</span><br><span class="line">        res = serializers.FeedbackSerializers(feedback, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(res.data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetContentAndFiles</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    获取详细内容和附件</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        id = request.data.get(<span class="string">'id'</span>)</span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        filepath = []</span><br><span class="line">        filename = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 获取内容</span></span><br><span class="line">            feedback_obj = models.FeedbackTable.objects.get(id=id)</span><br><span class="line">            content = feedback_obj.content</span><br><span class="line">            res[<span class="string">'content'</span>] = content</span><br><span class="line">            <span class="comment"># 获取文件</span></span><br><span class="line">            file_obj = models.Files.objects.filter(feedback=feedback_obj)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> file_obj.exists():</span><br><span class="line">                <span class="comment"># 没有附件</span></span><br><span class="line">                res[<span class="string">'files'</span>] = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 存在附件</span></span><br><span class="line">                res[<span class="string">'files'</span>] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> f <span class="keyword">in</span> file_obj:</span><br><span class="line">                    file_path = str(f.file)</span><br><span class="line">                    file_name = file_path.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">                    filepath.append(file_path)</span><br><span class="line">                    filename.append(file_name)</span><br><span class="line">                    res[<span class="string">'filepath'</span>] = filepath</span><br><span class="line">                    res[<span class="string">'filename'</span>] = filename</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'message'</span>: <span class="string">''</span>, <span class="string">'data'</span>: res&#125;)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">10010</span>, <span class="string">'message'</span>: <span class="string">'该反馈意见不存在!'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileDown</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    下载文件</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        filename = request.data.get(<span class="string">'filename'</span>)</span><br><span class="line">        filepath = request.data.get(<span class="string">'filepath'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = StreamingHttpResponse(self.readFile(filepath))</span><br><span class="line">            response[<span class="string">'Content-Type'</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">            response[<span class="string">'Content-Disposition'</span>] = <span class="string">'attachment;filename="&#123;0&#125;"'</span>.format(filename)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">201</span>, <span class="string">'message'</span>: <span class="string">'没有找到该附件'</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readFile</span><span class="params">(filepath, chunk_size=<span class="number">512</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        缓冲流下载文件方法</span></span><br><span class="line"><span class="string">        :param filepath:</span></span><br><span class="line"><span class="string">        :param chunk_size:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">with</span> open(filepath, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                c = f.read(chunk_size)</span><br><span class="line">                <span class="keyword">if</span> c:</span><br><span class="line">                    <span class="keyword">yield</span> c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>serializers.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apps.Feedback <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeedbackSerializers</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="string">"反馈意见基本信息"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.FeedbackTable</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'username'</span>, <span class="string">'status'</span>, <span class="string">'time'</span>]</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/09/14/Linear-Algebra/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/Linear-Algebra/" class="post-title-link" itemprop="url">Linear Algebra</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-14 10:41:08 / 修改时间：22:30:20" itemprop="dateCreated datePublished" datetime="2020-09-14T10:41:08+08:00">2020-09-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、向量是什么？"><a href="#1、向量是什么？" class="headerlink" title="1、向量是什么？"></a>1、向量是什么？</h1><p>向量（Vector）是线性代数中最基础、最根源的组成部分。<br>$$<br>\text{三种观点} = \begin{cases}<br>                \text{physics student perspective}\<br>                \text{computer science student perspective}\<br>                \text{mathematician’s perspective}<br>          \end{cases}<br>$$</p>
<ul>
<li>从物理专业学生的视角看：向量是空间中的箭头，决定一个向量的是它的长度和它所指的方向，只要以上两个特征相同，你可以自由移动一个向量而保持它不变。</li>
<li>从计算机专业学生的视角看：向量是有序的数字列表。</li>
<li>数学家试图去概括这两种观点：a vector can be anything，只要保证两个向量相加以及数字与向量相乘是有意义的即可。</li>
</ul>
<p><strong>几何含义：</strong></p>
<p>向量相加：从第一个向量的起点出发，指向第二个向量的终点</p>
<p>向量数乘：向量的缩放（scaling）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/23/Taichi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/Taichi/" class="post-title-link" itemprop="url">Taichi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-23 23:09:03" itemprop="dateCreated datePublished" datetime="2020-08-23T23:09:03+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-05 09:55:44" itemprop="dateModified" datetime="2020-09-05T09:55:44+08:00">2020-09-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、The-Taichi-Programming-Language"><a href="#1、The-Taichi-Programming-Language" class="headerlink" title="1、The Taichi Programming Language"></a>1、The Taichi Programming Language</h1><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h3 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h3><p>Taichi is strongly typed. Supported basics types include:</p>
<ul>
<li>Signed integers:  ti.i8/i16/i32/i64</li>
<li>Unsigned integers:  ti.u8/u16/u32/u64</li>
<li>Float-point numbers:  ti.f32/f64</li>
</ul>
<h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Taichi is a data-oriented programming language where tensors are first-class citizens.</p>
<ul>
<li>Tensors are essentially multi-dimensional arrays.（在Taichi种，tensor和matrix是两个完全不同的概念）</li>
<li>An element of a tensor can be either a scalar(var), a vector(ti.Vector), or a matrix(ti.Matrix)</li>
<li>Tensor elements are always accessed via the a[i, j, k] syntax. (No pointers! 编译器不易优化)</li>
<li>Access out-of-bound is undefined behavior.</li>
<li>Tensors can be spatially  sparse.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init()</span><br><span class="line">a = ti.var(dt=ti.f32, shape=(<span class="number">42</span>, <span class="number">63</span>)) <span class="comment"># A tensor of 42x63 scalars</span></span><br><span class="line">b = ti.Vector(<span class="number">3</span>, dt=ti.f32, shape=<span class="number">4</span>) <span class="comment"># A tensor of 4x3D vectors</span></span><br><span class="line">C = ti.Matrix(<span class="number">2</span>, <span class="number">2</span>, dt=ti.f32, shape=(<span class="number">3</span>, <span class="number">5</span>)) <span class="comment"># A tensor pf 3x5 2x2 matrices</span></span><br><span class="line">loss = ti.var(dt=ti.f32, shape=()) <span class="comment"># A (0-D) tensor of a single scalar</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">3</span>, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'a[3, 4] = '</span>, a[<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># "a[3, 4] = 1.000000"</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">2</span>] = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(<span class="string">'b[0] ='</span>, b[<span class="number">0</span>][<span class="number">0</span>], b[<span class="number">0</span>][<span class="number">1</span>], b[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="comment"># print(b[0]) is not yet supported</span></span><br><span class="line"></span><br><span class="line">loss[<span class="literal">None</span>] = <span class="number">3</span> <span class="comment"># 没有下标</span></span><br><span class="line">print(loss[<span class="literal">None</span>]) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>a（标量张量）：有42x63个元素，每个元素是一个标量</p>
<p>b（向量张量）：tensor长度为4，向量有3个元素，4个3D vectors组成的张量</p>
<p>c（矩阵张量）：3x5的tensor，里面每个元素是一个2x2的矩阵</p>
<p>loss：0-D的张量，只有一个标量元素</p>
<h2 id="computation"><a href="#computation" class="headerlink" title="computation"></a>computation</h2><h3 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h3><p>Kernels——用来计算的函数。</p>
<ul>
<li>The language used in Taichi kernels and functions is similar to Python.（区别：该语言会被即时编译，Taichi自带一个编译器，把kernel里的语言编译成高性能kernel，能够运行的更快。）</li>
<li>The Taichi kernel lanuage is compiled, statically-typed, lexically-scoped, parallel and differentiable.</li>
<li>Kernels must be decorated with @ti.kernel.</li>
<li>Kernel arguments and return values must be type-hinted.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i: ti.i32)</span>:</span></span><br><span class="line">    a = <span class="number">40</span></span><br><span class="line">    print(<span class="string">'Hello world!'</span>, a + i)</span><br><span class="line">    </span><br><span class="line">hello(<span class="number">2</span>) <span class="comment"># Hello world! 42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">()</span> -&gt; ti.i32:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s  <span class="comment"># 45</span></span><br></pre></td></tr></table></figure>

<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Taichi Functions 可以被 Taichi Kernels 调用，但是Taichi Function 不能被 python 调用。（<strong>device</strong> functions；<strong>global</strong> kernels）</p>
<p>Taichi functions can be called by Taichi kernels and other Taichi functions. They must be decorated with @ti.func.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple_array</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">128</span>):</span><br><span class="line">        a[i] = triple(a[i])</span><br></pre></td></tr></table></figure>

<p>Taichi Function will be force-inlined. 暂时不支持递归。一个Taichi Function最多只能包含一条return statement。</p>
<h3 id="Matrices-and-linear-algebra"><a href="#Matrices-and-linear-algebra" class="headerlink" title="Matrices and linear algebra"></a>Matrices and linear algebra</h3><ul>
<li>ti.Matrix is for small matrices(e.g. 3x3) only.</li>
<li>ti.Vector is the same as ti.Matrix, except that it has only one column.</li>
</ul>
<p><strong>Note:</strong>  Differentiate element-wise product * and matrix product @</p>
<h4 id="Parallel-for-loops"><a href="#Parallel-for-loops" class="headerlink" title="Parallel for-loops"></a>Parallel for-loops</h4><p>For loops in Taichi have two forms:</p>
<ul>
<li><strong>Range-for loops</strong>, which are no different from Python for loops, except that it will be parallelized when used at the outermost scope. Range-for loops can be nested.</li>
<li><strong>Struct-for loops</strong>, which iterates over (sparse) tensor elements. </li>
</ul>
<p>For loops at the outermost scope in a Taichi kernel is <strong>automatically parallelized</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># Parallelized</span></span><br><span class="line">        x[i] += i</span><br><span class="line">        </span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):  <span class="comment"># Serialized in each parallel thread</span></span><br><span class="line">            s += j</span><br><span class="line">         </span><br><span class="line">        y[i] = s</span><br><span class="line">      </span><br><span class="line"><span class="meta">@ti,kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_3d</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Parallelized for all 3&lt;=i&lt;8, 1&lt;=j&lt;6, 0&lt;=k&lt;9</span></span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> ti.ndrange((<span class="number">3</span>, <span class="number">8</span>), (<span class="number">1</span>, <span class="number">6</span>), <span class="number">9</span>):</span><br><span class="line">        x[i, j, k] = i + j + k</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> It is the loop at the outermost scope that gets parallelized, not the outermost loop.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># Parallelized</span></span><br><span class="line">        ...</span><br><span class="line">      </span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(k: ti.i32)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">42</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># Serical</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<h4 id="Struct-for-loops"><a href="#Struct-for-loops" class="headerlink" title="Struct-for loops"></a>Struct-for loops</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"></span><br><span class="line">ti.init(arch=ti.gpu)</span><br><span class="line"></span><br><span class="line">n = <span class="number">320</span></span><br><span class="line">pixels = ti.var(dt=ti.f32, shape=(n * <span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(t: ti.f32)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> pixels:  <span class="comment"># Parallelized over all pixels</span></span><br><span class="line">        pixels[i, j] = i * <span class="number">0.001</span> + j * <span class="number">0.002</span> + t</span><br><span class="line">        </span><br><span class="line">paint(<span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><p>In Taichi, augmented assignments (e.g.  x[i] += 1) are automatically atomic.</p>
<p>When modifying global variables in parallel, make sure you use atomic operations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">	<span class="comment"># Approach 1: OK</span></span><br><span class="line">	total[<span class="literal">None</span>] += x[i]  <span class="comment"># total 0-D tensor</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment"># Approach 2: OK</span></span><br><span class="line">	ti.atomic_add(total[<span class="literal">None</span>], x[i])</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># Approach 3: Wrong result (the operation is not atomic .)</span></span><br><span class="line">	total[<span class="literal">None</span>] = total[<span class="literal">None</span>] + x[i]</span><br></pre></td></tr></table></figure>

<h3 id="Taichi-scope-v-s-Python-scope"><a href="#Taichi-scope-v-s-Python-scope" class="headerlink" title="Taichi-scope v.s. Python-scope"></a>Taichi-scope v.s. Python-scope</h3><p><strong>Definition：</strong></p>
<ul>
<li>Taichi-scope: Everything decorated with ti.kernel and ti.func.</li>
<li>Python-scope: Code outside the Taichi-scope.</li>
</ul>
<p><strong>Note：</strong></p>
<ul>
<li>Code in Taichi-scope will be compiled by the Taichi compiler and run on parallel devices.</li>
<li>Code in Python-scope is simply Python code and will be executed by the Python interpreter.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init()</span><br><span class="line"></span><br><span class="line">a = ti.var(dt=ti.f32, shape=(<span class="number">42</span>, <span class="number">63</span>)) <span class="comment"># A tensor of 42x63 scalars</span></span><br><span class="line">b = ti.Vector(<span class="number">3</span>, dt=ti.f32, shape=<span class="number">4</span>) <span class="comment"># A tensor of 4x3D vectors</span></span><br><span class="line">C = ti.Matrix(<span class="number">2</span>, <span class="number">2</span>, dt=ti.f32, shape=(<span class="number">3</span>,<span class="number">5</span>)) <span class="comment"># A tensor of 3x5 2x2 matrices</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a[<span class="number">3</span>, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'a[3, 4] ='</span>, a[<span class="number">3</span>, <span class="number">4</span>]) </span><br><span class="line">    <span class="comment"># a[3, 4] = 1.000000</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">2</span>] = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    print(<span class="string">'b[0] ='</span>, b[<span class="number">0</span>], <span class="string">', b[2] ='</span>, b[<span class="number">2</span>])</span><br><span class="line">    <span class="comment"># b[0] = [0.000000, 0.000000, 0.000000] , b[2] = [6.000000, 7.000000, 8.000000]</span></span><br><span class="line">    </span><br><span class="line">    C[<span class="number">2</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'C[2, 1] ='</span>, C[<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># C[2, 1] = [[0.000000, 1.000000], [0.000000, 0.000000]]</span></span><br><span class="line">    </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="Phases-of-a-Taichi-program"><a href="#Phases-of-a-Taichi-program" class="headerlink" title="Phases of a Taichi program"></a>Phases of a Taichi program</h3><ol>
<li>Initialization: ti.init(…)</li>
<li>Tensor allocation: ti.var, ti.Vector, ti.Matrix</li>
<li>Computation (launch kernels, access tensors in Python-scope)</li>
<li>Optional: restart the Taichi system (clear memory, destroy all variables and kernels): ti.reset()</li>
</ol>
<p><strong>Note</strong></p>
<p>For now, after the first kernel launch or tensor access in Python-scope, no more tensor allocation is allowed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fractal.py</span></span><br><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init(arch=ti.gpu)</span><br><span class="line"></span><br><span class="line">n = <span class="number">320</span></span><br><span class="line">pixels = ti.var(dt=ti.f32, shape=(n * <span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex_sqr</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ti.Vector([z[<span class="number">0</span>]**<span class="number">2</span> - z[<span class="number">1</span>]**<span class="number">2</span>, z[<span class="number">1</span>]*z[<span class="number">0</span>]*<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(t: ti.f32)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> pixels: <span class="comment"># Parallelized over all pixels</span></span><br><span class="line">        c = ti.Vector([<span class="number">-0.8</span>, ti.cos(t)*<span class="number">0.2</span>])</span><br><span class="line">        z = ti.Vector([i/n<span class="number">-1</span>, j/n<span class="number">-0.5</span>]) * <span class="number">2</span></span><br><span class="line">        iterations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> z.norm() &lt; <span class="number">20</span> <span class="keyword">and</span> iterations &lt;<span class="number">50</span>:</span><br><span class="line">            z = complex_sqr(z) + c</span><br><span class="line">            iterations += <span class="number">1</span></span><br><span class="line">        pixels[i, j] = <span class="number">1</span> - iterations * <span class="number">0.02</span></span><br><span class="line">        </span><br><span class="line">gui = ti.GUI(<span class="string">"Julia Set"</span>, res=(n*<span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    paint(i * <span class="number">0.03</span>)</span><br><span class="line">    gui.set_image(pixels)</span><br><span class="line">    gui.show()</span><br></pre></td></tr></table></figure>

<h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><p> ti.init(debug=True, arch=ti.cpu) initializes Taichi in debug mode, which enables bound checkers (CPU only).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init(debug=<span class="literal">True</span>, arch=ti.cpu)</span><br><span class="line"></span><br><span class="line">a = ti.var(ti.i32, shape=(<span class="number">10</span>))</span><br><span class="line">b = ti.var(ti.i32, shape=(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        a[i] = b[i+<span class="number">1</span>] <span class="comment"># Runtime error in debug mode</span></span><br><span class="line">        </span><br><span class="line">shift()</span><br></pre></td></tr></table></figure>

<h2 id="Objective-data-oriented-programming"><a href="#Objective-data-oriented-programming" class="headerlink" title="Objective data-oriented programming"></a>Objective data-oriented programming</h2><p>Taichi is a data-oriented programming (DOP) language, but simple DOP makes modularization hard. To improve code reusability, Taichi borrows some concepts from object-oriented programming (OOP).</p>
<p>The hybrid scheme is called objective data-oriented programming (ODOP).</p>
<p>Three important decorators</p>
<ul>
<li>Use @ti.data_oriented to decorate your class.</li>
<li>Use @ti.kernel to decorate class members functions that are Taichi kernels.</li>
<li>Use @ti.func to decorate class members functions that are Taichi functions.</li>
</ul>
<p>Demo:  ti example odop_solar  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">ti.init()</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.data_oriented</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolarSystem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, dt)</span>:</span></span><br><span class="line">        <span class="comment"># initializer of the solar system simulator</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.dt = dt</span><br><span class="line">        self.x = ti.Vector.field(<span class="number">2</span>, dtype=float, shape=n)</span><br><span class="line">        self.v = ti.Vector.field(<span class="number">2</span>, dtype=float, shape=n)</span><br><span class="line">        self.center = ti.Vector.field(<span class="number">2</span>, dtype=float, shape=())</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="meta">    @ti.func</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">random_vector_in</span><span class="params">(rmax)</span>:</span></span><br><span class="line">        <span class="comment"># create a random vector</span></span><br><span class="line">        a = ti.random() * math.tau</span><br><span class="line">        r = ti.random() * rmax</span><br><span class="line">        <span class="keyword">return</span> r * ti.Vector([ti.cos(a), ti.sin(a)])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @ti.kernel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># initialization or reset</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            offset = self.random_vector_in(<span class="number">0.5</span>)</span><br><span class="line">            self.x[i] = self.center[<span class="literal">None</span>] + offset  <span class="comment"># Offset from center</span></span><br><span class="line">            self.v[i] = [-offset.y, offset.x]  <span class="comment"># Perpendicular to offset</span></span><br><span class="line">            self.v[i] += self.random_vector_in(<span class="number">0.02</span>)  <span class="comment"># Shaking</span></span><br><span class="line">            self.v[i] *= <span class="number">1</span> / offset.norm()**<span class="number">1.5</span>  <span class="comment"># Kepler's 3rd law</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @ti.func</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gravity</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        <span class="comment"># compute gravitational acceleration at pos</span></span><br><span class="line">        offset = -(pos - self.center[<span class="literal">None</span>])</span><br><span class="line">        <span class="keyword">return</span> offset / offset.norm()**<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @ti.kernel</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integrate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># semi-implicit time integration</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.n):</span><br><span class="line">            self.v[i] += self.dt * self.gravity(self.x[i])</span><br><span class="line">            self.x[i] += self.dt * self.v[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self, gui)</span>:</span></span><br><span class="line">        <span class="comment"># render the simulation scene on the GUI</span></span><br><span class="line">        gui.circle([<span class="number">0.5</span>, <span class="number">0.5</span>], radius=<span class="number">10</span>, color=<span class="number">0xffaa88</span>)</span><br><span class="line">        gui.circles(solar.x.to_numpy(), radius=<span class="number">3</span>, color=<span class="number">0xffffff</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solar = SolarSystem(<span class="number">8</span>, <span class="number">0.0001</span>)</span><br><span class="line">solar.center[<span class="literal">None</span>] = [<span class="number">0.5</span>, <span class="number">0.5</span>]</span><br><span class="line">solar.initialize()</span><br><span class="line"></span><br><span class="line">gui = ti.GUI(<span class="string">"Solar System"</span>, background_color=<span class="number">0x0071a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> gui.running:</span><br><span class="line">    <span class="comment"># GUI event processing</span></span><br><span class="line">    <span class="keyword">if</span> gui.get_event(gui.PRESS):</span><br><span class="line">        <span class="keyword">if</span> gui.event.key == gui.SPACE:</span><br><span class="line">            solar.initialize()</span><br><span class="line">        <span class="keyword">elif</span> gui.event.key == gui.ESCAPE:</span><br><span class="line">            gui.running = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        solar.integrate()</span><br><span class="line"></span><br><span class="line">    solar.render(gui)</span><br><span class="line">    gui.show()</span><br></pre></td></tr></table></figure>

<h2 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h2><p>Taichi provides metaprogramming tools. Metaprogramming can :</p>
<ul>
<li>Allow users to pass almost anything (including Taichi tensors) to Taichi kernels</li>
<li>Improve run-time performance by moving run-time costs to compile time</li>
<li>Achieve dimensionality independence (e.g. write 2D and 3D simulation code simultaneously.)</li>
<li>Simplify the development of Taichi standard library</li>
</ul>
<p>Taichi kernels are <strong>lazily instantiated</strong> and a lot of computation can happen at compile time. Every kernel in Taichi is a template kernel, even if it has no template arguments.</p>
<h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(x: ti.template <span class="params">()</span>, y: ti.template <span class="params">()</span>, c: ti.f32)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:   </span><br><span class="line">        y[i] = x[i] + c</span><br></pre></td></tr></table></figure>

<p>如果不用template很难把tensor当argument传给kernel</p>
<p><strong>Template instantiation</strong></p>
<p>Kernel templates will be instantiated on the first call, and cached for later calls with the same template signature.</p>
<p><strong>Template argument takes (almost) everything</strong></p>
<p>Feel free to pass tensors, classes, functions, and numerical values to ti.template() arguments.</p>
<h3 id="Template-kernel-instantiation"><a href="#Template-kernel-instantiation" class="headerlink" title="Template kernel instantiation"></a>Template kernel instantiation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init()</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i: ti.template <span class="params">()</span>)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">100</span>):</span><br><span class="line">    hello(i) <span class="comment"># 100 different kernels will be created</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">world</span><span class="params">(i: ti.i32)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">100</span>):</span><br><span class="line">    world(i) <span class="comment"># The only instance will be reused</span></span><br></pre></td></tr></table></figure>

<h3 id="Dimensionality-independent-programming"><a href="#Dimensionality-independent-programming" class="headerlink" title="Dimensionality-independent programming"></a>Dimensionality-independent programming</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(x: ti.template<span class="params">()</span>, y: ti.template<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(y):  <span class="comment"># 将y的全部index打包,I--&gt;n维向量</span></span><br><span class="line">        x[I] = y[I]</span><br><span class="line">        </span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">array_op</span><span class="params">(x: ti.template<span class="params">()</span>, y: ti.template<span class="params">()</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> ti.grouped(x):</span><br><span class="line">        <span class="comment"># I is a vector of size x.dim() and data type i32</span></span><br><span class="line">        y[I] = I[<span class="number">0</span>] + I[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># If tensor x is 2D, the above is equivalent to</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> x:</span><br><span class="line">        y[i, j] = i + j</span><br></pre></td></tr></table></figure>

<h3 id="Tensor-size-reflection"><a href="#Tensor-size-reflection" class="headerlink" title="Tensor-size reflection"></a>Tensor-size reflection</h3><p>Fetch tensor dimensionality info as compile-time constants:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"></span><br><span class="line">tensor = ti.var(ti.f32, shape=(<span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_tensor_size</span><span class="params">(x: ti.template<span class="params">()</span>)</span>:</span></span><br><span class="line">    print(len(x.shape))  <span class="comment"># x.dim() &amp; x.shape() is deprecated</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ti.static(range(len(x.shape))):</span><br><span class="line">        print(x.shape[i])</span><br><span class="line"></span><br><span class="line">print_tensor_size(tensor)</span><br></pre></td></tr></table></figure>

<h3 id="Compile-time-branching"><a href="#Compile-time-branching" class="headerlink" title="Compile-time branching"></a>Compile-time branching</h3><p>Using compile-time evaluation will allow certain computations to happen when kernels are being instantiated. This saves the overhead of those computations at runtime. (C++17 equivalence: if constexpr.)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enable_projection = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ti.static(enable_projection): <span class="comment"># No runtime overhead</span></span><br><span class="line">        x[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Forced-loop-unrolling"><a href="#Forced-loop-unrolling" class="headerlink" title="Forced loop-unrolling"></a>Forced loop-unrolling</h3><p>Use ti.static(range(…)) to unroll the loops at compile time:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"></span><br><span class="line">ti.init()</span><br><span class="line">x = ti.Vector(<span class="number">3</span>, dt=ti.i32, shape =<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> ti.static(range(<span class="number">3</span>)):</span><br><span class="line">            x[i][j] = j</span><br><span class="line">        print(x[i])</span><br><span class="line"></span><br><span class="line">fill()</span><br></pre></td></tr></table></figure>

<p>When to use range-for loops?</p>
<ul>
<li>For performance.  （loop-unrolling后可以减少loop本身的overhead）</li>
<li>To loop over vector/matrix elements. Indices into Taichi matrices must be compile-time constants. Indices into Taichi tensors can be run-time variables. For example, if x is a 1-D tensor of 3D vectors, accessed as x [tensor_index] [matrix_index]. The first index can be a variable, yet the second must be a constant.</li>
</ul>
<h3 id="Variable-aliasing"><a href="#Variable-aliasing" class="headerlink" title="Variable aliasing"></a>Variable aliasing</h3><p>Creating handy aliases for global variables and functions with cumbersome names can sometimes improve readability:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_kernel</span> <span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> tensor_a:</span><br><span class="line">        tensor_b[i, j] = some_function(tensor_a[i, j])</span><br><span class="line">        </span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_kernel</span> <span class="params">()</span>:</span></span><br><span class="line">    a, b, fun = ti.static(tensor_a , tensor_b , some_function)</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> a:</span><br><span class="line">        b[i,j] = fun(a[i,j])</span><br></pre></td></tr></table></figure>

<h2 id="Differentiable-Programming"><a href="#Differentiable-Programming" class="headerlink" title="Differentiable Programming"></a>Differentiable Programming</h2><p>Forward programs evaluate $f(x)$, differentiable programs evaluate $\frac{∂f(x)}{∂x}$</p>
<p>Taichi supports <strong>reverse-mode automatic differentiation (AutoDiff)</strong> that back-propagates gradients w.r.t. a scalar (loss) function f(x).</p>
<p>Two ways to compute gradients:</p>
<ol>
<li>Use Taichi’s tape (ti.Tape(loss)) for both forward and gradient evaluation.</li>
<li>Explicitly use gradient kernels for gradient evaluation with more controls.</li>
</ol>
<h3 id="Gradient-based-optimization"><a href="#Gradient-based-optimization" class="headerlink" title="Gradient-based optimization"></a>Gradient-based optimization</h3><p>$$<br>min_x \quad L(x) = \frac{1}{2}\sum_{i=0}^{n-1}(x_i - y_i)^2<br>$$</p>
<ol>
<li><p>Allocating tensors with gradients：x = ti.var(dt=ti.f32, shape=n, needs_grad=True)</p>
</li>
<li><p>Defining loss function kernel(s)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span> <span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        L[<span class="literal">None</span>] += <span class="number">0.5</span> * (x[i] - y[i])**<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Compute loss with ti.Tape(loss=L)：reduce()</p>
</li>
<li><p>Gradient descent：for i in x: x[i] -= x.grad[i] * 0.1</p>
</li>
</ol>
<h3 id="Application-1-Forces-from-potential-energy-gradients"><a href="#Application-1-Forces-from-potential-energy-gradients" class="headerlink" title="Application 1: Forces from potential energy gradients"></a>Application 1: Forces from potential energy gradients</h3><p>From the definition of potential energy: (potential energy关于位置的导数–&gt;顶点的受力)<br>$$<br>f_i = -\frac{∂U(x)}{∂x_i}<br>$$<br>Manually deriving gradients is hard. Let’s use AutoDiff:</p>
<ol>
<li>Allocate a 0−D tensor to store the potential energy: potential = ti.var(ti.f32, shape=()).</li>
<li>Define forward kernels that computes potential energy from x[i].</li>
<li>In a ti.Tape(loss=potential), call the forward kernels.</li>
<li>Force on each particle is -x.grad[i].</li>
</ol>
<h3 id="Application-2-Differentiating-a-whole-physical-process"><a href="#Application-2-Differentiating-a-whole-physical-process" class="headerlink" title="Application 2: Differentiating a whole physical process"></a>Application 2: Differentiating a whole physical process</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ti.Tape(loss=loss):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(steps - <span class="number">1</span>):</span><br><span class="line">        simulate(i)</span><br></pre></td></tr></table></figure>

<p><strong>Computational history</strong></p>
<p>Always keep the whole computational history of time steps for end-to-end differentiation. I.e., instead of only allocating<br>ti.Vector(3, dt=ti.f32, shape=(num_particles)) that stores the latest particles, allocate for the whole simulation process<br>ti.Vector(3, dt=ti.f32, shape=(num_timesteps, num_particles)). (Use checkpointing to reduce memory consumption.)</p>
<h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><p><strong>Visualizing 2D results</strong></p>
<p>Simply make use of Taichi’s GUI system. Useful functions:</p>
<ul>
<li>gui = ti.GUI(“Taichi MLS-MPM-128”, res=512, background_color=0x112F41)</li>
<li>gui.circle/gui.circles(x.to_numpy(), radius=1.5, color=colors.to_numpy())</li>
<li>gui.line/triangle/set_image/show/…</li>
</ul>
<p><strong>Visualizing 3D results</strong></p>
<p>Exporting 3D particles and meshes using ti.PLYWriter</p>
<p>Use Houdini/Blender to view (and render) your 3D results.</p>
<hr>
<p>ti example: 查看example demo 4</p>
<p>python -m taichi example mpm128 (demo_name)</p>
<h1 id="2、Lagrangian-Simulation-Approaches"><a href="#2、Lagrangian-Simulation-Approaches" class="headerlink" title="2、Lagrangian Simulation Approaches"></a>2、Lagrangian Simulation Approaches</h1><h2 id="Mass-Spring-Systems-弹簧质点系统"><a href="#Mass-Spring-Systems-弹簧质点系统" class="headerlink" title="Mass-Spring Systems (弹簧质点系统)"></a>Mass-Spring Systems (弹簧质点系统)</h2><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/taichi/mass_spring.png" alt="mass_spring" style="zoom:50%;" />

<p>k: spring stiffness; l<sub>ij</sub>: spring rest length between particle i and particle j;</p>
<p>m<sub>i</sub>: the mass of particle i. (<strong>x<sub>i</sub></strong> − <strong>x<sub>j</sub></strong>): direction vector from particle j to particle i;</p>
<h2 id="Time-integration"><a href="#Time-integration" class="headerlink" title="Time integration"></a>Time integration</h2><p><strong>1、Forward Euler</strong> (explicit)：</p>
<p>​        前向欧拉法：根据现有的状态推测以后的状态：</p>
<p>$$<br>v_{t+1} = v_t + \Delta t\frac{f_t}{m}<br>$$</p>
<p>$$<br>x_{t+1} = x_t + \Delta tv_t<br>$$</p>
<p><strong>2、Semi-implicit Euler</strong> (aka. symplectic Euler, explicit)：<br>$$<br>v_{t+1} = v_t + \Delta t\frac{f_t}{m}<br>$$</p>
<p>$$<br>x_{t+1} = x_t + \Delta tv_{t+1}<br>$$</p>
<p><strong>3、Backward Euler</strong> (often with Newton’s method, implicit)：</p>
<h3 id="Implementing-a-mass-spring-system-with-symplectic-Euler"><a href="#Implementing-a-mass-spring-system-with-symplectic-Euler" class="headerlink" title="Implementing a mass-spring system with symplectic Euler"></a>Implementing a mass-spring system with symplectic Euler</h3><ol>
<li><p>Compute new velocity using<br>$$<br>v_{t+1} = v_t + \Delta t\frac{f_t}{m}<br>$$</p>
</li>
<li><p>Collision with ground</p>
</li>
<li><p>Compute new position using<br>$$<br>x_{t+1} = x_t + \Delta tv_{t+1}<br>$$</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mass_spring.py</span></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">substep</span><span class="params">()</span>:</span></span><br><span class="line">    n = num_particles[<span class="literal">None</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute force and new velocity</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        v[i] *= ti.exp(-dt * damping[<span class="literal">None</span>]) <span class="comment"># damping</span></span><br><span class="line">        total_force = ti.Vector(gravity) * particle_mass</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> rest_length[i, j] != <span class="number">0</span>:</span><br><span class="line">                x_ij = x[i] - x[j]</span><br><span class="line">                total_force += -spring_stiffness[<span class="literal">None</span>] * (x_ij.norm() - rest_length[i, j]) * x_ij.normalized()</span><br><span class="line">        v[i] += dt * total_force / particle_mass</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Collide with ground</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> x[i].y &lt; bottom_y:</span><br><span class="line">            x[i].y = bottom_y</span><br><span class="line">            v[i].y = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># Compute new position</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        x[i] += v[i] * dt</span><br></pre></td></tr></table></figure>

<h3 id="Explicit-v-s-implicit-time-integrators"><a href="#Explicit-v-s-implicit-time-integrators" class="headerlink" title="Explicit v.s. implicit time integrators"></a>Explicit v.s. implicit time integrators</h3><p>Explicit (forward Euler, symplectic Euler, RK, …)：</p>
<ul>
<li><p>Future depends only on past</p>
</li>
<li><p>Easy to implement</p>
</li>
<li><p>Easy to explode: （从材料的刚度考虑时间步长的限制）<br>$$<br>\Delta t \leq c\sqrt{\frac{m}{k}} \quad\quad(c-1)<br>$$</p>
</li>
<li><p>Bad for stiff materials</p>
</li>
</ul>
<p>Implicit (backward Euler, middle-point, …):</p>
<ul>
<li>Future depends on both future and past</li>
<li>Chicken-egg problem: need to solve a system of (linear) equations</li>
<li>In general harder to implement</li>
<li>Each step is more expensive but time steps are larger</li>
<li>Numerical damping and locking</li>
</ul>
<h3 id="Mass-spring-systems"><a href="#Mass-spring-systems" class="headerlink" title="Mass-spring systems"></a>Mass-spring systems</h3><p>Implicit time integration:<br>$$<br>x_{t+1} = x_t + \Delta tv_{t+1} \quad\quad (1)<br>$$</p>
<p>$$<br>v_{t+1} = v_t + \Delta tM^{-1}f(x_{t+1}) \quad\quad (2)<br>$$</p>
<p>Eliminate x<sub>t+1</sub>:<br>$$<br>v_{t+1} = v_t + \Delta tM^{-1}f(x_t + \Delta tv_{t+1}) \quad\quad (3)<br>$$<br>Linearize (one step of Newton’s method):<br>$$<br>v_{t+1} = v_t + \Delta tM^{-1}[f(x_t) + \frac{∂f}{∂x}(x_t)\Delta tv_{t+1}] \quad\quad (4)<br>$$<br>Clean up:<br>$$<br>[I - \Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)] v_{t+1} = v_t + \Delta tM^{-1}f(x_t) \quad\quad (5)<br>$$<br>How to solve it?</p>
<ul>
<li>Jacobi/Gauss-Seidel iterations (easy to implement!)</li>
<li>Conjugate gradients (later in this course)</li>
</ul>
<p>$$<br>A = [I - \Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)]<br>$$</p>
<p>$$<br>b = v_t + \Delta tM^{-1}f(x_t)<br>$$</p>
<p>$$<br>Av_{t+1} = b<br>$$</p>
<h3 id="Unifying-explicit-and-implicit-integrators"><a href="#Unifying-explicit-and-implicit-integrators" class="headerlink" title="Unifying explicit and implicit integrators"></a>Unifying explicit and implicit integrators</h3><p>$$<br>[I - \beta\Delta t^2M^{-1}\frac{∂f}{∂x}(x_t)] v_{t+1} = v_t + \Delta tM^{-1}f(x_t)<br>$$</p>
<ol>
<li>β = 0: forward/semi-implicit Euler (explicit)</li>
<li>β = 1/2: middle-point (implicit)</li>
<li>β = 1: backward Euler (implicit)</li>
</ol>
<h2 id="Lagrangian-fluid-simulation-SPH"><a href="#Lagrangian-fluid-simulation-SPH" class="headerlink" title="Lagrangian fluid simulation: SPH"></a>Lagrangian fluid simulation: SPH</h2><p><strong>High-level idea:</strong> use particles carrying samples of physical quantities, and a kernel function W, to approximate continuous fields: (<em>A</em> can be almost any spatially varying physical attributes: density, pressure, etc. Derivatives: different story)<br>$$<br>A(x) = \sum_i{A_i}\frac{m_i}{ρ_i}W(||x-x_j||_2, h)<br>$$</p>
<ol>
<li>Originally proposed for astrophysical problems</li>
<li>No meshes. Very suitable for free-surface flows!</li>
<li>Easy to understand intuitively: just imagine each particle is a small parcel of water (although strictly not the case!)</li>
</ol>
<h3 id="Implementing-SPH-using-the-Equation-of-States"><a href="#Implementing-SPH-using-the-Equation-of-States" class="headerlink" title="Implementing SPH using the Equation of States"></a>Implementing SPH using the Equation of States</h3><p>Also known as Weakly Compressible SPH (WCSPH).</p>
<p>Momentum equation: ( ρ: density;  B: bulk modulus;  γ : constant, usually ∼ 7 )<br>$$<br>\frac{Dv}{Dt} = -\frac{1}{ρ}\nabla p + g, \quad\quad p = B((\frac{ρ}{ρ_0})^\gamma - 1)<br>$$</p>
<p>$$<br>A(x) = \sum_i{A_i}\frac{m_i}{ρ_i}W(||x-x_j||_2,h)<br>$$</p>
<p>$$<br>ρ_i = \sum_j{m_j}W(||x_i-x_j||_2,h)<br>$$</p>
<p>Extras: surface tension, viscosity</p>
<p>Note: the WCSPH paper should have used material derivatives.</p>
<h3 id="Gradients-in-SPH"><a href="#Gradients-in-SPH" class="headerlink" title="Gradients in SPH"></a>Gradients in SPH</h3><p>$$<br>\nabla A_i = ρ<em>i \sum{m_j}(\frac{A_i}{ρ_i^2} + \frac{A_j}{ρ_j^2}) \nabla</em>{x_i}W(||x_i-x_j||_2,h)<br>$$</p>
<p>Not really accurate.</p>
<p>But at least symmetric and momentum conserving!</p>
<h3 id="SPH-Simulation-Cycle"><a href="#SPH-Simulation-Cycle" class="headerlink" title="SPH Simulation Cycle"></a>SPH Simulation Cycle</h3><p>$$<br>\frac{Dv}{Dt} = -\frac{1}{ρ}\nabla p + g, \quad\quad p = B((\frac{ρ}{ρ_0})^\gamma - 1)<br>$$</p>
<ol>
<li>For each particle i, compute $ρ_i = \sum{m_j}W(||x_i-x_j||_2,h)$</li>
<li>For each particle i, compute $\nabla p_i$ using the gradient operator</li>
<li>Symplectic Euler step (again…):</li>
</ol>
<p>$$<br>v_{t+1} = v_t + \Delta t\frac{D_v}{D_t}<br>$$</p>
<p>$$<br>x_{t+1} = x_t + \Delta tv_{t+1}<br>$$</p>
<h3 id="Variants-of-SPH"><a href="#Variants-of-SPH" class="headerlink" title="Variants of SPH"></a>Variants of SPH</h3><p>Predictive-Corrective Incompressible SPH (PCI-SPH)：隐式的时间积分（不完全隐式），采用预测矫正的格式，每次先预测一下粒子的位置/速度，然后根据预测做出矫正，得到一个散度比较小的速度场–&gt;更加接近不可压缩</p>
<p>Position-based fluids (PBF) Demo: ti example pbf2d</p>
<p>Divergence-free SPH (DFSPH)</p>
<h3 id="Courant–Friedrichs–Lewy-CFL-condition"><a href="#Courant–Friedrichs–Lewy-CFL-condition" class="headerlink" title="Courant–Friedrichs–Lewy (CFL) condition"></a>Courant–Friedrichs–Lewy (CFL) condition</h3><p>显示时间积分：从粒子运动的速度考虑时间步长的限制：<br>$$<br>C = \frac{u \Delta t}{\Delta x} \leq C_{max} - 1<br>$$</p>
<ul>
<li>C:  CFL number (Courant number, or simple the CFL)</li>
<li>$\Delta t$:  time step</li>
<li>$\Delta x$:  length interval (e.g. particle radius and grid size)</li>
<li>u: maximum (velocity)     $u\Delta t$  –&gt; 一个时间步之内粒子移动的最大距离</li>
</ul>
<p>Application: estimating allowed time step in (explicit) time integrations. Typical C<sub>max</sub> in graphics:</p>
<ul>
<li>SPH: ∼ 0.4</li>
<li>MPM: 0.3 ∼ 1</li>
<li>FLIP fluid (smoke): 1 ∼ 5+</li>
</ul>
<h3 id="Accelerating-SPH-Neighborhood-search"><a href="#Accelerating-SPH-Neighborhood-search" class="headerlink" title="Accelerating SPH: Neighborhood search"></a>Accelerating SPH: Neighborhood search</h3><p>So far, per substep complexity of SPH is $O(n^2)$ . This is too costly to be practical. In practice, people build spatial data structure such as voxel grids to accelerate neighborhood search. This reduces time complexity to O(n).</p>
<h1 id="3、Basics-of-deformation-elasticity-and-finite-elements"><a href="#3、Basics-of-deformation-elasticity-and-finite-elements" class="headerlink" title="3、Basics of deformation, elasticity, and finite elements"></a>3、Basics of deformation, elasticity, and finite elements</h1><h2 id="Deformation"><a href="#Deformation" class="headerlink" title="Deformation"></a>Deformation</h2><p>Deformation map ϕ : a (vector to vector) function that relates rest material position and deformed material position.  (将静止位置映射到形变位置，如果在3D中，即是从三维向量到三维向量的一个向量函数)<br>$$<br>x_{deformed} = \phi (x_{rest})<br>$$<br>Deformation gradient F：（对静止位置求导数）<br>$$<br>F:=\frac{∂x_{deformed}}{∂x_{rest}}<br>$$<br>Deformation gradients are translational invariant:<br>$$<br>\phi_1 = \phi(x_{rest}) \quad and \quad \phi_2 = \phi(x_{rest}) + c<br>$$<br>​        have the same deformation gradients</p>
<p>Deform/rest volume ratio $J = det(F)$   （$J$ ：形变以后的体积/静止的体积 = F的行列式）</p>
<h2 id="Elasticity"><a href="#Elasticity" class="headerlink" title="Elasticity"></a>Elasticity</h2><h3 id="Hyperelasticity"><a href="#Hyperelasticity" class="headerlink" title="Hyperelasticity"></a>Hyperelasticity</h3><p>Hyperelastic materials: materials whose stress–strain relationship is defined by a strain energy density function：<br>$$<br>\psi = \psi(F)<br>$$<br>Intuitive understanding: $\psi$ is a potential function that penalizes deformation.</p>
<p>“Stress”：the material’s internal elastic forces. （用来恢复原来体积形状的内力）</p>
<p>“Strain”：just replace it with deformation gradients F for now.</p>
<p><strong>Be careful</strong></p>
<p>We use ψ as the strain energy density function and ϕ as the deformation map. They are completely different.</p>
<h3 id="Stress-tensor"><a href="#Stress-tensor" class="headerlink" title="Stress tensor"></a>Stress tensor</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/" class="post-title-link" itemprop="url">Weakly compressible SPH for free surface flows</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-23 16:58:36" itemprop="dateCreated datePublished" datetime="2020-08-23T16:58:36+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-01 22:23:53" itemprop="dateModified" datetime="2020-11-01T22:23:53+08:00">2020-11-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>基于Tait方程，本文提出了一种弱可压缩光滑粒子流体动力学方法。与通常采用的严格执行不可压缩性的投影方法相比，通过允许用户定义小的密度波动，避免了泊松方程的耗时求解。我们还讨论了一个改进的表面张力模型，特别适合单相自由表面流动。通过与已有模型的比较，验证了该方法对自由表面流动的准确性。结合所提出的方法，可以有效地利用SPH模拟低粘度液体。该方法适用于中、小规模现象。喷溅和碎波等波浪效果是自然处理的。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​    在流体动画中，最理想的功能是模拟具有碎波和飞溅的湍流液体。像SPH这样的拉格朗日方法是捕捉这种性质的一个有前途的方法。</p>
<p>​    Miller 和 Pearcy 提出了基于粒子的方法，这种早期的方法是基于简单的粒子-粒子力。</p>
<p>​    Stam 和 Fiume 第一次将SPH应用于气体和火焰现象的模拟。</p>
<p>​    Takeshita等人对爆炸火焰也采用了粒子法。</p>
<p>​    除了这些可压缩现象，SPH还被用于模拟液体。</p>
<p>​    这些方法采用理想气体方程来联系压力和密度。这导致高压缩性和振荡，与气体相反，这是不希望的，视觉上令人不快。增强粒子方法的不可压缩性是一个具有挑战性的问题。康明斯和鲁德曼为拉格朗日方法提出了一种投影方法，这种方法也用于欧拉方法。类似地，Premoze等人已经实现了移动粒子半隐式方法(MPS)的不可压缩性。在这种方法中，基于压力校正将速度估计投影到无发散子空间上。因此，泊松方程必须求解。虽然可以处理大的时间步长，但是用于求解泊松方程的共轭梯度解算器对于大系统来说是耗时的。对于100k粒子，Premoze注释是3分钟，而可压缩的SPH实现可以处理类似的复杂性5-10秒每时间步。</p>
<p>​    在我们的SPH模拟中，我们建议使用Tait方程和一个高声速，这导致具有非常低密度波动的弱可压缩公式。该方法避免了由于可压缩性而导致的不可信的模拟结果。虽然与泊松方法相比，该方法需要更小的时间步长，但每时间步长的计算速度要快得多，而且实现很容易适应SPH框架。弱可压缩形式的计算时间与基于理想气体方程的可压缩形式所需的时间相对应。</p>
<p>​    除了体积保持，表面张力在逼真的流体动画中也起着重要的作用。由于对小细节的处理主要受表面张力的控制，所以在自由表面流体的拉格朗日方法中通常会考虑到这一点。然而，这些方法最初是为多相流设计的。虽然在高动态环境中不可评估，但它们不能正确处理大曲率。这是因为粒子在这些区域的邻居太少。此外，[Mor99]要求计算颜色场的二阶导数，颜色场对粒子无序非常敏感，因此不适用于湍流环境。</p>
<p>​    我们提出了一个基于内聚力的表面张力模型。该模型特别适合于单相流，但也可以处理多相流。避免了导数的计算，提高了方法的效率和稳定性。</p>
<h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><p>​    受早期程序方法的启发，计算机图形学中的流体模拟主要由欧拉方法和拉格朗日方法组成。一般来说，欧拉方法显示出许多有用的特征。仅举几个例子，计算是在固定的网格上进行的，避免了拉格朗日方法所要求的耗时的邻居搜索。此外，通过设置适当的边界条件，可以容易地处理流入和流出。</p>
<p>​    在[KM90]中，卡斯和米勒提出了一个基于浅水方程线性化的高度场模型(height-field model)。在[FM96]中，福斯特和梅塔克萨斯引入了三维纳维尔-斯托克斯方程组的有限差分解法。使用2D高度场和表面标记粒子来跟踪自由表面，并且实现了流体和刚性物体的单向耦合。在[FM97]中，2D标记粒子法被推广到三维，并提出了一种局部自适应阻尼方法来提高稳定性。斯塔姆[99]提出了三维不可压缩纳维尔-斯托克斯方程的无条件稳定解算器。福斯特和费迪基通过结合水平集和表面标记粒子来减轻质量耗散，使用改进的表面跟踪来增强流体的方法。这就是所谓的粒子水平集方法。埃尔科特等人提供了对[Sta99]的进一步扩展的全面概述。他们使用相同的半拉格朗日平流策略，但提出了一个保持循环的积分方案。</p>
<p>​    其他作者引入了处理多相流的扩展，包括两种或多种流体，与运动刚性固体的双向耦合，可变形固体，以及局部细化。奥布莱恩和哈金斯通过使用粒子系统来模拟液滴来增强基于网格的方法，米哈利夫等人解决了欧拉流体模拟的碎波问题。最近，点阵玻尔兹曼方法已经被提出用于流体模拟。在这种基于网格的替代方法中，粒子分布是使用碰撞和传播规则在有限的网格上演化的。</p>
<p>​    计算机图形学中拉格朗日方法的研究—至少在某种程度上—是由交互式应用推动的。拉格朗日方法在内存和计算时间方面是比较有效的。它们对于时变仿真域具有灵活性，易于实现。基于上述基本SPH方法，已经给出了各种扩展。SPH流体的应用范围从河流模拟、多相流体模拟和高粘性流体到流体控制。Desbrun和Cani 提出了一种用于可变形固体的弹性SPH方法。Hadap和Magnenat-Thalmann 使用SPH进行头发动力学。在[MST∗04]中，实现了基于sph的流体和可变形固体的双向耦合。Solenthaler等人[SSP07]提出了一种适用于液体、弹性和刚性物体的统一SPH方法。SPH也在虚拟手术中得到了应用。</p>
<p>​    Bell等人提出了一种基于分子动力学的颗粒方法。Zhu和Bridson 将细胞内粒子法扩展到模拟水和颗粒物质。为了更好地介绍图形中的各种流体模拟技术，我们参考了Bridson、Fedkiw和MullerFischer的优秀SIGGRAPH课程笔记。</p>
<h2 id="SPH-fluid-model"><a href="#SPH-fluid-model" class="headerlink" title="SPH fluid model"></a>SPH fluid model</h2><p>对于流体，插值公式如下：<br>$$<br>A(\mathbf{x}) = \sum_j m_j \frac{A_j}{ρ_j} W(\mathbf{x}-\mathbf{x}_j,h) \quad\quad (1)<br>$$</p>
<h3 id="The-governing-equations-and-their-SPH-formulation"><a href="#The-governing-equations-and-their-SPH-formulation" class="headerlink" title="The governing equations and their SPH formulation"></a>The governing equations and their SPH formulation</h3><p>​    在我们的方法中，我们求解欧拉方程，它是无粘流的Navier-Stokes方程的简化。为了提高方法的数值稳定性，在模型中加入了动量守恒的人工粘度。在非守恒形式下，欧拉方程：<br>$$<br>\frac{dρ}{dt} = -ρ\nabla \cdot \mathbf{v} \quad\quad \text{(continuity equation)} \quad\quad (2)<br>$$</p>
<p>$$<br>\frac{d\mathbf{v}}{dt} = -\frac{1}{ρ}\nabla P + \mathbf{g} \quad\quad \text{(momentum equation)} \quad\quad (3)<br>$$</p>
<p>​    v表示速度，P表示压力，g表示外力</p>
<p><strong>Continuity equation</strong></p>
<p>​    最初的SPH方法使用求和公式来计算密度:<br>$$<br>ρ<em>a = \sum_b m_b W</em>{ab}  \quad\quad (W_{ab} = W(\mathbf{x}_a - \mathbf{x}_b))  \quad\quad (4)<br>$$<br>​    由于质量是由粒子携带的，这种形式正好保持了质量。然而，由于自由表面中的表面粒子具有较少的邻居，因此公式(4)为等间距粒子计算了表面附近的错误(较低)密度。</p>
<p>​    有几种方法可以解决这个问题。例如，[SDD06]使用自适应的核半径h，在表面强制执行恒定密度，并在表面模拟小规模效果。莫纳汉[Mon94]引入了另一种方法，并在[SAC*99]中通过求解连续性方程来使用，这导致了SPH形式：<br>$$<br>\frac{dρ<em>a}{dt} = \sum_b m_b \mathbf{v}</em>{ab} \nabla_a W_{ab} \quad\quad (5)<br>$$<br>with $\mathbf{v}_{ab} = \mathbf{v}_a - \mathbf{v}_b$ </p>
<p>​    每个粒子都以密度ρ0初始化，密度变化只是由于粒子的相对运动。微分更新(5)保证了自由表面的正确密度。虽然使用(5)初始化更容易，但求和方法(4)更稳定，并已在我们的实验中使用。</p>
<p><strong>Momentum equation</strong></p>
<p>在SPH形式中，动量方程写成：<br>$$<br>\frac{d\mathbf{v}<em>a}{dt} = -\sum_b m_b \left( \frac{P_a}{ρ_a^2} + \frac{P_b}{ρ_b^2} \right) \nabla_a W</em>{ab} + \mathbf{g} \quad\quad (6)<br>$$<br>这个对称的版本保持了线动量和角动量。<br>$$<br>\frac{Dv}{Dt} = \frac{dv}{dt}|_{v_0=v}=\frac{∂v}{∂t}+v\cdot \nabla v=\frac{∂v}{∂t} + u\frac{∂v}{∂x}+v\frac{∂v}{∂y}+w\frac{∂v}{∂z}<br>$$<br><strong>Equation of state</strong></p>
<p>​    压力和密度有不同的联系形式。如果需要不可压缩性，泊松方程$\nabla^2 P = ρ\frac{\nabla \mathbf{v}}{∆t}$通常在欧拉方法中求解。然而，求解泊松方程是耗时的。相比之下，使用理想气体方程 $P = k_p ρ$ 或 $P = k_p(ρ - ρ_0)$ ，压力常数kp用于SPH，这导致相当高的可压缩性。</p>
<p>​    与这两种方法相比，我们使用泰特方程，该方程强制要求非常低的密度变化，并且计算效率高。忽略可以简单地作为恒压项添加的大气压力，泰特方程具有以下形式：<br>$$<br>P = B \left( \left(\frac{ρ}{ρ_0} \right)^{\gamma} -1 \right) \quad\quad (7)<br>$$<br>with γ = 7</p>
<p>​    压力常数B控制相对密度波动 $\frac{|∆ρ|}{ρ_0}$，其中 ∆ρ=ρ - ρ<sub>0</sub> 。为了确定B的值，我们考虑可压缩性效应与$O(M^2)$成比例，M表示流动的马赫数。这导致以下关系：<br>$$<br>\frac{|∆ρ|}{ρ_0} \sim \frac{|\mathbf{v}_f|^2}{c_s^2} \quad\quad (8)<br>$$<br>​    马赫数：流体力学中表征流体可压缩程度的一个重要的无量纲参数，记为Ma，定义为流场中某点的速度<em>v</em>同该点的当地声速c之比，即Ma=v/c。</p>
<p>​    因此，如果假设声速足够大，使得 $\frac{\mathbf{v}_f}{c_s} &lt; \sqrt{\eta}$，我们可以保证 $\frac{|∆ρ|}{ρ_0} \sim \eta$。通常，η设置为0.01，即允许1%数量级的密度变化。为了实施这一条件，选择B作为：<br>$$<br>B = \frac{ρ_0 c_s^2}{\gamma} \quad\quad (9)<br>$$<br>​    假设声速很高以保持低密度波动，与不可压缩粒子方法相比，泰特方程需要更小的时间步长。但是我们避免了求解泊松方程，每个时间步长需要的计算时间要少得多。对于100k粒子，一个时间步长的计算速度可以比MPS快二十倍。</p>
<h3 id="Viscosity"><a href="#Viscosity" class="headerlink" title="Viscosity"></a>Viscosity</h3><p>​    为了提高数值稳定性并考虑到冲击现象，采用了人工粘度：<br>$$<br>\frac{d\mathbf{v}<em>a}{dt} =<br>        \begin{cases}<br>        -\sum_b m_b \Pi</em>{ab}\nabla_a W_{ab} &amp; \mathbf{v}<em>{ab}^T\mathbf{x}</em>{ab}&lt;0\<br>        0 &amp; \mathbf{v}<em>{ab}^T\mathbf{x}</em>{ab}\geq 0<br>        \end{cases} \quad\quad(10)<br>$$</p>
<p>$$<br>\Pi_{ab} = -v \left(\frac{\mathbf{v}<em>{ab}^T \mathbf{x}</em>{ab}}{|\mathbf{x}_{ab}^2| + \varepsilon h^2} \right) \quad\quad (11)<br>$$</p>
<p>​    粘性项：$v = \frac{2αhc_s}{ρ_a + ρ_b}$ ，粘性常数α，对于我们的实验，α在0.08和0.5之间。线动量和角动量在(11)中是守恒的。</p>
<h3 id="Surface-Tension"><a href="#Surface-Tension" class="headerlink" title="Surface Tension"></a>Surface Tension</h3><p>​    当前的表面张力模型通常基于分配给粒子a的颜色值ca，一个相位的所有粒子都具有相同的颜色值，根据颜色值进行插值：<br>$$<br>c = \sum_b \frac{m_b c_b}{ρ<em>b} W</em>{ab} \quad\quad (12)<br>$$<br>​    表面法线计算为：$\mathbf{n} = \nabla c$  ，表面张力计算：<br>$$<br>\mathbf{f}^{tension} = -k \nabla^2 c \frac{\mathbf{n}}{|\mathbf{n}|} \quad\quad(13)<br>$$<br>​    k是表面张力系数。</p>
<p>​    由于归一化，法线只有在它们的长度超过某个阈值时才会被考虑。</p>
<p>​    这种模式有几个缺点。在粒子只有几个邻居的表面附近，计算曲率 $-\nabla^2c$ 容易出错。此外，计算二阶导数对粒子无序很敏感。</p>
<p>​    胡和亚当斯提出了修改版本。将表面张力表示为应力张量π的散度，应力张量π由颜色场c唯一定义:<br>$$<br>\Pi = k \frac{1}{|\nabla c|} \left(\frac{1}{3} \mathbf{I} |\nabla c|^2 - \nabla c \nabla c^T \right) \quad\quad (14)<br>$$<br>​    这个表达式得出加速度方程：<br>$$<br>\frac{d\mathbf{v}<em>a}{dt} = \frac{1}{m_a} \sum_b \nabla W</em>{ab} \left(\frac{\Pi_a}{\sigma_a^2} + \frac{\Pi_b}{\sigma_b^2} \right) \quad\quad (15)<br>$$<br>​    with $\sigma_a = \sum_b W(r_a -r_b)$ ，此方法解决了上述问题，因为他们没有明确计算曲率，对于|∇c| → 0，张量自然趋于零。</p>
<p>​    虽然上述两种方法已经应用于自由表面问题，但这两种方法最初都是针对多相场景的。因此，在没有第二相的情况下，它们无法计算出正确的表面张力。它们缺少适当数量的相邻粒子，特别是在高曲率的表面区域。</p>
<p>​    本文提出了一个新的表面张力模型，它依赖于内聚力。由于以前的方法采用了模型的宏观视角，本文的方法受到微观视角的启发，因为在分子水平上，表面张力是由于分子之间的吸引力而产生的。本文使用光滑核W作为加权函数来缩放吸引力:<br>$$<br>\frac{d\mathbf{v}_a}{dt} = -\frac{κ}{m_a}\sum_b{m_b}W(\mathbf{x}_a - \mathbf{x}_b) \quad\quad (16)<br>$$<br>​    此方法不依赖于第二相，适用于高曲率的自由表面问题。吸引力可以有效地计算出来。通过只对同相粒子施加吸引力，所提出的方法可以很容易地推广到多相问题。</p>
<h2 id="Visualization"><a href="#Visualization" class="headerlink" title="Visualization"></a>Visualization</h2><p>​    粒子方法的一些可视化技术基于显式表面重建。使用移动立方体(Marching Cubes)，从特征函数重建等值面。然而，捕捉小细节需要对底层空间进行非常精细或自适应的离散化。</p>
<p>​    粒子水平集不仅使用等值面，而且还引入了与速度场平流的示踪粒子。它们可以使用示踪粒子处理小液滴。然而，这些液滴不一定能捕捉模拟的分辨率。对于大变形，必须重新播种示踪粒子。在[KCC * 06]中，示踪粒子是用拉格朗日方法平流的。</p>
<p>​    受Zwicker等人[ZPvBG01]和Adams等人[ALD06]的表面喷溅算法启发，我们采用了一种光线追踪方法。小水花和单滴的可视化受到[KCC * 06]和[TRS06]的启发。该方法保证了适当地捕捉到小到单个粒子大小的特征。每个像素的法线计算类似于[Mor99]如下：<br>$$<br>\mathbf{n}_a = \sum_b\frac{m_b}{ρ_b}\nabla W(\mathbf{x}_a - \mathbf{x}_b) \quad\quad(17)<br>$$<br>​    我们对所有被射线击中的粒子求和。在3.4GHz的奔腾4上，可视化130k粒子大约需要1-2秒。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>​    在本节中，我们将说明SPH实现的一些属性。我们首先讨论模拟时间步长、边界条件和方法的初始化。随后，说明使用泰特方程与理想气体方程相比的效果，并讨论我们的表面张力模型的性质。最后，我们给出了一个带有碎波的示例场景。</p>
<p>​    邻域搜索通过均匀的空间细分来实现。集成是通过蛙跳方案实现的。所有实验均采用水的密度ρ<sub>0</sub>=  1000kg/m<sup>3</sup>进行。</p>
<h3 id="Time-step"><a href="#Time-step" class="headerlink" title="Time step"></a>Time step</h3><p>​    时间步长的适当选择对于稳定性和收敛性至关重要。在我们的例子中，时间步长由CFL条件、粘性项和力项[Mon92]导出:<br>$$<br>∆t = min\left(0.25\cdot \min\limits_a\ \left(\frac{h}{|\mathbf{f}_a|}\right), 0.4\cdot \frac{h}{c_s\cdot(1+0.6α)}\right) \quad\quad(18)<br>$$<br>​    尽管就数值稳定性而言，时间步长可能更大，但我们使用建议的时间步长来确保收敛。</p>
<h3 id="Boundary-conditions"><a href="#Boundary-conditions" class="headerlink" title="Boundary conditions"></a>Boundary conditions</h3><p>​    在流体粒子与边界碰撞的地方插入边界粒子。根据[Mon05]，计算流体粒子a与边界粒子k碰撞的力$\mathbf{f}<em>{ak}$为：<br>$$<br>\mathbf{f}</em>{ak} = \frac{m_k}{m_a + m_k}\Gamma(\mathbf{x}_a,\mathbf{x}_b)\frac{\mathbf{x}_a - \mathbf{x}_k}{|\mathbf{x}_a-\mathbf{x}_k|} \quad\quad(19)<br>$$<br>​    函数$\Gamma$定义为：<br>$$<br>\Gamma(\mathbf{x}_a,\mathbf{x}_b) = 0.02\frac{c_s^2}{|\mathbf{x}_a-\mathbf{x}_b|}<br>        \begin{cases}<br>            \frac{2}{3} &amp; 0&lt;q&lt;\frac{2}{3}\<br>            (2q-\frac{3}{2}q^2) &amp; \frac{2}{3}&lt;q&lt;1\<br>            \frac{1}{2}(2-q)^2 &amp; 1&lt;q&lt;2\<br>            0 &amp; otherwise<br>        \end{cases} \quad\quad (20)<br>$$<br>with $q = \frac{|\mathbf{x}_a - \mathbf{x}_b|}{h}$</p>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>​    为了获得近似恒定密度的有效状态我们使用求和方法(4)，用(6)的强阻尼版本将粒子演化一百步。在简单的初始几何图形的情况下，这种初始化可能会导致小的视觉伪影。</p>
<h3 id="Volume-preservation"><a href="#Volume-preservation" class="headerlink" title="Volume preservation"></a>Volume preservation</h3><p>​    为了比较基于Tait方程和理想气体方程的实现，我们进行了两个实验。在这两个实验中，我们测量最大密度和初始密度的比率，以评估体积保持。</p>
<p>​    在第一个实验中，我们用130k个粒子模拟了一个溃坝场景。大坝的高度是H =5。对于Tait方程，密度波动η设置为0.01。对于气体方程，压力常数Kp设置为300。密度波动和压力常数分别最小化和最大化，以便在两种方法中使用相同的时间步长。在两个版本中，粒子半径和初始间距为0.1，粘性项α为0.1，计算时间约为每时间步4.5s。气体方程测得的密度比是4.06，泰特方程测得的密度比是1.01，如图1所示。</p>
<img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_1.png" alt="Figure_1" style="zoom:80%;" />

<p>​    the Tait equation (left) and the ideal gas equation (right). The gas equation  leads to high compressibility.</p>
<p>​    在第二个实验中，我们模拟了两个高度为H = 2、总粒子数为16k、粘度为α = 0.5的溃坝在一个矩形盆地中相互碰撞。气体方程的压力常数Kp设置为200，密度波动参数η设置为0.01。使用气体方程测得的最大密度比是1.2。由参数确定，对于泰特方程，测得的密度比是1.01。</p>
<p>​    两个实验都是以相同的密度和相同的粒子质量初始化。实验表明，对于恒定的初始密度和粒子半径，气体方程的密度比随着模拟流体的体积而增加，即随着粒子的数量而增加。与弱可压缩方法相比，气体方程观察到相当大的体积变化。当大坝坍塌时，这一点尤其明显。使用我们的弱可压缩方法，密度波动可以对越来越多的粒子保持不变。就体积保持而言，泰特方程因此适用于处理大型粒子系统。</p>
<h3 id="Surface-tension"><a href="#Surface-tension" class="headerlink" title="Surface tension"></a>Surface tension</h3><p>​    为了将我们的表面张力方法与[HA06]进行比较，我们使用了一个具有27k粒子的流体立方体，假设它在失重情况下会变形成一个水滴。对于可比结果，我们的方法的表面张力为0.8，而[HA06]的表面张力为30.6。可选参数设置主要影响收敛到平衡状态的速度。只要参数在合理范围内，定性结果不受影响。结果如图2所示。</p>
<img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_2.png" alt="Figure_2" style="zoom:80%;" />

<p>​    The effect of surface tension. Initial state (left), resulting equilibrium using [HA06] (middle) and our surface tension approach (right).</p>
<p>​    由于[HA06]最初用于多相情况，它不太适合自由表面情况下的高曲率。与我们的方法相反，初始状态的高曲率基本上被保留。</p>
<p>​    在另一个实验中，我们研究了表面张力模型的参数设置。因此，我们模拟了具有两种不同表面张力的溃坝。表面张力0.01接近水，值3.4是此设定中最大的稳定值。如图3所示，选择较大的表面张力值会导致液体飞溅较大。</p>
<img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_3.png" alt="Figure_3" style="zoom:80%;" />

<p>​    Two corner-breaking dams using a surface tension of 0.01 (left) and 3.4 (right).</p>
<h3 id="Breaking-waves"><a href="#Breaking-waves" class="headerlink" title="Breaking waves"></a>Breaking waves</h3><p>​    我们设计了一个场景来说明碎波的处理。我们在一个26×5的水池中使用了200k个粒子，其地面坡度为12°。半径和初始间距设置为0.1。密度波动设置为0.01。粘度项为α = 0.08。为了产生波，我们使用平面波发生器。计算时间为每个时间步长7.5s。从图4中可以看出，飞溅和碎波可以用我们的方法来模拟。</p>
<img src="F:\blog\source\_posts\Weakly-compressible-SPH-for-free-surface-flows\Figure_4.png" alt="Figure_4" style="zoom:80%;" />

<p>​    A breaking wave is generated using a wave generator</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>​    我们提出了一种用于自由表面流体的弱可压缩SPH方法。通过允许小的用户定义的密度波动，与严格执行不可压缩性的方法相比，Tait方程是一种有效的替代方法。与气体方程相比，即使有大量粒子，密度波动仍然很小。已经在各种场景中说明了体积保持。使用我们的方法可以模拟具有飞溅的低粘性流体的碎波等自然现象。</p>
<p>​    此外，我们还提出了一种基于内聚力的表面张力改进算法。与以前的方法相比，我们的模型可以处理单相自由表面流体的高曲率。</p>
<p>​    目前正在进行的工作重点是多相表面张力和自适应粘度方案，如[MM97]中所建议的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">交互式应用中基于粒子的流体模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-13 09:52:09" itemprop="dateCreated datePublished" datetime="2020-08-13T09:52:09+08:00">2020-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-19 15:12:52" itemprop="dateModified" datetime="2020-08-19T15:12:52+08:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistically animated fluids can add substantial realism to interactive applications such as virtual surgery simulators or computer games. In this paper we propose an interactive method based on Smoothed Particle Hydrodynamics(SPH) to simulate fluids with free surfaces. The method is an extension of the SPH-based technique by Desbrun to animate highly deformable bodies. We gear the method towards fluid simulation by deriving the force density fields directly from the Navier-Stokes equation and by adding a term to model surface tension effects. In contrast to Eulerian grid-based approaches, the particle-based approach makes mass conservation equations and convection terms dispensable which reduces the complexity of the simulation. In addition, the particles can directly be used to render the surface of the fluid. We propose methods to track and visualize the free surface using point splatting and marching cubes-based surface reconstruction. Our animation method is fast enough to be used in interactive systems and to allow for user interaction with models consisting of up to 5000 particles.</span><br></pre></td></tr></table></figure>

<p><strong>Smoothed Particle Hydrodynamics (SPH)</strong></p>
<p>​        光滑粒子流体动力学。拉格朗日视角，一种无网格方法。该方法的基本思想是将连续的流体(或固体)用相互作用的质点组来描述，各个物质点上承载各种物理量，包括质量、速度等，通过求解质点组的动力学方程和跟踪每个质点的运动轨道，求得整个系统的力学行为。</p>
<p>​        对于流体的研究，有两种不同的坐标系，分别是欧拉法和拉格朗日法。欧拉视角的坐标系是固定的，如同站在河边观察河水的流动一样，用这种视角分析流体需要建立网格单元，还会涉及到有限元等复杂的工程方法，一般用在离线的应用中。而拉格朗日视角则将流体视为流动的单元，例如将一片羽毛放入风中，那么羽毛的轨迹可以帮我们指示空气的流动规律。SPH算法是典型的拉格朗日视角，它的基本原理就是通过粒子模拟流体的运动规律，然后再转换成网格进行流体渲染。</p>
<p><strong>force density</strong></p>
<p>​        力密度</p>
<p><strong>Navier-Stokes equation</strong></p>
<p>​        纳维-斯托克斯方程，描述粘性不可压缩流体动量守恒的运动方程。简称N-S方程。粘性流体的运动方程首先由Navier在1827年提出，只考虑了不可压缩流体的流动。Poisson在1831年提出可压缩流体的运动方程。Saint-Venant在1845年，Stokes在1845年独立提出粘性系数为一常数的形式，都称为Navier-Stokes方程，简称N-S方程。</p>
<p><strong>surface tension</strong></p>
<p>​        表面张力。水等液体会产生使表面尽可能缩小的力，这个力称为“表面张力”。液体具有内聚性和吸附性，这两者都是分子引力的表现形式。内聚性使液体能抵抗拉伸应力，而吸附性则使液体可以黏附在其他物体上面。在液体和气体的分界处，即液体表面及两种不能混合的液体之间的界面处，由于分子之间的吸引力，产生了极其微小的拉力。假想在表面处存在一个薄膜层，它承受着此表面的拉伸力，液体的这一拉力称为表面张力。</p>
<p><strong>Eulerian</strong></p>
<p>​        欧拉法。是以流体质点流经流场中各空间点的运动即以流场作为描述对象研究流动的方法——流场法。它不直接追究质点的运动过程，而是以充满运动液体质点的空间——流场为对象。研究各时刻质点在流场中的变化规律。将个别流体质点运动过程置之不理，而固守于流场各空间点。通过观察在流动空间中的每一个空间点上运动要素随时间的变化，把足够多的空间点综合起来而得出的整个流体的运动情况。</p>
<p><strong>流体运动的数学描述</strong></p>
<p>​        <strong>拉格朗日（Lagrange ）法——随体法</strong></p>
<p>​        拉格朗日法着眼于研究各个流体质点的运动，描述的流体质点至始至终的运动过程以及它们的物理量随时间t的变化规律。</p>
<p>​        <strong>欧拉（Euler ）法——当地法</strong></p>
<p>​        欧拉法着眼于空间点，描述的是各个时刻，各个空间点（场论的概念）中流体质点物理量的变化情况。物理量在空间中的分布称为物理场，如速度场、压力场、密度场等，这些所有的物理量场统称为流场。</p>
<p><strong>mass conservation</strong></p>
<p>​        质量守恒。</p>
<p><strong>convection terms</strong></p>
<p>​        对流项。速度运输动量。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><strong>1.1 Motivation</strong></p>
<p>​        不太精确的方法允许实时模拟流体效应，这开辟了各种新的应用。实时方法有助于在设计阶段测试某个概念是否有前途。流体实时模拟技术的其他应用包括医学模拟器、计算机游戏或任何类型的虚拟环境。</p>
<p><strong>1.2 Related Work</strong></p>
<p>​        Computational Fluid Dynamics (CFD) 计算流体力学 历史：</p>
<p>​        1822年Claude Navier和1845年George Stokes建立了著名的Navier-Stokes方程，描述了流体动力学；</p>
<p>​        描述质量守恒的连续性方程和描述能量守恒的状态方程；</p>
<p>​        1983年，T. Reeves引入了粒子系统作为一种建模一类模糊对象的技术。此后，基于粒子的拉格朗日方法和基于网格的欧拉方法被用于计算机图形学中流体的模拟；</p>
<p>​        Desbrun和Cani和Tonnesen使用粒子使软物体产生动画效果；</p>
<p>​        本文提出了一种基于光滑粒子流体动力学的基于质点的方法来实现任意流体运动的动画。</p>
<p><strong>1.3. Our Contribution</strong></p>
<p>​        提出了一种基于光滑粒子流体动力学(SPH)的方法来模拟具有自由表面的流体。Stam和Fiume首先将SPH引入图形界，以描述火和其他气体现象。后来，德斯布伦使用SPH动画高度可变形的物体。我们将他的方法扩展到流体的模拟上。为此，我们直接从Navier-Stokes方程推导出粘性力场和压力场，并提出了一种表面张力的建模方法。为了实现交互性，我们设计了新的专用平滑核。在交互速率下的表面跟踪和表面绘制是一个困难的问题，我们描述了可能的解决方案。</p>
<h2 id="2-Smoothed-Particle-Hydrodynamics"><a href="#2-Smoothed-Particle-Hydrodynamics" class="headerlink" title="2. Smoothed Particle Hydrodynamics"></a>2. Smoothed Particle Hydrodynamics</h2><p>​        SPH是粒子系统的一种插值方法。有了SPH，仅在离散粒子位置定义的场量可以在空间的任何地方计算。为此，SPH在每个粒子的局部邻域分布数量使用径向对称平滑核。</p>
<p>​        “平滑核”可以这样理解这个概念，粒子的属性都会“扩散”到周围，并且随着距离的增加影响逐渐变小，这种随着距离而衰减的函数被称为“平滑核”函数，最大影响半径为“平滑核半径”。</p>
<p>​        根据SPH，在<strong>r</strong>位置，平滑核半径h范围内有数个粒子，位置为<strong>r<sub>0</sub></strong>到<strong>r<sub>j</sub></strong>，用所有粒子贡献的加权和表示插值标量A:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F1.png" alt="公式1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F1.png" class="" title="This is image1">

<p><em>其中A<sub>j</sub>是在r<sub>j</sub>位置要迭代的某种属性，m<sub>j</sub>和ρ<sub>j</sub>是粒子j的质量和密度，<strong>r<sub>j</sub></strong>是该粒子的位置，h是平滑核半径。函数W就是平滑核函数。</em></p>
<p>​        函数W(r,h)称为核半径为h的平滑核，由于我们只使用有限支撑集（support，也就是函数值不为0的点所组成的集合）的核，因此在公式中我们使用h作为支撑集半径。如果W为偶函数(即W(r,h) =W(−r,h))并归一化，插值具有二阶精度。平滑核函数是标准化的：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F2.png" alt="公式2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F2.png" class="" title="This is image2">

<p>​        粒子质量和密度出现在公式(1)中，每个粒子i的体积V<sub>i</sub> = m<sub>i</sub> /ρ<sub>i</sub> ，在整个模拟过程中质量m<sub>i</sub> 是恒定的，密度ρ<sub>i</sub> 是变化的，并且需要在每个时间步长进行评估。通过代入公式(1)得到位置r处的密度:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F3.png" alt="公式3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F3.png" class="" title="This is image3">

<p>​        在大多数流体方程中，出现了场量的导数，并需要计算。在SPH方法中，这些导数只影响平滑核。A的梯度：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F4.png" alt="公式4"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F4.png" class="" title="This is image4">

<p>​        A的拉普拉斯式求值是：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F5.png" alt="公式5"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F5.png" class="" title="This is image5">

<p>​        SPH存在一些固有的问题。当用SPH推导粒子的流体方程时，这些方程不能保证满足某些物理原理，如力的对称性和动量守恒。</p>
<h2 id="3-Modelling-Fluids-with-Particles"><a href="#3-Modelling-Fluids-with-Particles" class="headerlink" title="3. Modelling Fluids with Particles"></a>3. Modelling Fluids with Particles</h2><p>​        这部分介绍基于SPH的模型和技术，以解决这些SPH相关的问题。</p>
<p>​        在基于网格的欧拉公式中，等温流体由速度场v、密度场ρ和压力场p来描述。这些量随时间的变化由两个方程给出。第一个方程保证了质量守恒：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F6.png" alt="公式6"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F6.png" class="" title="This is image6">

<p>​        Navier-Stokes方程则表示动量守恒：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F7.png" alt="公式7"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F7.png" class="" title="This is image7">

<p><em>g为重力加速度，μ为流体的粘度（粘性系数）。公式(7)表示不可压缩流体的简化形式。</em></p>
<p>​        使用粒子而不是静止网格大大简化了这两个方程。首先，因为粒子的数量是恒定的，每个粒子的质量恒定，质量守恒是有保证的，公式(6)可以完全省略。第二，公式(7)左边的 <u>∂v/∂t+v·∇v</u> 可以用随体导数Dv/Dt代替。由于粒子随流体运动，速度的随体导数仅仅是粒子速度的时间导数，这意味着粒子系统不需要对流项v·∇v。</p>
<p>​        在公式(7)的右边有三个力密度场。建模压力(−∇p)、外力(ρ<strong>g</strong>)、粘度(μ∇<sup>2</sup><strong>v</strong>)。这些力密度场<strong>f</strong> =−∇p+ρ<strong>g</strong>+μ∇<sup>2</sup><strong>v</strong>的和决定了左边粒子的动量变化量ρDv/Dt。对于粒子i的加速度，则有:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F8.png" alt="公式8"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F8.png" class="" title="This is image8">



<p>下面使用SPH来建模力密度项</p>
<h3 id="3-1-Pressure"><a href="#3-1-Pressure" class="headerlink" title="3.1 Pressure"></a>3.1 Pressure</h3><p>​        将SPH规则应用到压力项−∇p：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F9.png" alt="公式9"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F9.png" class="" title="This is image9">

<p>​        不幸的是，当只有两个粒子相互作用时，这种力是不平衡的。由于核函数在中心的梯度为零，粒子i只使用粒子j的压力来计算其压力，反之亦然。由于两个粒子位置上的压力一般不相等，所以压力不会是平衡的。文献中提出了公式(9)不同的平衡方法。我们建议了一个非常简单的解决方案，发现它最适合我们的速度和稳定的目的：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F10.png" alt="公式10"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F10.png" class="" title="This is image10">

<p>​        这样计算出来的压力是平衡的，因为它使用了相互作用粒子压力的算术平均值。</p>
<p>​        由于粒子只携带质量、位置和速度三个量，因此必须首先评估粒子位置处的压力。这需要两个步骤。公式(3)产生粒子所在位置的密度。然后，通过理想气体状态方程计算压强：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F11.png" alt="公式11"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F11.png" class="" title="This is image11">

<p><em>k是一个气体常数，它只与温度有关</em></p>
<p>​        改进：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F12.png" alt="公式12"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F12.png" class="" title="This is image12">

<p>​        ρ<sub>0</sub>是流体的静态密度（标准密度）。</p>
<p>​        由于压力依赖于压力场的梯度，从数学上讲，偏移量对压力没有影响。然而，偏移量对SPH平滑场的梯度有一定的影响，使数值模拟更加稳定。</p>
<h3 id="3-2-Viscosity"><a href="#3-2-Viscosity" class="headerlink" title="3.2 Viscosity"></a>3.2 Viscosity</h3><p>​        将SPH规则应用到粘度项μ∇<sup>2</sup><strong>v</strong>，得到不平衡的作用力：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F13.png" alt="公式13"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F13.png" class="" title="This is image13">

<p><em>速度场随粒子而变化。</em></p>
<p>​        由于粘滞力只依赖于速度差而不依赖于绝对速度，因此有一种利用速度差来对称粘滞力的自然方法:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F14.png" alt="公式14"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F14.png" class="" title="This is image14">

<p>​        公式(14)的一种可能的解释是从粒子i自身的运动参照系观察粒子i的邻域。那么粒子i就会朝着它周围环境的相对速度方向加速。</p>
<h3 id="3-3-Surface-Tension"><a href="#3-3-Surface-Tension" class="headerlink" title="3.3 Surface Tension"></a>3.3 Surface Tension</h3><p>​        基于Morris的思想模拟表面张力。流体中的分子受到邻近分子的引力。在流体内部，这些分子间的力在各个方向上是相等的，并且相互平衡。相反，作用在自由表面分子上的力是不平衡的。净力(即表面张力)作用于表面垂直于流体的方向。他们也倾向于最小化表面的曲率。曲率越大，力就越大。表面张力还取决于张力系数σ，该系数取决于形成表面的两种流体。</p>
<p>​        流体的表面可以通过使用一个附加的场量来找到，这个场量在存在粒子的位置上为1，不存在粒子的位置为0。这个场称为色场。对于平滑的色场，我们得到:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F15.png" alt="公式15"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F15.png" class="" title="This is image15">

<p>​        平滑的色场的梯度：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F16.png" alt="公式16"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F16.png" class="" title="This is image16">

<p>​        产生指向流体的表面法向场，n的散度测量表面的曲率：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F17.png" alt="公式17"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F17.png" class="" title="This is image17">

<p>​        对于凸面的流体体积，负曲率是得到正曲率的必要条件。综上所述，我们得到了表面牵引力:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F18.png" alt="公式18"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F18.png" class="" title="This is image18">

<p>​        为了在表面附近的粒子之间分配表面牵引力，并获得力密度，我们乘以一个归一化标量场δs=| <strong>n</strong> |，该场仅在表面附近是非零的。对于作用在表面附近的力密度，我们得到：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F19.png" alt="公式19"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F19.png" class="" title="This is image19">

<p>​        在|<strong>n</strong>|较小的位置计算<strong>n</strong>/|<strong>n</strong>|会造成数值问题。我们只在|<strong>n</strong>|超过某个阈值时计算力。</p>
<h3 id="3-4-External-Forces"><a href="#3-4-External-Forces" class="headerlink" title="3.4 External Forces"></a>3.4 External Forces</h3><p>​        我们的模拟器支持外力，如重力，碰撞力和用户交互引起的力。这些力直接施加在粒子上，而不使用SPH。在我们的例子中，当粒子与固体物体（如玻璃）碰撞时，我们只需将它们推出物体，并反射垂直于物体表面的速度分量。</p>
<h3 id="3-5-Smoothing-Kernels"><a href="#3-5-Smoothing-Kernels" class="headerlink" title="3.5 Smoothing Kernels"></a>3.5 Smoothing Kernels</h3><p>​        SPH方法的稳定性、精度和速度在很大程度上取决于平滑核的选择。由于核函数都是偶函数且归一化的，所以我们使用的核函数有二阶插值误差（见图1）。</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%9B%BE1.png" alt="图1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%9B%BE1.png" class="" title="This is image_1">

<p><em>我们在模拟中使用的三个平滑核W<sub>poly6</sub>、W<sub>spiky</sub>和W<sub>viscosity</sub>（从左到右）。粗线表示核函数，细线表示向中心方向的梯度，虚线表示拉普拉斯函数。请注意，这些图的比例不同。曲线显示沿一个轴通过平滑长度h=1的中心的三维核函数。</em></p>
<p>​        此外，在边界处导数为零的核有利于稳定性。除了这些约束，人们还可以自由地为特殊目的设计核函数。我们设计了下面的核函数：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F20.png" alt="公式20"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F20.png" class="" title="This is image20">

<p>​    除了两种情况外，所有情况下都使用它。这个简单核函数的一个重要特征是r只出现平方，这意味着在距离计算中不需要计算平方根。然而，如果用这个核函数来计算压力，粒子往往会在高压下形成团簇。当粒子彼此非常接近时，斥力消失，Poly6核的梯度在中心变为0，因此它不适用于插值压力，为了使粒子接近时具有较大的压力，必须使用另一种梯度在0点有较大取值的平滑核来插值压力，称为Spiky核，该内核在中心附近有一个非消失的梯度。对于压力的计算，我们使用Debrun的Spiky核：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F21.png" alt="公式21"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F21.png" class="" title="This is image21">

<p>​        这产生了必要的斥力。在边界处，一阶导数和二阶导数都为零。</p>
<p>​        粘性是一种由摩擦引起的现象，通过将流体加热来降低流体的动能。因此，粘性只对速度场有平滑作用。然而，如果用一个标准核来计算粘度，则产生的粘性力并不总是具有这种性质。对于两个相互靠近的粒子，平滑速度场的拉普拉斯系数（粘性力依赖于此）可能会变为负值，从而导致粘性力增加其相对速度。在粗采样的速度场中会出现伪影。在粒子数相对较少的实时应用中，这种影响会导致稳定性问题。因此需要使用另一种平滑核插值粘性力，称为粘度核：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F22.png" alt="公式22"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F22.png" class="" title="This is image22">

<p>​        它的拉普拉斯方程处处为正，并具有以下附加性质:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cproperties.png" alt="properties"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/properties.png" class="" title="This is image_2">

<p>​        使用此核来进行黏性力计算，大大提高了模拟的稳定性，可以省略任何类型的附加阻尼。</p>
<h3 id="3-6-Simulation"><a href="#3-6-Simulation" class="headerlink" title="3.6 Simulation"></a>3.6 Simulation</h3><p>​        对于公式(8)的积分，我们采用蛙跳法。作为一个只需计算一次力的二阶方案，它最适合我们的目的，在我们的例子中允许时间步长达10毫秒。对于这些例子，我们使用恒定的时间步长。如果基于Courant-Friedrichs-Lewy条件使用自适应时间步长，我们预计会有更好的性能。</p>
<p><strong>蛙跳差分格式</strong></p>
<p>​        蛙跳格式是一个很常用的差分格式，它在时间和空间上都采用中心差分。（通过解差分方程来求微分方程的近似解，是连续问题离散化）假设离散化如下图所示：</p>
<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog1.png" alt="leap_frog1" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog1.png" class="" title="This is image_3">

<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog2.png" alt="leap_frog2" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog2.png" class="" title="This is image_4">

<p>​        蛙跳格式是时间和空间上均为二阶精度的，三层一步显式差分格式。因而，为了计算(n+1)层的值，需要(n-1)层和n层的已知值。另外，还可以看出，后一偶数层的值实际上等于前一偶数层的值加上一个变化量，而跳过其间的奇数层，这就是蛙跳式这个名称的来历。</p>
<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog3.png" alt="leap_frog3" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog3.png" class="" title="This is image_5">

<p><strong>CFL收敛条件判断数</strong></p>
<p>​        CFL数是计算流体力学中，判断计算的收敛条件，具体是差分方程的依赖域必须包含相应微分方程的依赖域，最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。Time stepping technique是指时间推进技术，一般有统一时间步长和当地时间步长，而选择当地时间步长也就是当地CFL条件允许的最大时间步长，采用这种方法能够加速收敛，节省计算时间。</p>
<h2 id="4-Surface-Tracking-and-Visualization"><a href="#4-Surface-Tracking-and-Visualization" class="headerlink" title="4. Surface Tracking and Visualization"></a>4. Surface Tracking and Visualization</h2><p>​        第3.3节中定义的色场c<sub>S</sub>及其梯度<strong>n</strong>=∇c<sub>S</sub>可用于识别表面粒子和计算表面法线。</p>
<p>​        我们把粒子i定义为表面粒子，如果：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F23.png" alt="公式23"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F23.png" class="" title="This is image23">

<p>​        其中l是阈值参数。粒子i位置处的表面法线方向由下式给出：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F24.png" alt="公式24"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F24.png" class="" title="This is image24">

<h3 id="4-1-Point-Splatting"><a href="#4-1-Point-Splatting" class="headerlink" title="4.1 Point Splatting"></a>4.1 Point Splatting</h3><p>​        我们现在有一组法线但没有连通性信息的点。这正是point splatting（把点变成有面积的简单几何形状渲染）所需的信息类型。然而，这些方法被设计用于处理从通常至少包含10,000到100,000个点的扫描仪获得的点云。我们只使用了几千个粒子，其中一小部分被确定存在于表面。如结果部分所示，静止表面飞溅会产生似乎合理的结果。我们目前正在研究提高液体表面采样率的方法。因此，插值表面粒子的颜色场信息，在仅用于渲染的表面上寻找附加粒子的位置。</p>
<h3 id="4-2-Marching-Cubes"><a href="#4-2-Marching-Cubes" class="headerlink" title="4.2 Marching Cubes"></a>4.2 Marching Cubes</h3><p>​        另一种可视化自由表面的方法是绘制色场c<sub>S</sub>的等值面。我们使用移动立方体算法对等值面进行三角剖分。在空间固定的网格中，首先识别包含表面的单元格。我们从包含表面粒子的所有单元格开始搜索，然后沿着表面递归地遍历网格。使用哈希表，我们可以确保单元格不会被访问超过一次。对于识别出包含表面的每个单元格，三角形是通过快速查表生成的。</p>
<p><strong>Marching Cubes算法</strong></p>
<p>​        Marching Cubes算法是三维离散数据场中提取等值面的经典算法。算法主要的思想是在三维离散数据场中通过线性插值来逼近等值面，具体如下：三维离散数据场中每个栅格单元作为一个体素，体素的每个顶点都存在对应的标量值。如果体素顶点上的值大于或等于等值面值，则定义该顶点位于等值面之外，标记为“0”；而如果体素顶点上的值小于等值面值，则定义该顶点位于等值面之内，标记为“1”。由于每个体素单元有8个顶点，每个顶点有2种状态，那么共存在2<sup>8</sup> = 256种情形。但由于反转状态不变，所以可以减少一半，为128种。再根据旋转不变形，又可以减少到15种情况。</p>
<p>​        如图所示：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/MC_15%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="MC_15种情况"></p>
<p>​        每个体素单元上顶点和边的索引规则如下图左所示，假如体素下方的顶点3的值小于等值面值，其他顶点上的值都大于等值面值（如下图右所示），那么我们可以生成一个与体素边2，3，11相交的三角面片，而三角面片顶点的具体位置则需要根据等值面值和边顶点3-2，3-0，3-7的值线性插值计算得到。</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E7%AD%89%E5%80%BC%E9%9D%A2.png" alt="等值面"></p>
<p>​        对于与等值面存在交点的体素边，交点坐标用P表示，P1、P2代表边上两个端点的坐标，V1、V2代表这两个端点上的值，V代表等值面值，那么交点坐标的计算公式：P = P1 + (V – V1)·(P2 – P1)/(V2 – V1)</p>
<p><strong>算法第一步：</strong>通过edgeTable表判断等值面和体素单元哪一条边相交</p>
<p>​        体素单元顶点状态的索引号定义规则如下：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E9%A1%B6%E7%82%B9%E7%8A%B6%E6%80%81%E7%B4%A2%E5%BC%95.png" alt="顶点状态索引"></p>
<p>​        以上图所示为例，仅顶点3标记为“1”，其他顶点标记为“0”，那么体素单元的顶点状态为0000 1000或者8，通过查找表得到edgeTable[8] = 1000 0000 1100，意味着体素单元的边2，3，11和等值面相交，然后通过线性插值计算各个交点的位置。</p>
<p><strong>算法第二步：</strong>通过triTable表生成对应三角面片的组成情况</p>
<p>　　还是以上图所示为例，通过查找表得到triTable[8] = {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}，意味着该种顶点状态可以生成三角面片(3, 11, 2)，代表三角面片的3个顶点为边3，11，2和等值面相交的交点。</p>
<p>　　经过上述步骤之后，我们可以得到等值面的点面信息。为了进一步完善显示效果，需要调整顶点法向。假设顶点(i, j, k)上的值为f(i, j, k)，采用中心差分方法可以计算该点处的梯度矢量：</p>
<img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95.png" alt="中心差分法" style="zoom:90%;" />

<p>​        对G进行归一化，得到顶点(i, j, k)上的单位法向量，然后对体素单元上8个顶点的法向量进行线性插值就可得到三角面片各个顶点的显示法向量。</p>
<h2 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h2><p>​        由于SPH中使用的平滑核具有有限的支持集h，降低计算复杂度的一种常用方法是使用h大小的网格，然后只需在粒子自己的单元和所有相邻的单元中搜索粒子i的潜在交互伙伴。该技术将力计算步骤的时间复杂度从O（n<sup>2</sup>）降低到O（nm），m是每个网格单元的平均粒子数。</p>
<p>​        通过一个简单的附加技巧，我们可以将模拟速度提高10倍。我们将粒子对象的副本存储在网格单元中(使内存消耗加倍)，而不是存储对粒子的引用。加速的原因是内存中接近插值所需的信息，这大大提高了cash命中率。通过使用希尔伯特空间填充曲线进行更好的聚类，可能进一步加速。快速近邻搜索的数据结构也用于曲面跟踪和渲染。</p>
<p><strong>SPH的求解过程</strong></p>
<p>​        标准SPH的求解过程可以由下图概括（[Kelager2006] ）</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/SPH%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.png" alt="SPH求解过程"></p>
<p>详细的算法过程如下：</p>
<ol>
<li>对于全部的粒子建立空间索引；</li>
<li>对于全部的粒子计算粘性力、合外力，压强，密度，并根据这些力的作用计算粒子的加速度；</li>
<li>根据粒子的加速度与时间步长得到下一时刻的速度和位置（时间积分, Time integration），并处理必要的碰撞。</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li>对于步骤1，由于SPH是考察一个粒子被周围粒子影响效应的叠加，我们需要在整个粒子空间中遍历多次，时间复杂度为<strong>O</strong>(<strong>n</strong>)。加速方法可以采用快速最近邻查找算法（原始文献参见[Teschner2003]）。[Kelager2006] 给这个算法做了一个简单的概括；</li>
<li>对于步骤2，对于某些确定的物理量，我们需要决定哪些粒子对我们考察的粒子产生影响。这些粒子的范围是由核函数的支撑集长度决定的；流体的不可压缩性是由我们人为引入的压强所保证的；</li>
<li>对于步骤3，我们可以使用很多时间积分方法，比如前向欧拉（Forward Euler），蛙跳（Leap Frog）等。蛙跳法的具体形式如下：</li>
</ol>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog4.png" alt="leap_frog4"></p>
<p>​        其中：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog5.png" alt="leap_frog5"></p>
<h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h2><p>​        图R1所示，用2200个粒子对玻璃中的水进行采样。外部旋转力使流体形成漩涡。第一张图（a）显示了单个粒子。对于第二幅图像（b），仅用point splatting渲染自由表面。在这两种模式下，动画以每秒20帧的速度在1.8GHz的Pentium IV PC上运行，并带有Gforce4显卡。当使用marching cubes算法将颜色场的等值面可视化时，会产生最令人信服的结果，如图（c）所示。但是，在这种模式下，帧速率下降到每秒5帧。尽管如此，这种帧速率仍然明显高于大多数离线流体模拟技术，而且随着下一代图形硬件的发展，实时性能将成为可能。</p>
<p>​        图R2所示的图像序列演示了与流体的交互作用。通过鼠标移动，用户产生一个使水飞溅的外力场。自由表面使用point splatting进行渲染，而孤立的粒子绘制为单个液滴。对1300个粒子的模拟以每秒25帧的速度运行。</p>
<p>​        对于图R3中所示的动画，我们使用了3000个粒子，并以每秒5帧的速度用marching cubes技术渲染了表面。</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult1.png" alt="result1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result1.png" class="" title="This is image_result1">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult2.png" alt="result2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result2.png" class="" title="This is image_result2">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult3.png" alt="result3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result3.png" class="" title="This is image_result3">

<h2 id="7-Conclusions-and-FutureWork"><a href="#7-Conclusions-and-FutureWork" class="headerlink" title="7. Conclusions and FutureWork"></a>7. Conclusions and FutureWork</h2><p>​        提出了一种基于粒子的交互式流体模拟与绘制方法。物理模型基于平滑粒子流体力学，并使用特殊用途的核来提高稳定性和速度。我们介绍了跟踪和渲染流体自由表面的技术。结果还不如离线计算的动画那样逼真。然而，考虑到仿真模拟是以交互速率运行的，而不是像今天的离线方法那样每帧花费几分钟或几小时，结果是相当有希望的。</p>
<p>​        在满足物理模型要求的前提下，流体表面的实时跟踪与渲染仍然是一个有待研究的课题。在未来，我们将研究提高采样技术以及提高基于marching cubes算法性能的方法。</p>
<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>​        <strong>哈密顿算子𝛁</strong></p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5CNabla.png" alt="Nabla"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/Nabla.png" class="" title="This is Hamiltonian">

<p>​        𝛁在运算中既有微分又有矢量的双重运算性质。</p>
<p>​        与梯度、散度、旋度的关系：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct2.png" alt="t2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t2.png" class="" title="This is image_t2">

<p>​        把它作用在一个标量场A=f(x,y,z)上，那么：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/grad.png" alt="grad"></p>
<p>​        这个运算可以视为一个矢量和标量的乘法，得到的∇A是一个矢量场，称为A的“梯度”，表示标量场A在某处的变化快慢和方向。</p>
<p>​        而如果把哈密顿算子作用在一个矢量场A上，得到的∇·A称为矢量场A的“散度”，散度的计算和矢量的点积运算相似，得到的是一个标量场。</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/div.png" alt="div"></p>
<p>​        <strong>拉普拉斯算子</strong></p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct3.png" alt="t3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t3.png" class="" title="This is image_t3">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct4.png" alt="t4"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t4.png" class="" title="This is image_t4">

<p>​        </p>
<p>​        在一个时空连续变化的物理场φ(<strong>r</strong>,t)中，运动的观察点观察到的物理量φ的时间变化可以写</p>
<p>为（式中 𝜹𝒓为观察点在微元时间 𝛿𝑡中的矢量位移， 𝜹𝒓=𝛿𝑡 𝒗<sub>𝑂</sub> ，𝛁是哈密顿算子）</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct1.png" alt="t1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t1.png" class="" title="This is image_t1">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 15:58:49" itemprop="dateCreated datePublished" datetime="2020-08-12T15:58:49+08:00">2020-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">编译原理（7）L R分析程序及其自动构造</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:41:36" itemprop="dateCreated datePublished" datetime="2020-05-31T22:41:36+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 10:05:07" itemprop="dateModified" datetime="2020-08-01T10:05:07+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="7-1-LR分析概述"><a href="#7-1-LR分析概述" class="headerlink" title="7.1 LR分析概述"></a>7.1 LR分析概述</h2><p>shift 移进</p>
<p>reduce 归约</p>
<p>acc 接受</p>
<p>空格 error</p>
<p><strong>LR（K）</strong></p>
<ul>
<li>L  从左至右扫描输入符号串</li>
<li>R 构造一个最右推导的逆过程</li>
<li>K 向右顺序查看输入串的K个符号</li>
<li>LR（0）:在分析过程中不需向右查看输入符号。</li>
</ul>
<p>四种分析器： LR(0)  SLR(1)  LR(1)  LALR(1)</p>
<p>SLR(1)和LALR(1)分别是LR(0)和LR(1)的一种改进。</p>
<h3 id="LR分析器模型"><a href="#LR分析器模型" class="headerlink" title="LR分析器模型"></a>LR分析器模型</h3><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614142419341.png" alt="image-20200614142419341" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614142419341.png" class="" title="This is image_a">

<h3 id="LR分析算法"><a href="#LR分析算法" class="headerlink" title="LR分析算法"></a>LR分析算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">置ip指向输入串w的第一个符号</span><br><span class="line">令S为栈顶状态</span><br><span class="line">   a是ip指向的符号</span><br><span class="line">重复 begin</span><br><span class="line">if  ACTION[S,a]&#x3D;Sj</span><br><span class="line">       then   begin  PUSH j,a(进栈)</span><br><span class="line">                     ip 前进(指向下一输入符号)</span><br><span class="line">               end</span><br><span class="line">else if ACTION[S,a]&#x3D;rj     (第j条产生式为A→B)</span><br><span class="line">	then begin</span><br><span class="line">    pop  |β|  项</span><br><span class="line">    令当前栈顶状态为S’</span><br><span class="line">    push GOTO[S’,A]和A(进栈)</span><br><span class="line">    end</span><br><span class="line">    else if ACTION[s,a]&#x3D;acc</span><br><span class="line">        then return (成功）</span><br><span class="line">        else error</span><br><span class="line">    end.重复</span><br><span class="line"></span><br><span class="line">其中，Sj&#x3D;GOTO[Si,X]表示当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj</span><br></pre></td></tr></table></figure>

<h3 id="LR分析程序"><a href="#LR分析程序" class="headerlink" title="LR分析程序"></a>LR分析程序</h3><p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">G[S]: S → a A c B e   [1]   </span><br><span class="line">      A → b           [2] </span><br><span class="line">      A → Ab          [3]		</span><br><span class="line">      B → d           [4]</span><br><span class="line">w&#x3D;abbcde#</span><br><span class="line"></span><br><span class="line">Step   states.   Syms.   The rest of input	action goto</span><br><span class="line">1        0        #            abbcde#           s2</span><br><span class="line">2        02       #a           bbcde#            s4</span><br><span class="line">3        024      #ab          bcde#             r2   goto(2,A)</span><br><span class="line">4        023      #aA          bcde#             s6</span><br><span class="line">5        0236     #aAb         cde#              r3</span><br><span class="line">6        023      #aA          cde#              s5</span><br><span class="line">7        0235     #aAc         de#               s8</span><br><span class="line">8        02358    #aAcd        e#                r4 </span><br><span class="line">9        02357    #aAcB        e#                s9</span><br><span class="line">10       023579   #aAcBe       #                 r1</span><br><span class="line">11       01       #S           #                 acc</span><br></pre></td></tr></table></figure>

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143324736.png" alt="image-20200614143324736" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143324736.png" class="" title="This is image_b">

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143850915.png" alt="image-20200614143850915" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143850915.png" class="" title="This is image_c">

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143916188.png" alt="image-20200614143916188" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143916188.png" class="" title="This is image_d">

<h3 id="构造LR分析表的预备知识"><a href="#构造LR分析表的预备知识" class="headerlink" title="构造LR分析表的预备知识"></a>构造LR分析表的预备知识</h3><p><strong>ＬＲ文法</strong></p>
<ul>
<li>对于一个上下文无关文法, 如果能够构造一张 LR 分析表, 使得它的每一个入口均是唯一的（Sj,rj,acc,空白），则称该上下文无关是LR 文法．</li>
</ul>
<p><strong>活前缀</strong></p>
<ul>
<li>规范句型的前缀，若不含句柄以后的任何符号，则称它为该规范句型的活前缀。</li>
</ul>
<h2 id="7-2-LR（0）分析"><a href="#7-2-LR（0）分析" class="headerlink" title="7.2 LR（0）分析"></a>7.2 LR（0）分析</h2><p> <strong>LR(0)文法</strong></p>
<pre><code>能力最弱，理论上最重要</code></pre><ul>
<li>存在FA 识别活前缀</li>
<li>识别活前缀的DFA如何构造（LR(0)项目集规范族的构造）</li>
<li>LR(0)分析表的构造</li>
</ul>
<p><strong>活前缀</strong></p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614145819899.png" alt="image-20200614145819899" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614145819899.png" class="" title="This is image_e">

<p><strong>LR分析需要构造识别活前缀的有穷自动机</strong></p>
<p>​        我们可以把文法的终结符和非终结符都看成有穷自动机的输入符号，每次把一个符号进栈看成已识别过了该符号，同时状态进行转换，当识别到可归前缀时，相当于在栈中形成句柄，认为达到了识别句柄的终态。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0%5Cimage-20200614150627057.png" alt="f"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614150627057.png" class="" title="This is image_f">

<h3 id="构造识别文法活前缀DFA的三种方法"><a href="#构造识别文法活前缀DFA的三种方法" class="headerlink" title="构造识别文法活前缀DFA的三种方法"></a>构造识别文法活前缀DFA的三种方法</h3><ol>
<li>根据形式定义求出活前缀的正规表达式，然后由此正规表达式构造NFA再确定化为DFA</li>
<li>求出文法的所有项目，按一定规则构造识别活前缀的NFA再确定化为DFA</li>
<li><strong>使用闭包函数（CLOSURE）和转向函数(GOTO(I,X))构造文法G’的LR(0)的项目集规范族，再由转换函数建立状态之间的连接关系得到识别活前缀的DFA</strong></li>
</ol>
<h3 id="构造LR（0）项目集规范族"><a href="#构造LR（0）项目集规范族" class="headerlink" title="构造LR（0）项目集规范族"></a>构造LR（0）项目集规范族</h3><p>LR(0)项目集规范族(构成识别一个文法的活前缀的DFA的状态的全体) 。 </p>
<p>LR（0）项目或配置（ <em>item</em> or <em>configuration）</em>.</p>
<p>—在右端某一位置有圆点的G的产生式</p>
<p>   A → xyz   A → .xyz </p>
<p>​                    A → x.yz</p>
<p>​                    A → xy.z</p>
<p>​                    A → xyz.</p>
<h3 id="活前缀和句柄的关系"><a href="#活前缀和句柄的关系" class="headerlink" title="活前缀和句柄的关系"></a>活前缀和句柄的关系</h3><ol>
<li>活前缀已含有句柄的全部符号，表明产生式A→β的 右部β已出现在栈顶</li>
<li>活前缀只含句柄的一部分符号表明A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>活前缀不含有句柄的任何符号，此时期望A→β的右部所推出的符号串</li>
</ol>
<h3 id="活前缀-与句柄-与-LR-0-项目"><a href="#活前缀-与句柄-与-LR-0-项目" class="headerlink" title="活前缀,与句柄 ,与 LR(0)项目"></a>活前缀,与句柄 ,与 LR(0)项目</h3><p>​        为刻划这种分析过程中的文法G的每一个产生式的右部符号已有多大一部分被识别（出现在栈顶）的情况，分别用标有圆点的产生式来指示位置。</p>
<ul>
<li>A→β．刻划产生式A→β的 右部β已出现在栈顶</li>
<li>A→β1．β2 刻划A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>A→．β 刻划没有句柄的任何符号在栈顶，此时期望A→β的右部所推出的符号串</li>
<li>对于A→ε的LR(0)项目只有A→．</li>
</ul>
<p><strong>LR（0）项目</strong></p>
<p>根据圆点所在的位置和圆点后是终结符还是非终结符或为空把项目分为以下几种：</p>
<ul>
<li>移进项目，形如 A →a • ab  a是终结符, a ,b ∈V* 以下同</li>
<li>待约项目，形如 A →a • Bb</li>
<li>归约项目，形如 A →a • </li>
<li>接受项目，形如 S’ →S • </li>
</ul>
<p>A→ε的LR(0)项目只有A→ •  是归约项目</p>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：文法G:</span><br><span class="line">（0）S&#96;→E     (1) E→aA     (2) E→bB</span><br><span class="line"> (3) A→cA    (4) A→d      (5) B→cB</span><br><span class="line"> (7) B→d</span><br></pre></td></tr></table></figure>

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153148449.png" alt="image-20200614153148449" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153148449.png" class="" title="This is image_g">

<h3 id="LR（0）分析表的构造"><a href="#LR（0）分析表的构造" class="headerlink" title="LR（0）分析表的构造"></a>LR（0）分析表的构造</h3><p>如果每个入口不含多重定义，则称它为文法G的一张LR(0)表。具有LR(0)表的文法G称为一个LR（0）文法。</p>
<p>LR(0)文法是无二义的。</p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153440192.png" alt="image-20200614153440192" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153440192.png" class="" title="This is image_h">

<p>若含有移进/归约冲突，则文法不是LR(0)的</p>
<h2 id="7-3-SLR（1）分析"><a href="#7-3-SLR（1）分析" class="headerlink" title="7.3 SLR（1）分析"></a>7.3 SLR（1）分析</h2><p>若 LR(0) 项目集规范族中有项目集IK含 移进/归约、 归约/归约冲突：</p>
<p>IK   :{ …A→ α .bβ , P ® α . ,   Q ® α .  , …}</p>
<p>存在“移进-归约”和“归约-归约”冲突。</p>
<p>解决冲突的方法是分析含P和Q的句型即考察FOLLOW(P)和FOLLOW(Q)</p>
<p><strong>则解决冲突的SLR(1)技术：</strong></p>
<p>当状态K面临当前输入符号a时：</p>
<ul>
<li>若a=b，则移进</li>
<li>对a ∈ FOLLOW (P) 则  action [ K,a ] =用 P → α  归约 </li>
<li>对a ∈ FOLLOW (Q) 则  action [ K,a ] =用 Q → α 归约</li>
<li>能用SLR(1)技术解决冲突的文法称为SLR(1)文法。</li>
</ul>
<p><strong>SLR(1)文法是无二义的。</strong></p>
<p>数字1的意思是，在分析过程中顶多只要向前看一个符号。</p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614154824752.png" alt="image-20200614154824752" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614154824752.png" class="" title="This is image_i">














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（6）自底向上的优先分析法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:34" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:34+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:55:29" itemprop="dateModified" datetime="2020-08-01T09:55:29+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="6-1-自底向上语法分析概述"><a href="#6-1-自底向上语法分析概述" class="headerlink" title="6.1 自底向上语法分析概述"></a>6.1 自底向上语法分析概述</h2><ul>
<li>自底向上语法分析试图将一个字符串归约至开始符号。</li>
<li>自下而上语法分析比自顶向下语法分析更有效率，对语法的限制更少</li>
<li>“移进-归约”：从输入字符串开始，逐步进行归约直到归约到文法的开始符号。</li>
</ul>
<img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613225725172.png" alt="image-20200613225725172" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225725172.png" class="" title="This is image_a">

<ul>
<li>归约过程恰好是最右推导（规范推导）的逆过程：</li>
</ul>
<img src="编译原理（6）自底向上的优先分析法\image-20200613225824198.png" alt="image-20200613225824198" style="zoom:60%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225824198.png" class="" title="This is image_b">

<ul>
<li><p>规范归约定义：</p>
<p>假定α是文法G的一个句子，我们称序列αn, αn-1,… α0是α的一个规范归约。如果此序列满足：</p>
<p>​      1、 αn= α</p>
<p>​      2、 α0为开始符号。</p>
<pre><code>3、对任何 i, 0&lt;i&lt;=n, αi-1是从αi经把句柄替换为相应产生式的左部符号而得到的。</code></pre></li>
<li><p>规范归约也称最左归约，最右推导称为规范推导。规范推导得到的句型成为规范句型。</p>
</li>
<li><p>如果文法G无二义，则规范推导的逆过程一定是规范归约。</p>
</li>
</ul>
<h3 id="“移进—归约”法的栈实现"><a href="#“移进—归约”法的栈实现" class="headerlink" title="“移进—归约”法的栈实现"></a>“移进—归约”法的栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自顶向下：初始：分析栈：#S    输入串:a1a2…an#</span><br><span class="line">        结束：      #            #（成功）</span><br><span class="line">   分析过程：用产生式的右部替换左部。</span><br><span class="line">   </span><br><span class="line">自底向上：初始：分析栈：#     输入串:a1a2…an#</span><br><span class="line">        结束：      #S           #（成功）</span><br><span class="line">   分析过程：自左至右把输入符号串W的符号一一移进栈里，一旦发现栈顶的一部分符号形成一个可归约串，就把栈中这个子串用相应的归约符号替换。</span><br><span class="line"></span><br><span class="line">四类操作：移进，归约，接受，出错处理。</span><br><span class="line">缺点</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>文法G[E]：<br> E → T + E | T</p>
<p>T → int * T | int | (E)</p>
<img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613231423602.png" alt="image-20200613231423602" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613231423602.png" class="" title="This is image_c">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|int * int + int		移进</span><br><span class="line">int | * int + int	    移进</span><br><span class="line">int  * | int + int	    移进</span><br><span class="line">int * int | + int       规约 T→int</span><br><span class="line">int * T | + int			规约 T→int * T</span><br><span class="line">T | + int				移进</span><br><span class="line">T + | int				移进</span><br><span class="line">T + int | 				规约T → int</span><br><span class="line">T + T |					规约E → T</span><br><span class="line">T + E |					规约E → T + E</span><br><span class="line">E |</span><br></pre></td></tr></table></figure>

<h2 id="6-2-自底向上的优先分析算法"><a href="#6-2-自底向上的优先分析算法" class="headerlink" title="6.2 自底向上的优先分析算法"></a>6.2 自底向上的优先分析算法</h2><h3 id="6-2-1-简单优先分析法"><a href="#6-2-1-简单优先分析法" class="headerlink" title="6.2.1 简单优先分析法"></a>6.2.1 简单优先分析法</h3><ul>
<li>按照文法符号（包括终结符和非终结符）的优先关系确定句柄。</li>
<li>例：</li>
</ul>
<img src="编译原理（6）自底向上的优先分析法\image-20200613235831008.png" alt="image-20200613235831008" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613235831008.png" class="" title="This is image_d">

<h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>•优先关系</p>
<p>​    –X=Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XY…</p>
<p>​    –X&lt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XB…， </p>
<p>​                     且 B=+&gt; Y…</p>
<p>​    –X&gt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…BD…， </p>
<p>​                     且B =+&gt; …X,D =*&gt; Y…</p>
<p>•#的优先级&lt;所有符号，所有符号的优先级&gt;#，这里仅对与#相邻的文法符号而言。</p>
<h4 id="简单优先文法的定义"><a href="#简单优先文法的定义" class="headerlink" title="简单优先文法的定义"></a>简单优先文法的定义</h4><p>满足以下条件的文法是简单优先文法：</p>
<p>（1）在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。（简单优先关系矩阵不含多重入口）</p>
<p>（2）在文法中任意两个产生式没有相同的右部。（例如：F–&gt;a ; B–&gt;a）</p>
<h4 id="简单优先分析法的算法步骤"><a href="#简单优先分析法的算法步骤" class="headerlink" title="简单优先分析法的算法步骤"></a>简单优先分析法的算法步骤</h4><ul>
<li>将输入符号串a1a2…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性&gt;下一个待输入符号aj为止。</li>
<li>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;ak为止。</li>
<li>由句柄ak…ai在文法的产生式中查找右部为ak…ai的产生式，若找到则用相应左部代替句柄，若找不到则为出错。</li>
<li>重复1，2，3步，直到栈中只剩开始符。</li>
</ul>
<h3 id="6-2-2-算符优先分析法"><a href="#6-2-2-算符优先分析法" class="headerlink" title="6.2.2 算符优先分析法"></a>6.2.2 算符优先分析法</h3><ul>
<li><p>某些文法具有“算符”特性</p>
<p>​        –表达式运算符（优先级、结合性）</p>
<p>​        –人为地规定其算符的优先顺序，即给出优先级别和同一级别的结合性</p>
</li>
<li><p>只考虑算符之间的优先关系</p>
</li>
</ul>
<p><img src="F:%5Cblog%5Csource_posts%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602175422247.png" alt="image-20200602175422247"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602175422247.png" class="" title="This is image_e">

<h4 id="如何确定算符优先关系"><a href="#如何确定算符优先关系" class="headerlink" title="如何确定算符优先关系"></a>如何确定算符优先关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）i的优先级最高</span><br><span class="line">（1）↑优先级次于i，右结合</span><br><span class="line">（2）*和&#x2F;优先级次之，左结合</span><br><span class="line">（3）+和-优先级最低，左结合</span><br><span class="line">（4）括号‘(’,‘)’的优先级大于括号外的运算符，小于括号内的运算符，内括号的优先性大于外括号</span><br><span class="line">（5）#的优先性低于与其相邻的算符</span><br></pre></td></tr></table></figure>

<h4 id="算符文法的定义"><a href="#算符文法的定义" class="headerlink" title="算符文法的定义"></a>算符文法的定义</h4><ul>
<li>定义  如果不含空产生式的上下文无关文法 G 中没有形如 U→…VW…的产生式，其中V,W∈VN则称G 为算符文法（OG）。</li>
<li>性质1：在算符文法中任何句型都不包含两个相邻的非终结符.(数学归纳法)</li>
<li>性质2：如 Vx 或 xV 出现在算符文法的句型 a 中，其中V∈VN,x∈VT, 则 a 中任何含 x 的短语必含有V.（反证法）（&lt;+&gt;归约，归约时把E带上&lt;E+E&gt;）</li>
</ul>
<h4 id="算符优先关系的定义"><a href="#算符优先关系的定义" class="headerlink" title="算符优先关系的定义"></a>算符优先关系的定义</h4><p>在OG中 定义 （算符优先关系）</p>
<ul>
<li><p>x = y    G中有形如.U→…xy…或U –&gt; …xVy…的产生式。    </p>
</li>
<li><p>x &lt; y     G中有形如.U →…xW…的产生式,而       W =+&gt; y….或W =+&gt; Vy…</p>
</li>
<li><p>x &gt; y     G中有形如.U → …Wy…的产生式,而        W =+&gt; …x或W =+&gt; … xV</p>
</li>
</ul>
<ul>
<li><p>规定 若 S =+&gt; x… 或  S =+&gt; Vx…  则  # &lt; x</p>
<p>​             S =+&gt; …x  或 S =+&gt; …xV  则  x &gt; #</p>
</li>
</ul>
<h4 id="算符优先文法的定义"><a href="#算符优先文法的定义" class="headerlink" title="算符优先文法的定义"></a>算符优先文法的定义</h4><ul>
<li><p>在 OG文法 G 中，若任意两个终结符间至多有一种算符优先关系存在，则称G 为算符优先文法(OPG)。</p>
<p><strong>–结论 算符优先文法是无二义的。</strong></p>
</li>
</ul>
<h4 id="算符优先关系表的构造"><a href="#算符优先关系表的构造" class="headerlink" title="算符优先关系表的构造"></a>算符优先关系表的构造</h4><ul>
<li>由定义直接构造</li>
<li>由关系图法构造算符优先关系表</li>
</ul>
<p><strong>FIRSTVT</strong> 和 <strong>LASTVT</strong></p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614112149299.png" alt="image-20200614112149299" style="zoom:40%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614112149299.png" class="" title="This is image_f">

<p><strong>如何计算算符优先关系</strong></p>
<p>（1） ‘=‘关系</p>
<p>​        –直接看产生式的右部，若出现了  A →…ab…或A →…aBb,则a=b</p>
<p>（2）’&lt;‘关系</p>
<p>​        –求出每个非终结符B的FIRSTVT(B)</p>
<p>​        –若A→…aB…,则”b∈FIRSTVT(B),a&lt;b</p>
<p>（3）’&gt;’关系</p>
<p>​        –求出每个非终结符B的LASTVT(B)</p>
<p>​        –若A→…Bb…,则”a∈LASTVT(B),a&gt;b</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">文法G[E]：(0) E’→#E#                         FIRSTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (1) E→E+T							FIRSTVT(E)&#x3D;&#123;+,*,↑,(,i&#125;</span><br><span class="line">		 (2) E→T							FIRSTVT(T)&#x3D;&#123;*,↑,(,i&#125;</span><br><span class="line">		 (3) T→T*F							FIRSTVT(F)&#x3D;&#123;↑,(,i&#125;</span><br><span class="line">		 (4) T→F							FIRSTVT(P)&#x3D;&#123;(,i&#125;</span><br><span class="line">		 (5) F→P↑F|P						LASTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (6) P→(E)							LASTVT(E)&#x3D;&#123;+,*,↑,),i&#125;   LASTVT(F)&#x3D;&#123;↑,),i&#125;</span><br><span class="line">		 (7) P→i							LASTVT(T)&#x3D;&#123;*,↑,),i&#125;     LASTVT(P)&#x3D;&#123;),i&#125;</span><br><span class="line"></span><br><span class="line">1)‘&#x3D;’关系</span><br><span class="line">	由产生式(0)和(6),得#&#x3D;#，（&#x3D;）</span><br><span class="line">2）‘&lt;’关系</span><br><span class="line">    找形如：A→…aB…的产生式</span><br><span class="line">    #E：则#&lt;FIRSTVT(E)</span><br><span class="line">    +T: 则+&lt;FIRSTVT(T)  </span><br><span class="line">    *F: 则*&lt;FIRSTVT(F)</span><br><span class="line">    ↑F: 则↑&lt;FIRSTVT(F)</span><br><span class="line">    (E: 则(&lt;FIRSTVT(E)</span><br><span class="line">3)‘&gt;’关系</span><br><span class="line">    找形如：A→…Bb…的产生式</span><br><span class="line">    E# ,则 LASTVT(E)&gt;#</span><br><span class="line">    E+ ,则 LASTVT(E)&gt;+ </span><br><span class="line">    T* ,则 LASTVT(T)&gt;* </span><br><span class="line">    P↑ ,则 LASTVT(P)&gt;↑ </span><br><span class="line">    E) ,则 LASTVT(E)&gt;)</span><br></pre></td></tr></table></figure>

<img src="编译原理（6）自底向上的优先分析法\image-20200614113542961.png" alt="image-20200614113542961" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614113542961.png" class="" title="This is image_g">

<h4 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h4><ul>
<li>归约过程中，只考虑终结符之间的优先关系来确定句柄，而与非终结符无关。这样去掉了对非终结符的归约，所以用算符优先分析法的规约过程与规范归约是不同的，P110.</li>
<li>为解决在算符优先分析过程中如何寻找可归约串，引进<strong>最左素短语</strong>的概念</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算符文法的任一句型有如下形式：</span><br><span class="line">	#N1a1N2a2......NnanNn+1#</span><br><span class="line">	若Niai......NjajNj+1为句柄，则有ai-1&lt;ai&#x3D;ai+1&#x3D;...&#x3D; aj-1 &#x3D; aj&gt; ai+1</span><br><span class="line"></span><br><span class="line">对于算符优先文法，如果aNb(或ab)出现在句型r中</span><br><span class="line">    若a&lt;b，则在r中必含有b而不含a的短语存在</span><br><span class="line">    若a&gt;b，则在r中必含有a而不含b的短语存在</span><br><span class="line">    若a&#x3D;b，则在r中含有a的短语必含有b，反之亦然</span><br></pre></td></tr></table></figure>

<p>定义  </p>
<p>cfg G 的句型的素短语是一个短语，它<strong>至少包含一个终结符</strong>，且除自身外<strong>不再包含其他素短语</strong>。处于句型最左边的素短语为<strong>最左素短语</strong>。</p>
<p>例如：</p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614114837340.png" alt="image-20200614114837340" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614114837340.png" class="" title="This is image_h">

<h4 id="优先函数"><a href="#优先函数" class="headerlink" title="优先函数"></a>优先函数</h4><ul>
<li>优先函数比优先矩阵节省空间</li>
<li>优先函数:从终结符号映射到整数的函数。</li>
<li>若a&lt;b,则f(a)&lt;g(b)</li>
<li>若a=b,则f(a)=g(b)</li>
<li>若a&gt;b,则f(a)&gt;g(b)</li>
</ul>
<p>例如：</p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614115252192.png" alt="image-20200614115252192" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614115252192.png" class="" title="This is image_i">

<p>​    f( * )&lt;g( i ) =&gt; *&lt;i，但f( i )&gt;g( i ) =&gt; i&gt;i是不存在的，所以错误检查能力损失。</p>
<p>​    可通过检查栈顶和输入符号a来发现那些不可比较的情形。</p>
<h4 id="构造优先函数"><a href="#构造优先函数" class="headerlink" title="构造优先函数"></a>构造优先函数</h4><p>（如果有环路则没有优先函数）</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602185248232.png" alt="j"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602185248232.png" class="" title="This is image_j">

<ol>
<li>设a是一个终结符或#，对每一个a建立两个符号fa和ga.</li>
<li>将所有fa和ga组成的集合分为若干组，办法是若a=b则fa和gb在同一组。</li>
<li>画图，结点是2建立的组。对任何a和b，若a&lt;b，则从gb所在的组画一箭弧到fa所在的组；若a&gt;b，则从fa 所在的组画一箭弧到gb所在的组.</li>
<li>若第3步构造的图中有环路，则没有优先函数。若没有环路，令f(a)是从fa 所在的组出发的沿箭弧前进的最长路径的长度。 g(a)是从ga 所在的组出发的沿箭弧前进的最长路径的长度。</li>
</ol>
<h4 id="算符优先分析法的局限性"><a href="#算符优先分析法的局限性" class="headerlink" title="算符优先分析法的局限性"></a>算符优先分析法的局限性</h4><p>很难避免把错误的句子得到正确的归约</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（5）自顶向下语法分析方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:04" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:04+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:36:41" itemprop="dateModified" datetime="2020-08-01T09:36:41+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>句型的分析——分析算法分类：</p>
<p><strong>自上而下分析法：</strong></p>
<p> 从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<p><strong>自下而上分析法：</strong></p>
<p>从输入符号串开始，逐步进行归约（最右推导的逆过程），直至归约到文法的开始符号。</p>
<h2 id="5-1-自上而下语法分析的一般过程"><a href="#5-1-自上而下语法分析的一般过程" class="headerlink" title="5.1 自上而下语法分析的一般过程"></a>5.1 自上而下语法分析的一般过程</h2><p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文法G：    S → cAd    A → ab |a                  </span><br><span class="line">识别输入串  w=cad</span><br><span class="line">试探：推导过程：S =&gt; cAd =&gt; cabd</span><br><span class="line">回溯:试探推导过程：S =&gt; cAd =&gt; cad</span><br></pre></td></tr></table></figure>

<h3 id="一、自上而下语法分析的问题"><a href="#一、自上而下语法分析的问题" class="headerlink" title="一、自上而下语法分析的问题"></a>一、自上而下语法分析的问题</h3><h4 id="5-1-1-左递归问题"><a href="#5-1-1-左递归问题" class="headerlink" title="5.1.1 左递归问题"></a>5.1.1 左递归问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：一个文法是含有左递归的，如果存在非终结符P</span><br><span class="line">                            P &#x3D;&gt; Pα </span><br><span class="line">含有左递归的文法使上述的自上而下分析过程陷入无限循环。</span><br></pre></td></tr></table></figure>

<p>直接左递归 若 P –&gt; Pα | β     （α、β ∈V*且β不以P开头）</p>
<p>间接左递归 若 P =&gt; Pα           S –&gt; Aa     A–&gt;Sb      A–&gt;b</p>
<h4 id="5-1-2-消除左递归"><a href="#5-1-2-消除左递归" class="headerlink" title="5.1.2 消除左递归"></a>5.1.2 消除左递归</h4><p><strong>消除直接左递归：</strong></p>
<p>​        形如：P –&gt; Pα | β         （ α非ε， β不以P打头）</p>
<p>​        改写为：P –&gt; β P’         P’  –&gt;  α P’ | ε</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： E --&gt; E+T|T</span><br><span class="line"><span class="code">    T --&gt; T*F|F</span></span><br><span class="line"><span class="code">    F --&gt; (E)|i</span></span><br><span class="line">G[E]: (1)E --&gt; TE'  (2)E' --&gt; +TE'|ε  </span><br><span class="line"><span class="code">      (2)T --&gt; FT'  (4)T' --&gt; *FT'|ε </span></span><br><span class="line"><span class="code">      (5)F --&gt; (E)|i</span></span><br></pre></td></tr></table></figure>

<p>一般情况：</p>
<p>A –&gt; Aα1 | Aα2| …| Aαm|β1|β2|…|βn</p>
<p>消除左递归后：</p>
<p>A  –&gt;  β1A’|β2A’|…|βnA’</p>
<p>A’ –&gt;  α1A’ | α2A’| …|αmA’|ε</p>
<p><strong>消除间接左递归</strong></p>
<p>间接左递归定义：给定文法G(S) :<br>            S→Qc∣c        Q→Rb∣b          R→Sa∣a</p>
<p>虽然不存在直接左递归，但S、Q、R 都是左递归的，例如有  S⇒Qc⇒Rbc⇒Sabc </p>
<p>要求文法：1. 无回路（A=&gt;A）   2. 无空产生式（不含以ε为右部的产生式）</p>
<p>消除左递归的算法：</p>
<ol>
<li>把文法G的所有非终结符按任一种顺序排列P1, P2, P3…. Pn;</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例：S--&gt;Ac|c  A--&gt;Bb|b   B--&gt;Sa|a</span><br><span class="line">（1）排序：B  A  S</span><br><span class="line">（2）将B代入A： A--&gt;Sab|ab|b</span><br><span class="line"><span class="code">    将A代入S： S--&gt;Sabc|abc|bc|c</span></span><br><span class="line"> 消除S的直接左递归，得到文法：</span><br><span class="line"><span class="code">    S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    A--&gt;Sab|ab|b</span></span><br><span class="line"><span class="code">    B--&gt;Sa|a</span></span><br><span class="line">（3）化简，最终得到结果：</span><br><span class="line"><span class="code">	S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line">（1）排序：S  A  B</span><br><span class="line">（2）将S代入A： A--&gt;Bb|b</span><br><span class="line"><span class="code">	将S、A代入B： B--&gt;Aca|ca|a</span></span><br><span class="line"><span class="code">	            B--&gt;Bbca|bca|ca|a</span></span><br><span class="line">消除B的直接左递归，得到文法：</span><br><span class="line"><span class="code">	S--&gt;Ac|c</span></span><br><span class="line"><span class="code">	A--&gt;Bb|b</span></span><br><span class="line"><span class="code">	B--&gt;bcaB'|caB'|aB'</span></span><br><span class="line"><span class="code">	B'--&gt;bcaB'|ε</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-回溯问题"><a href="#5-1-3-回溯问题" class="headerlink" title="5.1.3 回溯问题"></a>5.1.3 回溯问题</h4><p>定义：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“<strong>回溯</strong>”。</p>
<h4 id="5-1-4-提取左公因子"><a href="#5-1-4-提取左公因子" class="headerlink" title="5.1.4 提取左公因子"></a>5.1.4 提取左公因子</h4><p>提取左公因子：A →αβ1|αβ2</p>
<p>变为： A →αA’         A’ →β1 |β2</p>
<p>若A →αβ1|αβ2 |…|αβn|r</p>
<p>变为：A →αA’          A’ →β1|β2|…|βn</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：S → iEtS|iEtSeS|a      E→b</span><br><span class="line">提取左公因子： S -→ iEtSS’|a </span><br><span class="line"><span class="code">            S’-→ eS|ε</span></span><br><span class="line"><span class="code">            E -→ b</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-递归下降分析法"><a href="#5-2-递归下降分析法" class="headerlink" title="5.2 递归下降分析法"></a>5.2 递归下降分析法</h2><p>递归下降分析器：在消除了左递归和提取左公因子后，可以构造一个不带回溯的自上而下的分析程序。</p>
<p>这个程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">例：G[ E]:    </span><br><span class="line">   (<span class="number">1</span>)   E → TE’    (<span class="number">2</span>)  E’ → +TE’| ε</span><br><span class="line">   (<span class="number">3</span>)   T → FT’    (<span class="number">4</span>)  T’ → *FT’ |ε</span><br><span class="line">   (<span class="number">5</span>)   F → (E)|i</span><br><span class="line"></span><br><span class="line">Procedure E;</span><br><span class="line">     Begin</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T;</span><br><span class="line">     Begin</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br><span class="line">Procedure F;</span><br><span class="line">   IF sym=‘i’ then advance</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       IF sym=‘(’ then</span><br><span class="line">           Begin</span><br><span class="line">              advance;</span><br><span class="line">              E</span><br><span class="line">       IF sym=‘)’ then advance</span><br><span class="line">              <span class="keyword">else</span>  ERROR</span><br><span class="line">           End;</span><br><span class="line">    <span class="keyword">else</span> ERROR;</span><br><span class="line">Procedure E’;</span><br><span class="line">   IF sym=‘+’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T’;</span><br><span class="line">   IF sym=‘*’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-非递归的预测分析方法（LL-1-）"><a href="#5-3-非递归的预测分析方法（LL-1-）" class="headerlink" title="5.3 非递归的预测分析方法（LL(1)）"></a>5.3 非递归的预测分析方法（LL(1)）</h2><h3 id="一、总控程序"><a href="#一、总控程序" class="headerlink" title="一、总控程序"></a>一、总控程序</h3><img src="编译原理（5）自顶向下语法分析方法\image-20200601224211773.png" alt="image-20200601224211773" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/image-20200601224211773.png" class="" title="This is image_a">

<p>分析算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">   首先把‘#’，然后把文法开始符号推入栈；把第一个输入符号读进a;    FLAG：=TRUE；</span><br><span class="line">WHILE FLAG  DO      </span><br><span class="line">BEGIN</span><br><span class="line">   把栈顶符号上托出去并放在Ｘ中；</span><br><span class="line">   IF X ∈ Vt  </span><br><span class="line">   		THEN  </span><br><span class="line">       		IF X=a  </span><br><span class="line">       			THEN</span><br><span class="line">       				把下一个输入符号读进a</span><br><span class="line">　     	   ELSE ERROR      </span><br><span class="line">   ELSE  IF X=‘#’ </span><br><span class="line">   		THEN</span><br><span class="line">            IF X=a  </span><br><span class="line">       			 THEN  </span><br><span class="line">       				 FLAG:=FALSE</span><br><span class="line">            ELSE ERROR</span><br><span class="line">   ELSE IF M[X,a]=&#123;X-&gt;X1X2..XK&#125;</span><br><span class="line">          THEN   </span><br><span class="line">              把XK，X K<span class="number">-1</span>,..,X1一一推进栈 </span><br><span class="line">          ELSE　ERROR</span><br><span class="line">   END OF WHILE;</span><br><span class="line">STOP<span class="comment">/*分析成功，过程完毕*／</span></span><br><span class="line"><span class="comment">END</span></span><br></pre></td></tr></table></figure>

<h3 id="二、预测分析表M的构造"><a href="#二、预测分析表M的构造" class="headerlink" title="二、预测分析表M的构造"></a>二、预测分析表M的构造</h3><p>​                                                            ——LL（1）文法及其分析程序</p>
<p>FIRST集和FOLLOW集 </p>
<p>设G=(VT, VN, S, P)是上下文无关文法</p>
<p>FIRST（α）= {a|α =&gt; aβ, a∈VT, α, β∈V*}</p>
<p>FOLLOW（A）= {a|S =&gt;…Aa…, a ∈VT}</p>
<h4 id="5-3-1-first集"><a href="#5-3-1-first集" class="headerlink" title="5.3.1 first集"></a>5.3.1 first集</h4><p>（1）为什么要引入first集的概念？</p>
<ul>
<li>因为有公共左因子的问题，公共左公因子是指在文法的产生式集合中，某个非终结符的多个候选式具有相同的前缀。</li>
<li>一般来说，公共左公因子的产生式为 </li>
</ul>
<p>$$<br>A→αβ1│αβ2<br>$$</p>
<ul>
<li><p>如果有公共左因子的问题，那么只能采取试探的方法来分析每一个候选式，分析的过程很可能产生回溯，回溯分析法是一种不确定的方法。</p>
</li>
<li><p>若所有候选式都没有公共左因子就可以选择惟一匹配的候选式，不会产生(公共左公因子引起的)回溯。</p>
</li>
<li><p>为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望 </p>
<p>​        要么只有一个候选式可用</p>
<p>​        要么没有候选式可用</p>
<p>因此引入以下FIRST集合的概念:</p>
</li>
<li><p>对α∈(VT⋃VN)∗,有<br>$$<br>FIRST(α)＝ { {a|α⟹a⋅⋅⋅,a∈VT} }<br>$$<br>特别地，若α⟹ε,  则ε∈FIRST(α)</p>
</li>
</ul>
<p>（2）推导算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对每一文法X∈V，计算first（X）：</span><br><span class="line">	①X∈Vt，则first（X）&#x3D;&#123;X&#125; </span><br><span class="line">    ②X∈Vn（非终结符），且有X-&gt;a , 则a∈first（X）</span><br><span class="line">    ③X∈Vn（非终结符），且有X-&gt;# , 若#∈first（X）</span><br><span class="line">    ④若有X，Y1,Y2,Y3...∈Vn，且有产生式X-&gt;Y1,Y2,Y3&#x3D;&gt;#,则first（Y1）-&#123;#&#125;，first（Y2）-&#123;#&#125;...first（Yi）都属于first（X）找中</span><br><span class="line">	重复②-④</span><br><span class="line">⑤当所有Yi&#x3D;&gt;#   则first（X）&#x3D; first（Y1）-&#123;#&#125; ∪ first（Y2）-&#123;#&#125;..... ∪ first（Yi）</span><br><span class="line">当有X-&gt;# ，才能说#∈first（X）</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-follow集"><a href="#5-3-2-follow集" class="headerlink" title="5.3.2 follow集"></a>5.3.2 follow集</h4><p>（1）为什么要引入follow集的概念？</p>
<p>​        当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了一个文法符号的<strong>后跟符号</strong>集合。 </p>
<p>（2）推导算法（PS：求follow集，都是从开始符号S开始推导）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计算follow集:</span><br><span class="line">	①设S为起始，&#123;#&#125;加入follow（S）</span><br><span class="line">    ②要求follow（B），若A-&gt;aBb是一个产生式，则把first（b）的非空元素加入follow（B）中</span><br><span class="line">	③若b-&gt;#,则把follow（A）加入follow（B）中</span><br><span class="line">解释：因为若D-&gt;xAy,A-&gt;aBb, 则 D-&gt;xaBby,且b&#x3D;#，则first（y）或者说是follow(A)∈follow(B)</span><br><span class="line">就是所求符号的右边如果等于# 则不停找上一级</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-select集"><a href="#5-3-3-select集" class="headerlink" title="5.3.3 select集"></a>5.3.3 select集</h4><p>select(X-&gt;Y)，先求first（Y），如果first（Y）存在#∈first（Y）的情况，则再求follow（X），最后求两者的并集即可</p>
<p>例：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>是否</th>
<th>Frist集</th>
<th>Follow集</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ #,   ’,’ ,  )  }</td>
</tr>
<tr>
<td align="left">T</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ ) }</td>
</tr>
<tr>
<td align="left">N</td>
<td>是</td>
<td>{ ‘,’  ,  # }</td>
<td>{ ) }</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Select(S-&gt;a) &#x3D;first（a）&#x3D; &#123;a&#125;</span><br><span class="line">Select(S-&gt;^) &#x3D;first（^）&#x3D;&#123;^&#125;</span><br><span class="line">Select(S-&gt;(T)) &#x3D;first（ （T）  ）&#x3D;&#123; ( &#125;</span><br><span class="line">Select(T-&gt;SN) &#x3D; first(S)&#x3D;&#123;a,^,(&#125;</span><br><span class="line">Select(N-&gt;,SN)&#x3D;first( , ) &#x3D;&#123; , &#125;</span><br><span class="line">Select(N-&gt;#) &#x3D;follow(N) &#x3D; &#123; ) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-4-预测分析表构造算法"><a href="#5-3-4-预测分析表构造算法" class="headerlink" title="5.3.4 预测分析表构造算法"></a>5.3.4 预测分析表构造算法</h4><p>1.对文法G的每个产生式Ａ→a执行第二步和第三步；</p>
<p>2.对每个终结符a∈FIRST(α)，把Ａ→α加至M[A,a]中，</p>
<p>3.若ε∈FIRST(α)，则对任何b∈FOLLOW(A)， 把Ａ→α加至M[A,b]中，</p>
<p>4.把所有无定义的M[A,a]标上“出错标志”。</p>
<h3 id="三、LL（1）文法"><a href="#三、LL（1）文法" class="headerlink" title="三、LL（1）文法"></a>三、LL（1）文法</h3><p>一个文法G，若它的分析表M不含多重定义入口，则称为LL（1）文法。</p>
<p>例：</p>
<p>文法S→iEtS|iEtSeS|a     E→b</p>
<p>不是LL（1）文法。</p>
<p>一个LL（1）文法是无二义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个文法G是LL（1）的，当且仅当对于G的每一个非终结符Ａ的任何两个不同产生式Ａ→α|β，下面的条件成立：</span><br><span class="line">1.FIRST（α）∩ FIRST(β) &#x3D; φ</span><br><span class="line">	也就是，α和β推导不出以同一个终结符a为首的符号串；它们不应该都能推出空字ε．</span><br><span class="line">2.假若β&#x3D;&gt;ε，那么FIRST（α) ∩ FOLLOW（A）＝ φ</span><br><span class="line">	也就是，若β&#x3D;&gt;ε.则α所能推出的串的首符号不应在FOLLOW(A）中．</span><br><span class="line">  结论：</span><br><span class="line">  		LL(1)文法是无二义的．</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理（4）词法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:39:22" itemprop="dateCreated datePublished" datetime="2020-05-31T22:39:22+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:34:30" itemprop="dateModified" datetime="2020-08-01T09:34:30+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>词法分析程序亦称为扫描器。</p>
<p>扫描器的任务是识别基本的语法单位——单词；</p>
<p>扫描器的输出是语法分析程序的输入。</p>
<p><strong>词法分析程序的设计和实现</strong>：</p>
<p>首先需要描述和刻画语言中的原子单位——单词，其次需要识别单词和执行某些相关的动作。描述程序设计语言的词法的机制是3型文法和正则表达式，识别机制是有穷状态自动机。</p>
<h2 id="4-1-词法分析程序"><a href="#4-1-词法分析程序" class="headerlink" title="4.1 词法分析程序"></a>4.1 词法分析程序</h2><p><strong>词法分析（lexical analysis）</strong></p>
<p>–逐个读入源程序字符并按照构词规则切分成一系列单词。   </p>
<p>–单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。</p>
<p>–词法分析是编译过程中的一个阶段，在语法分析前进行 。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" alt="a"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" class="" title="This is image_a">

<ul>
<li><p>主要任务：</p>
<p>–读源程序，产生单词符号，并转换为token表示</p>
</li>
<li><p>其他任务：</p>
<p>–滤掉空格，删除注释、换行符</p>
<p>–对行列计数</p>
<p>–发现并定位词法错误，并尽量改正</p>
<p>–建立符号表、常数表等表格，……</p>
</li>
</ul>
<h3 id="4-1-1-词法分析器的输入缓冲区"><a href="#4-1-1-词法分析器的输入缓冲区" class="headerlink" title="4.1.1 词法分析器的输入缓冲区"></a>4.1.1 词法分析器的输入缓冲区</h3><h3 id="4-1-2-词法分析器的输出"><a href="#4-1-2-词法分析器的输出" class="headerlink" title="4.1.2 词法分析器的输出"></a>4.1.2 词法分析器的输出</h3><ul>
<li><p>单词符号一般可分为下列五种：</p>
<p>–基本字，关键字</p>
<p>–标识符</p>
<p>–常数（量）</p>
<p>–运算符</p>
<p>–界符</p>
</li>
<li><p>输出的二元式（token）表示：（单词种别，单词自身的值）</p>
</li>
<li><p>Token的种类：</p>
<p>​    1、有些单词，只需要值，如基本字；</p>
<p>​    2、有些单词，还需要其他信息，如标示符。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： A:&#x3D;B+2                                                            </span><br><span class="line">(Id的整数码,指向A的符号表的入口指针）   ($28, Aaddr)       </span><br><span class="line">(运算符的整数码,’:&#x3D;’)                                                     </span><br><span class="line">(Id的整数码,指向B的符号表的入口指针)        </span><br><span class="line">(运算符的整数码,’+’)                                            </span><br><span class="line">(常数的整数码, 2)</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-以状态转换图为例设计词法分析器"><a href="#4-1-3-以状态转换图为例设计词法分析器" class="headerlink" title="4.1.3 以状态转换图为例设计词法分析器"></a>4.1.3 以状态转换图为例设计词法分析器</h3><img src="编译原理（4）词法分析/image-20200613110111799.png" alt="image-20200613110111799" style="zoom:60%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613110111799.png" class="" title="This is image_b">

<h2 id="4-2-正规表达式与正规集（正规语言）"><a href="#4-2-正规表达式与正规集（正规语言）" class="headerlink" title="4.2 正规表达式与正规集（正规语言）"></a>4.2 正规表达式与正规集（正规语言）</h2><ul>
<li><p>正规表达式（regular expression）是描述单词符号的一种方便工具，也是定义正规集的工具。</p>
</li>
<li><p>定义（正规式和它所表示的正规集）：</p>
<p>–设字母表为Σ，辅助字母表Σ`={Ф，ε，|，·，*，(，)}。</p>
<p>–1) ε和Ф都是Σ上的正规式，它们所表示的正规集分别为{ε}和{ }；</p>
<p>–2) 任何a∈Σ，a是Σ上的一个正规式，它所表示的正规集为{a}；</p>
<p>–3) 假定e1和e2都是Σ上的正规式，它们所表示的正规集分别为L(e1)和L(e2)，那么，(e1), e1| e2, e1·e2, e1* 也都是正规式，它们所表示的正规集分别为L(e1), L(e1)∪L(e2), L(e1)L(e2)和(L(e1))*。</p>
<p>–4) 仅由有限次使用上述三步骤而定义的表达式才是Σ上的正规式，仅由这些正规式所表示的字集才是Σ上的正规集。</p>
<img src="编译原理（4）词法分析/image-20200613112425500.png" alt="image-20200613112425500" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613112425500.png" class="" title="This is image_c">

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例1  令Σ&#x3D;&#123;a，b&#125;， Σ上的正规式和相应的正规集的例子有：</span><br><span class="line">    正规式			 正规集</span><br><span class="line">    a			   &#123;a&#125;</span><br><span class="line">    a|b			   &#123;a,b&#125;</span><br><span class="line">    ab			   &#123;ab&#125;</span><br><span class="line">    (a|b)(a|b)	   &#123;aa,ab,ba,bb&#125;</span><br><span class="line">    a* 			   &#123;ε,a,aa, ……任意个a的串&#125;</span><br><span class="line">    (a|b)*		   &#123;ε,a,b,aa,ab ……所有由a和b组成的串&#125;</span><br><span class="line">	(a|b)*(aa|bb)(a|b)*    &#123;Σ*上所有含有两个相继的a或两个相继的b组成的串&#125;</span><br><span class="line">	</span><br><span class="line">例3 Σ&#x3D;&#123;d，.，e，+，-&#125;,则Σ上的正规式 d*(.dd*|ε)(e(+|-|ε)dd*|ε )</span><br><span class="line">	表示的是无符号数的集合。其中d为0~9的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>若两个正规式e1和e2所表示的正规集相同,则说e1和e2等价,写作e1=e2。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如： e1&#x3D; (a|b)， e2 &#x3D; b|a</span><br><span class="line"></span><br><span class="line">又如： e1&#x3D; b(ab)* ,  e2 &#x3D;(ba)*b				</span><br><span class="line">	  e1&#x3D; (a|b)* ,  e2 &#x3D;(a*|b*)*</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设r,s,t为正规式，正规式服从的代数规律有：</p>
<p>–1、r|s=s|r                    “或”服从交换律</p>
<p>–2、r|(s|t)=(r|s)|t        “或”的可结合律</p>
<p>–3、(rs)t=r(st)                “连接”的可结合律</p>
<p>–4、r(s|t)=rs|rt      (s|t)r=sr|tr    分配律 </p>
<p>–5、εr=r, rε=r                 ε是“连接”的恒等元素 零一律</p>
<p>–6、 r|r=r    <strong>r* =ε|r+    r+=rr*</strong> </p>
</li>
<li><p>文法的定义</p>
<p>–G={VN,VT,P,S}</p>
<p>–VN：非终结符的非空有穷集</p>
<p>–VT：终结符的非空有穷集</p>
<p>–P： 产生式的非空有穷集</p>
<p>​         a→b  a∈( VN∪VT )* 且至少含一个非终结符， b∈( VN∪VT )*</p>
<p>–S：∈VN，称为开始符号</p>
</li>
<li><p>正规文法： G的任何产生式为A→aB或A→a，其中a∈VT ∪ ε ，A，B∈VN</p>
</li>
</ul>
<p><strong>对任意一个正规文法，存在一个定义同一个语言的正规式；反之亦然。</strong></p>
<p>Σ上的<strong>正规式=&gt;正规文法</strong></p>
<p>初始VT= Σ, S∈VN ，生成正规产生式(或定义式) :S→r （r为正规式）     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(R1) 对形如 A→r1r2的正规产生式： A→r1B           </span><br><span class="line">							 B→r2               </span><br><span class="line">							 B∈VN                   </span><br><span class="line">(R2)对形如A→r*r1的正规产生式：   A→rB          </span><br><span class="line">							 A→r1          </span><br><span class="line">							 B→rB          </span><br><span class="line">							 B→r1   B∈VN                                </span><br><span class="line">(R3)对形如A→r1|r2的正规产生式:  A→r1        </span><br><span class="line">							 A→r2</span><br></pre></td></tr></table></figure>

<p>不断应用R做变换，直到每个产生式右端只含一个VN</p>
<p><strong>正规文法=&gt;正规式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正规文法                      正规式</span><br><span class="line">A→xB, B→y      转换成： 	  A&#x3D;xy 			</span><br><span class="line">A→xA|y         转换成：       A&#x3D;x*y </span><br><span class="line">A→x|y          转换成：       A&#x3D;x|y</span><br></pre></td></tr></table></figure>

<h2 id="4-3-有穷自动机"><a href="#4-3-有穷自动机" class="headerlink" title="4.3 有穷自动机"></a>4.3 有穷自动机</h2><h3 id="4-3-1-确定的有穷自动机DFA"><a href="#4-3-1-确定的有穷自动机DFA" class="headerlink" title="4.3.1 确定的有穷自动机DFA"></a>4.3.1 确定的有穷自动机DFA</h3><p><strong>DFA定义：</strong></p>
<p>一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中</p>
<p>​    1、K是一个有穷集，它的每个元素称为一个状态；</p>
<p>​    2、Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号字母表；</p>
<p>​    3、f是转换函数，是在K×Σ→K上的映射，即，如f（ki，a）=kj，（ki∈K，kj∈K）就意味着，当前状态为ki，输入符为a时，将转换为下一个状态kj，我们把kj称作ki的一个后继状态；</p>
<p>​    4、S∈K是唯一的一个初态；</p>
<p>​    5、Z 包含于 K是一个终态集，终态也称可接受状态或结束状态。</p>
<p><strong>DFA例：</strong></p>
<img src="编译原理（4）词法分析/image-20200613160754459.png" alt="image-20200613160754459" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160754459.png" class="" title="This is image_d">

<p><strong>DFA的状态转换图表示：</strong></p>
<img src="编译原理（4）词法分析\image-20200613160815782.png" alt="image-20200613160815782" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160815782.png" class="" title="This is image_e">

<p><strong>DFA</strong> <strong>的矩阵表示</strong></p>
<img src="编译原理（4）词法分析\image-20200613160908110.png" alt="image-20200613160908110" style="zoom:70%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160908110.png" class="" title="This is image_f">

<p><strong>DFA M的作用：</strong></p>
<p> 对于∑*中的任何字符串t，若存在一条从初态结到某一终态结的道路，且这条路上所有弧的标记符连接成的字符串等于t，则称t可为DFA M所接受（识别）。若M的初态结同时又是终态结，则空字可为M所识别（接受）。</p>
<ul>
<li><p>∑*上的符号串t被M接受的形式叙述：</p>
<p>若t∈∑*，f (S，t)=P，其中S为 M的开始状态，P ∈ Z，Z为终态集。</p>
<p>则称t为DFA M所<strong>接受</strong>（<strong>识别</strong>）。</p>
</li>
<li><p>∑*上的符号串t在M上运行的定义：</p>
<p>一个输入符号串t，（我们将它表示成 t1tx的形式，其中t1 ∈∑，tx∈ ∑<em>）在DFA M上*</em>运行**的定义为：</p>
<p>f（Q， t1 tx ）=f（f（Q， t1 ），tx） 其中Q∈K                         </p>
</li>
</ul>
<p>例：证明t=baab被前例中的DFA所接受</p>
<img src="编译原理（4）词法分析\image-20200613183717517.png" alt="image-20200613183717517" style="zoom:55%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613183717517.png" class="" title="This is image_g">

<p>所识别的语言：含有相继两个a或相继两个b的串。</p>
<p>DFA M所能接受的符号串的全体记为 L(M)(语言)</p>
<p><strong>结论：</strong></p>
<p>– Σ上一个符号串集V 包含于 Σ*是正规的，当且仅当存在一个Σ上的确定有穷自动机M，使得V=L(M)。</p>
<h3 id="4-3-2-不确定的有穷自动机NFA"><a href="#4-3-2-不确定的有穷自动机NFA" class="headerlink" title="4.3.2 不确定的有穷自动机NFA"></a>4.3.2 不确定的有穷自动机NFA</h3><p>NFA定义：</p>
<p>N={K，Σ，f，S，Z}，其中K为状态的有穷非空集，Σ为有穷输入字母表，f为Kx Σ*到K的子集（2^K）的一种映射，S 包含于 K是初始状态集，Z 包含于 K为终止状态集。</p>
<ul>
<li><p>例子</p>
<p>NFA N=（{S，P，Z}，{0，1}，f，{S，P}，{Z}）</p>
<p>其中 f（S，0）={P}</p>
<p>​        f（S，1）={S，Z}</p>
<p>​        f（P，1）={Z}</p>
<p>​        f（Z，0）={P}</p>
<p>​        f（Z，1）={P}</p>
<p>状态图表示：</p>
</li>
</ul>
<img src="编译原理（4）词法分析\image-20200613184408840.png" alt="image-20200613184408840" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613184408840.png" class="" title="This is image_h">

<ul>
<li>∑*上的符号串t在NFA N上运行</li>
<li>∑*上的符号串t被NFA N接受</li>
<li>具有ε转移的不确定的有穷自动机NFA… f为 K x（Σ ∪{ε}）到K的子集（2^K）的一种映射</li>
<li>对任何一个具有ε转移的不确定的有穷自动机NFA　N，一定存在一个不具有ε转移的不确定的有穷自动机NFA　Ｍ ，使得L(M)=L(N)。</li>
</ul>
<h3 id="4-3-3-NFA的确定化"><a href="#4-3-3-NFA的确定化" class="headerlink" title="4.3.3 NFA的确定化"></a>4.3.3 NFA的确定化</h3><p>DFA是NFA的特例。对每个NFA N一定存在一个DFA M ，使得L(M)=L(N)。对每个NFA N存在着与之等价的DFA M。与某一NFA等价的DFA不唯一。</p>
<p><strong>定义对状态集合I的几个有关运算：</strong></p>
<ol>
<li>状态集合 I 的 ε- 闭包，表示为 ε-closure(I)，定义为一状态集，是状态集 I 中的任何状态S经任意条ε弧而能到达的状态的集合。状态集合 I 的任何状态S都属于 ε-closure(I)。</li>
<li>状态集合 I 的a弧转换，表示为 move(I,a) 定义为状态集合 J，其中 J 是所有那些可从 I 的某一状态经过一条a弧而到达的状态的全体。定义 Ia = ε-closure(J)</li>
</ol>
<p>例：</p>
<img src="编译原理（4）词法分析\image-20200613190857433.png" alt="image-20200613190857433" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190857433.png" class="" title="This is image_i">

<img src="编译原理（4）词法分析\image-20200613190905154.png" alt="image-20200613190905154" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190905154.png" class="" title="This is image_j">

<p>假设NFA N=(K, Σ, f, K0, Kt)按如下办法构造一个DFA M=(S, Σ, d, S0, St)，使得L(M)=L(N)：</p>
<ol>
<li><p>M的状态集S由K的一些子集组成。用[S1 S2… Sj ]表示S的元素，其中S1, S2,,… Sj是K的状态。并且约定，状态S1, S2,… Sj 是按某种规则排列的，即对于子集{S1, S2}={ S2, S1,}来说，S的状态就是[S1 S2]；</p>
</li>
<li><p>M和N的输入字母表是相同的，即是 Σ ；</p>
</li>
<li><p>转换函数是这样定义的：                    </p>
<p> d([S1 S2,… Sj],a)= [R1R2… Rt]  其中   {R1,R2,… , Rt} = ε-closure(move({S1, S2,,… Sj},a)) </p>
</li>
<li><p>S0=ε-closure(K0)为M的开始状态；</p>
</li>
<li><p>St={[Si Sk… Se]，其中[Si  Sk… Se]∈S且{Si , Sk,,… Se}∩Kt≠Φ}</p>
</li>
</ol>
<p><strong>NFA确定化例子：</strong></p>
<img src="编译原理（4）词法分析\image-20200613192154391.png" alt="image-20200613192154391" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192154391.png" class="" title="This is image_k">

<img src="编译原理（4）词法分析\image-20200613192229903.png" alt="image-20200613192229903" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192229903.png" class="" title="This is image_l">

<img src="编译原理（4）词法分析\image-20200613205712090.png" alt="image-20200613205712090" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613205712090.png" class="" title="This is image_m">

<h2 id="4-4-有穷自动机和正规表达式"><a href="#4-4-有穷自动机和正规表达式" class="headerlink" title="4.4 有穷自动机和正规表达式"></a>4.4 有穷自动机和正规表达式</h2><p><strong>有穷自动机和正规表达式的等价性：</strong>   </p>
<ul>
<li>对于∑上的一个NFA M，可以构造一个∑上的正规式R,使得L(R)=L(M)。</li>
<li>对于∑上的一个正规式R，可以构造一个∑上的NFA M，使的L(M)=L(R)。</li>
</ul>
<p><strong>正规式 =&gt;有穷自动机</strong></p>
<p>设给定正规式W，则构造相应自动机的方法如下：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" alt="n"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" class="" title="This is image_n">

<p>然后利用以下规则加入结点和箭弧，直到得到自动机为止。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" alt="o"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" class="" title="This is image_o">

<p><strong>有穷自动机=&gt;正规式</strong></p>
<p>首先检查是否只有一个终态结点，若有多个，则引入新结点T，从所有终态结点引ε边到T结点，并令T为唯一的终态结点。</p>
<p>然后按以下规则消除结点与箭弧：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" alt="p"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" class="" title="This is image_p">

<h2 id="4-5-有穷自动机和正规文法"><a href="#4-5-有穷自动机和正规文法" class="headerlink" title="4.5 有穷自动机和正规文法"></a>4.5 有穷自动机和正规文法</h2><p><strong>有穷自动机和正规文法的等价性：</strong>     </p>
<ul>
<li>对于一个NFA M，都存在 一个正规文法G，使得L(G)=L(M).               </li>
<li>对于一个正规文法G,都存在一个NFA M，使得L(M)=L(G). </li>
</ul>
<p><strong>正规文法=&gt;自动机</strong></p>
<ul>
<li>字母表与G的终结符集相同；</li>
<li>G中的非终结符对应状态，开始符对应开始状态</li>
<li>增加一个新的终结状态Z。</li>
<li>G中的A-&gt;tB构造转换函数f(A,t)=B</li>
<li>G中的A-&gt;t构造转换函数f(A,t)=Z</li>
</ul>
<p><strong>自动机=&gt;正规文法</strong></p>
<ul>
<li>对转换函数f(A,t)=B，对应产生式：   A-&gt;tB</li>
<li>对终态Z，增加一产生式： Z-&gt;ε</li>
<li>NFA的初态对应文法的开始符号；</li>
<li>NFA的字母表对应文法的终结符号集。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Daphne Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daphne Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

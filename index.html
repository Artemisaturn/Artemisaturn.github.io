<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"artemisaturn.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://artemisaturn.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Daphne Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://artemisaturn.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/07/30/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/30/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-30 23:19:22" itemprop="dateCreated datePublished" datetime="2020-07-30T23:19:22+08:00">2020-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-31 08:21:36" itemprop="dateModified" datetime="2020-07-31T08:21:36+08:00">2020-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>dasdfasfd</p>
<p><img src="test/aaa.png" alt="aaa"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">编译原理（7）L R分析程序及其自动构造</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:41:36" itemprop="dateCreated datePublished" datetime="2020-05-31T22:41:36+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-14 15:48:49" itemprop="dateModified" datetime="2020-06-14T15:48:49+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="7-1-LR分析概述"><a href="#7-1-LR分析概述" class="headerlink" title="7.1 LR分析概述"></a>7.1 LR分析概述</h2><p>shift 移进</p>
<p>reduce 归约</p>
<p>acc 接受</p>
<p>空格 error</p>
<p><strong>LR（K）</strong></p>
<ul>
<li>L  从左至右扫描输入符号串</li>
<li>R 构造一个最右推导的逆过程</li>
<li>K 向右顺序查看输入串的K个符号</li>
<li>LR（0）:在分析过程中不需向右查看输入符号。</li>
</ul>
<p>四种分析器： LR(0)  SLR(1)  LR(1)  LALR(1)</p>
<p>SLR(1)和LALR(1)分别是LR(0)和LR(1)的一种改进。</p>
<h3 id="LR分析器模型"><a href="#LR分析器模型" class="headerlink" title="LR分析器模型"></a>LR分析器模型</h3><img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614142419341.png" alt="image-20200614142419341" style="zoom:80%;" />

<h3 id="LR分析算法"><a href="#LR分析算法" class="headerlink" title="LR分析算法"></a>LR分析算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">置ip指向输入串w的第一个符号</span><br><span class="line">令S为栈顶状态</span><br><span class="line">   a是ip指向的符号</span><br><span class="line">重复 begin</span><br><span class="line">if  ACTION[S,a]&#x3D;Sj</span><br><span class="line">       then   begin  PUSH j,a(进栈)</span><br><span class="line">                     ip 前进(指向下一输入符号)</span><br><span class="line">               end</span><br><span class="line">else if ACTION[S,a]&#x3D;rj     (第j条产生式为A→B)</span><br><span class="line">	then begin</span><br><span class="line">    pop  |β|  项</span><br><span class="line">    令当前栈顶状态为S’</span><br><span class="line">    push GOTO[S’,A]和A(进栈)</span><br><span class="line">    end</span><br><span class="line">    else if ACTION[s,a]&#x3D;acc</span><br><span class="line">        then return (成功）</span><br><span class="line">        else error</span><br><span class="line">    end.重复</span><br><span class="line"></span><br><span class="line">其中，Sj&#x3D;GOTO[Si,X]表示当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj</span><br></pre></td></tr></table></figure>

<h3 id="LR分析程序"><a href="#LR分析程序" class="headerlink" title="LR分析程序"></a>LR分析程序</h3><p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">G[S]: S → a A c B e   [1]   </span><br><span class="line">      A → b           [2] </span><br><span class="line">      A → Ab          [3]		</span><br><span class="line">      B → d           [4]</span><br><span class="line">w&#x3D;abbcde#</span><br><span class="line"></span><br><span class="line">Step   states.   Syms.   The rest of input	action goto</span><br><span class="line">1        0        #            abbcde#           s2</span><br><span class="line">2        02       #a           bbcde#            s4</span><br><span class="line">3        024      #ab          bcde#             r2   goto(2,A)</span><br><span class="line">4        023      #aA          bcde#             s6</span><br><span class="line">5        0236     #aAb         cde#              r3</span><br><span class="line">6        023      #aA          cde#              s5</span><br><span class="line">7        0235     #aAc         de#               s8</span><br><span class="line">8        02358    #aAcd        e#                r4 </span><br><span class="line">9        02357    #aAcB        e#                s9</span><br><span class="line">10       023579   #aAcBe       #                 r1</span><br><span class="line">11       01       #S           #                 acc</span><br></pre></td></tr></table></figure>

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614143324736.png" alt="image-20200614143324736" style="zoom:90%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614143850915.png" alt="image-20200614143850915" style="zoom:80%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614143916188.png" alt="image-20200614143916188" style="zoom:80%;" />

<h3 id="构造LR分析表的预备知识"><a href="#构造LR分析表的预备知识" class="headerlink" title="构造LR分析表的预备知识"></a>构造LR分析表的预备知识</h3><p><strong>ＬＲ文法</strong></p>
<ul>
<li>对于一个上下文无关文法, 如果能够构造一张 LR 分析表, 使得它的每一个入口均是唯一的（Sj,rj,acc,空白），则称该上下文无关是LR 文法．</li>
</ul>
<p><strong>活前缀</strong></p>
<ul>
<li>规范句型的前缀，若不含句柄以后的任何符号，则称它为该规范句型的活前缀。</li>
</ul>
<h2 id="7-2-LR（0）分析"><a href="#7-2-LR（0）分析" class="headerlink" title="7.2 LR（0）分析"></a>7.2 LR（0）分析</h2><p> <strong>LR(0)文法</strong></p>
<pre><code>能力最弱，理论上最重要</code></pre><ul>
<li>存在FA 识别活前缀</li>
<li>识别活前缀的DFA如何构造（LR(0)项目集规范族的构造）</li>
<li>LR(0)分析表的构造</li>
</ul>
<p><strong>活前缀</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614145819899.png" alt="image-20200614145819899" style="zoom:80%;" />

<p><strong>LR分析需要构造识别活前缀的有穷自动机</strong></p>
<p>​        我们可以把文法的终结符和非终结符都看成有穷自动机的输入符号，每次把一个符号进栈看成已识别过了该符号，同时状态进行转换，当识别到可归前缀时，相当于在栈中形成句柄，认为达到了识别句柄的终态。</p>
<p>![image-20200614150627057](C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614150627057.png)</p>
<h3 id="构造识别文法活前缀DFA的三种方法"><a href="#构造识别文法活前缀DFA的三种方法" class="headerlink" title="构造识别文法活前缀DFA的三种方法"></a>构造识别文法活前缀DFA的三种方法</h3><ol>
<li>根据形式定义求出活前缀的正规表达式，然后由此正规表达式构造NFA再确定化为DFA</li>
<li>求出文法的所有项目，按一定规则构造识别活前缀的NFA再确定化为DFA</li>
<li><strong>使用闭包函数（CLOSURE）和转向函数(GOTO(I,X))构造文法G’的LR(0)的项目集规范族，再由转换函数建立状态之间的连接关系得到识别活前缀的DFA</strong></li>
</ol>
<h3 id="构造LR（0）项目集规范族"><a href="#构造LR（0）项目集规范族" class="headerlink" title="构造LR（0）项目集规范族"></a>构造LR（0）项目集规范族</h3><p>LR(0)项目集规范族(构成识别一个文法的活前缀的DFA的状态的全体) 。 </p>
<p>LR（0）项目或配置（ <em>item</em> or <em>configuration）</em>.</p>
<p>—在右端某一位置有圆点的G的产生式</p>
<p>   A → xyz   A → .xyz </p>
<p>​                    A → x.yz</p>
<p>​                    A → xy.z</p>
<p>​                    A → xyz.</p>
<h3 id="活前缀和句柄的关系"><a href="#活前缀和句柄的关系" class="headerlink" title="活前缀和句柄的关系"></a>活前缀和句柄的关系</h3><ol>
<li>活前缀已含有句柄的全部符号，表明产生式A→β的 右部β已出现在栈顶</li>
<li>活前缀只含句柄的一部分符号表明A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>活前缀不含有句柄的任何符号，此时期望A→β的右部所推出的符号串</li>
</ol>
<h3 id="活前缀-与句柄-与-LR-0-项目"><a href="#活前缀-与句柄-与-LR-0-项目" class="headerlink" title="活前缀,与句柄 ,与 LR(0)项目"></a>活前缀,与句柄 ,与 LR(0)项目</h3><p>​        为刻划这种分析过程中的文法G的每一个产生式的右部符号已有多大一部分被识别（出现在栈顶）的情况，分别用标有圆点的产生式来指示位置。</p>
<ul>
<li>A→β．刻划产生式A→β的 右部β已出现在栈顶</li>
<li>A→β1．β2 刻划A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>A→．β 刻划没有句柄的任何符号在栈顶，此时期望A→β的右部所推出的符号串</li>
<li>对于A→ε的LR(0)项目只有A→．</li>
</ul>
<p><strong>LR（0）项目</strong></p>
<p>根据圆点所在的位置和圆点后是终结符还是非终结符或为空把项目分为以下几种：</p>
<ul>
<li>移进项目，形如 A →a • ab  a是终结符, a ,b ∈V* 以下同</li>
<li>待约项目，形如 A →a • Bb</li>
<li>归约项目，形如 A →a • </li>
<li>接受项目，形如 S’ →S • </li>
</ul>
<p>A→ε的LR(0)项目只有A→ •  是归约项目</p>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：文法G:</span><br><span class="line">（0）S&#96;→E     (1) E→aA     (2) E→bB</span><br><span class="line"> (3) A→cA    (4) A→d      (5) B→cB</span><br><span class="line"> (7) B→d</span><br></pre></td></tr></table></figure>

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614153148449.png" alt="image-20200614153148449" style="zoom:40%;" />

<h3 id="LR（0）分析表的构造"><a href="#LR（0）分析表的构造" class="headerlink" title="LR（0）分析表的构造"></a>LR（0）分析表的构造</h3><p>如果每个入口不含多重定义，则称它为文法G的一张LR(0)表。具有LR(0)表的文法G称为一个LR（0）文法。</p>
<p>LR(0)文法是无二义的。</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614153440192.png" alt="image-20200614153440192" style="zoom:90%;" />

<p>若含有移进/归约冲突，则文法不是LR(0)的</p>
<h2 id="7-3-SLR（1）分析"><a href="#7-3-SLR（1）分析" class="headerlink" title="7.3 SLR（1）分析"></a>7.3 SLR（1）分析</h2><p>若 LR(0) 项目集规范族中有项目集IK含 移进/归约、 归约/归约冲突：</p>
<p>IK   :{ …A→ α .bβ , P ® α . ,   Q ® α .  , …}</p>
<p>存在“移进-归约”和“归约-归约”冲突。</p>
<p>解决冲突的方法是分析含P和Q的句型即考察FOLLOW(P)和FOLLOW(Q)</p>
<p><strong>则解决冲突的SLR(1)技术：</strong></p>
<p>当状态K面临当前输入符号a时：</p>
<ul>
<li>若a=b，则移进</li>
<li>对a ∈ FOLLOW (P) 则  action [ K,a ] =用 P → α  归约 </li>
<li>对a ∈ FOLLOW (Q) 则  action [ K,a ] =用 Q → α 归约</li>
<li>能用SLR(1)技术解决冲突的文法称为SLR(1)文法。</li>
</ul>
<p><strong>SLR(1)文法是无二义的。</strong></p>
<p>数字1的意思是，在分析过程中顶多只要向前看一个符号。</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614154824752.png" alt="image-20200614154824752" style="zoom:50%;" />














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（6）自底向上的优先分析法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:34" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:34+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-14 11:56:56" itemprop="dateModified" datetime="2020-06-14T11:56:56+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="6-1-自底向上语法分析概述"><a href="#6-1-自底向上语法分析概述" class="headerlink" title="6.1 自底向上语法分析概述"></a>6.1 自底向上语法分析概述</h2><ul>
<li>自底向上语法分析试图将一个字符串归约至开始符号。</li>
<li>自下而上语法分析比自顶向下语法分析更有效率，对语法的限制更少</li>
<li>“移进-归约”：从输入字符串开始，逐步进行归约直到归约到文法的开始符号。</li>
</ul>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613225725172.png" alt="image-20200613225725172" style="zoom:50%;" />

<ul>
<li>归约过程恰好是最右推导（规范推导）的逆过程：</li>
</ul>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613225824198.png" alt="image-20200613225824198" style="zoom:60%;" />

<ul>
<li><p>规范归约定义：</p>
<p>假定α是文法G的一个句子，我们称序列αn, αn-1,… α0是α的一个规范归约。如果此序列满足：</p>
<p>​      1、 αn= α</p>
<p>​      2、 α0为开始符号。</p>
<pre><code>3、对任何 i, 0&lt;i&lt;=n, αi-1是从αi经把句柄替换为相应产生式的左部符号而得到的。</code></pre></li>
<li><p>规范归约也称最左归约，最右推导称为规范推导。规范推导得到的句型成为规范句型。</p>
</li>
<li><p>如果文法G无二义，则规范推导的逆过程一定是规范归约。</p>
</li>
</ul>
<h3 id="“移进—归约”法的栈实现"><a href="#“移进—归约”法的栈实现" class="headerlink" title="“移进—归约”法的栈实现"></a>“移进—归约”法的栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自顶向下：初始：分析栈：#S    输入串:a1a2…an#</span><br><span class="line">        结束：      #            #（成功）</span><br><span class="line">   分析过程：用产生式的右部替换左部。</span><br><span class="line">   </span><br><span class="line">自底向上：初始：分析栈：#     输入串:a1a2…an#</span><br><span class="line">        结束：      #S           #（成功）</span><br><span class="line">   分析过程：自左至右把输入符号串W的符号一一移进栈里，一旦发现栈顶的一部分符号形成一个可归约串，就把栈中这个子串用相应的归约符号替换。</span><br><span class="line"></span><br><span class="line">四类操作：移进，归约，接受，出错处理。</span><br><span class="line">缺点</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>文法G[E]：<br> E → T + E | T</p>
<p>T → int * T | int | (E)</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613231423602.png" alt="image-20200613231423602" style="zoom:70%;" />

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|int * int + int		移进</span><br><span class="line">int | * int + int	    移进</span><br><span class="line">int  * | int + int	    移进</span><br><span class="line">int * int | + int       规约 T→int</span><br><span class="line">int * T | + int			规约 T→int * T</span><br><span class="line">T | + int				移进</span><br><span class="line">T + | int				移进</span><br><span class="line">T + int | 				规约T → int</span><br><span class="line">T + T |					规约E → T</span><br><span class="line">T + E |					规约E → T + E</span><br><span class="line">E |</span><br></pre></td></tr></table></figure>

<h2 id="6-2-自底向上的优先分析算法"><a href="#6-2-自底向上的优先分析算法" class="headerlink" title="6.2 自底向上的优先分析算法"></a>6.2 自底向上的优先分析算法</h2><h3 id="6-2-1-简单优先分析法"><a href="#6-2-1-简单优先分析法" class="headerlink" title="6.2.1 简单优先分析法"></a>6.2.1 简单优先分析法</h3><ul>
<li>按照文法符号（包括终结符和非终结符）的优先关系确定句柄。</li>
<li>例：</li>
</ul>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235831008.png" alt="image-20200613235831008" style="zoom:80%;" />

<h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>•优先关系</p>
<p>​    –X=Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XY…</p>
<p>​    –X&lt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XB…， </p>
<p>​                     且 B=+&gt; Y…</p>
<p>​    –X&gt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…BD…， </p>
<p>​                     且B =+&gt; …X,D =*&gt; Y…</p>
<p>•#的优先级&lt;所有符号，所有符号的优先级&gt;#，这里仅对与#相邻的文法符号而言。</p>
<h4 id="简单优先文法的定义"><a href="#简单优先文法的定义" class="headerlink" title="简单优先文法的定义"></a>简单优先文法的定义</h4><p>满足以下条件的文法是简单优先文法：</p>
<p>（1）在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。（简单优先关系矩阵不含多重入口）</p>
<p>（2）在文法中任意两个产生式没有相同的右部。（例如：F–&gt;a ; B–&gt;a）</p>
<h4 id="简单优先分析法的算法步骤"><a href="#简单优先分析法的算法步骤" class="headerlink" title="简单优先分析法的算法步骤"></a>简单优先分析法的算法步骤</h4><ul>
<li>将输入符号串a1a2…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性&gt;下一个待输入符号aj为止。</li>
<li>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;ak为止。</li>
<li>由句柄ak…ai在文法的产生式中查找右部为ak…ai的产生式，若找到则用相应左部代替句柄，若找不到则为出错。</li>
<li>重复1，2，3步，直到栈中只剩开始符。</li>
</ul>
<h3 id="6-2-2-算符优先分析法"><a href="#6-2-2-算符优先分析法" class="headerlink" title="6.2.2 算符优先分析法"></a>6.2.2 算符优先分析法</h3><ul>
<li><p>某些文法具有“算符”特性</p>
<p>​        –表达式运算符（优先级、结合性）</p>
<p>​        –人为地规定其算符的优先顺序，即给出优先级别和同一级别的结合性</p>
</li>
<li><p>只考虑算符之间的优先关系</p>
</li>
</ul>
<p>![image-20200602175422247](C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200602175422247.png)</p>
<h4 id="如何确定算符优先关系"><a href="#如何确定算符优先关系" class="headerlink" title="如何确定算符优先关系"></a>如何确定算符优先关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）i的优先级最高</span><br><span class="line">（1）↑优先级次于i，右结合</span><br><span class="line">（2）*和&#x2F;优先级次之，左结合</span><br><span class="line">（3）+和-优先级最低，左结合</span><br><span class="line">（4）括号‘(’,‘)’的优先级大于括号外的运算符，小于括号内的运算符，内括号的优先性大于外括号</span><br><span class="line">（5）#的优先性低于与其相邻的算符</span><br></pre></td></tr></table></figure>

<h4 id="算符文法的定义"><a href="#算符文法的定义" class="headerlink" title="算符文法的定义"></a>算符文法的定义</h4><ul>
<li>定义  如果不含空产生式的上下文无关文法 G 中没有形如 U→…VW…的产生式，其中V,W∈VN则称G 为算符文法（OG）。</li>
<li>性质1：在算符文法中任何句型都不包含两个相邻的非终结符.(数学归纳法)</li>
<li>性质2：如 Vx 或 xV 出现在算符文法的句型 a 中，其中V∈VN,x∈VT, 则 a 中任何含 x 的短语必含有V.（反证法）（&lt;+&gt;归约，归约时把E带上&lt;E+E&gt;）</li>
</ul>
<h4 id="算符优先关系的定义"><a href="#算符优先关系的定义" class="headerlink" title="算符优先关系的定义"></a>算符优先关系的定义</h4><p>在OG中 定义 （算符优先关系）</p>
<ul>
<li><p>x = y    G中有形如.U→…xy…或U –&gt; …xVy…的产生式。    </p>
</li>
<li><p>x &lt; y     G中有形如.U →…xW…的产生式,而       W =+&gt; y….或W =+&gt; Vy…</p>
</li>
<li><p>x &gt; y     G中有形如.U → …Wy…的产生式,而        W =+&gt; …x或W =+&gt; … xV</p>
</li>
</ul>
<ul>
<li><p>规定 若 S =+&gt; x… 或  S =+&gt; Vx…  则  # &lt; x</p>
<p>​             S =+&gt; …x  或 S =+&gt; …xV  则  x &gt; #</p>
</li>
</ul>
<h4 id="算符优先文法的定义"><a href="#算符优先文法的定义" class="headerlink" title="算符优先文法的定义"></a>算符优先文法的定义</h4><ul>
<li><p>在 OG文法 G 中，若任意两个终结符间至多有一种算符优先关系存在，则称G 为算符优先文法(OPG)。</p>
<p><strong>–结论 算符优先文法是无二义的。</strong></p>
</li>
</ul>
<h4 id="算符优先关系表的构造"><a href="#算符优先关系表的构造" class="headerlink" title="算符优先关系表的构造"></a>算符优先关系表的构造</h4><ul>
<li>由定义直接构造</li>
<li>由关系图法构造算符优先关系表</li>
</ul>
<p><strong>FIRSTVT</strong> 和 <strong>LASTVT</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614112149299.png" alt="image-20200614112149299" style="zoom:40%;" />

<p><strong>如何计算算符优先关系</strong></p>
<p>（1） ‘=‘关系</p>
<p>​        –直接看产生式的右部，若出现了  A →…ab…或A →…aBb,则a=b</p>
<p>（2）’&lt;‘关系</p>
<p>​        –求出每个非终结符B的FIRSTVT(B)</p>
<p>​        –若A→…aB…,则”b∈FIRSTVT(B),a&lt;b</p>
<p>（3）’&gt;’关系</p>
<p>​        –求出每个非终结符B的LASTVT(B)</p>
<p>​        –若A→…Bb…,则”a∈LASTVT(B),a&gt;b</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">文法G[E]：(0) E’→#E#                         FIRSTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (1) E→E+T							FIRSTVT(E)&#x3D;&#123;+,*,↑,(,i&#125;</span><br><span class="line">		 (2) E→T							FIRSTVT(T)&#x3D;&#123;*,↑,(,i&#125;</span><br><span class="line">		 (3) T→T*F							FIRSTVT(F)&#x3D;&#123;↑,(,i&#125;</span><br><span class="line">		 (4) T→F							FIRSTVT(P)&#x3D;&#123;(,i&#125;</span><br><span class="line">		 (5) F→P↑F|P						LASTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (6) P→(E)							LASTVT(E)&#x3D;&#123;+,*,↑,),i&#125;   LASTVT(F)&#x3D;&#123;↑,),i&#125;</span><br><span class="line">		 (7) P→i							LASTVT(T)&#x3D;&#123;*,↑,),i&#125;     LASTVT(P)&#x3D;&#123;),i&#125;</span><br><span class="line"></span><br><span class="line">1)‘&#x3D;’关系</span><br><span class="line">	由产生式(0)和(6),得#&#x3D;#，（&#x3D;）</span><br><span class="line">2）‘&lt;’关系</span><br><span class="line">    找形如：A→…aB…的产生式</span><br><span class="line">    #E：则#&lt;FIRSTVT(E)</span><br><span class="line">    +T: 则+&lt;FIRSTVT(T)  </span><br><span class="line">    *F: 则*&lt;FIRSTVT(F)</span><br><span class="line">    ↑F: 则↑&lt;FIRSTVT(F)</span><br><span class="line">    (E: 则(&lt;FIRSTVT(E)</span><br><span class="line">3)‘&gt;’关系</span><br><span class="line">    找形如：A→…Bb…的产生式</span><br><span class="line">    E# ,则 LASTVT(E)&gt;#</span><br><span class="line">    E+ ,则 LASTVT(E)&gt;+ </span><br><span class="line">    T* ,则 LASTVT(T)&gt;* </span><br><span class="line">    P↑ ,则 LASTVT(P)&gt;↑ </span><br><span class="line">    E) ,则 LASTVT(E)&gt;)</span><br></pre></td></tr></table></figure>

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614113542961.png" alt="image-20200614113542961" style="zoom:70%;" />

<h4 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h4><ul>
<li>归约过程中，只考虑终结符之间的优先关系来确定句柄，而与非终结符无关。这样去掉了对非终结符的归约，所以用算符优先分析法的规约过程与规范归约是不同的，P110.</li>
<li>为解决在算符优先分析过程中如何寻找可归约串，引进<strong>最左素短语</strong>的概念</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算符文法的任一句型有如下形式：</span><br><span class="line">	#N1a1N2a2......NnanNn+1#</span><br><span class="line">	若Niai......NjajNj+1为句柄，则有ai-1&lt;ai&#x3D;ai+1&#x3D;...&#x3D; aj-1 &#x3D; aj&gt; ai+1</span><br><span class="line"></span><br><span class="line">对于算符优先文法，如果aNb(或ab)出现在句型r中</span><br><span class="line">    若a&lt;b，则在r中必含有b而不含a的短语存在</span><br><span class="line">    若a&gt;b，则在r中必含有a而不含b的短语存在</span><br><span class="line">    若a&#x3D;b，则在r中含有a的短语必含有b，反之亦然</span><br></pre></td></tr></table></figure>

<p>定义  </p>
<p>cfg G 的句型的素短语是一个短语，它<strong>至少包含一个终结符</strong>，且除自身外<strong>不再包含其他素短语</strong>。处于句型最左边的素短语为<strong>最左素短语</strong>。</p>
<p>例如：</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614114837340.png" alt="image-20200614114837340" style="zoom:80%;" />

<h4 id="优先函数"><a href="#优先函数" class="headerlink" title="优先函数"></a>优先函数</h4><ul>
<li>优先函数比优先矩阵节省空间</li>
<li>优先函数:从终结符号映射到整数的函数。</li>
<li>若a&lt;b,则f(a)&lt;g(b)</li>
<li>若a=b,则f(a)=g(b)</li>
<li>若a&gt;b,则f(a)&gt;g(b)</li>
</ul>
<p>例如：</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200614115252192.png" alt="image-20200614115252192" style="zoom:80%;" />

<p>​    f( * )&lt;g( i ) =&gt; *&lt;i，但f( i )&gt;g( i ) =&gt; i&gt;i是不存在的，所以错误检查能力损失。</p>
<p>​    可通过检查栈顶和输入符号a来发现那些不可比较的情形。</p>
<h4 id="构造优先函数"><a href="#构造优先函数" class="headerlink" title="构造优先函数"></a>构造优先函数</h4><p>（如果有环路则没有优先函数）</p>
<p>![image-20200602185248232](C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200602185248232.png)</p>
<ol>
<li>设a是一个终结符或#，对每一个a建立两个符号fa和ga.</li>
<li>将所有fa和ga组成的集合分为若干组，办法是若a=b则fa和gb在同一组。</li>
<li>画图，结点是2建立的组。对任何a和b，若a&lt;b，则从gb所在的组画一箭弧到fa所在的组；若a&gt;b，则从fa 所在的组画一箭弧到gb所在的组.</li>
<li>若第3步构造的图中有环路，则没有优先函数。若没有环路，令f(a)是从fa 所在的组出发的沿箭弧前进的最长路径的长度。 g(a)是从ga 所在的组出发的沿箭弧前进的最长路径的长度。</li>
</ol>
<h4 id="算符优先分析法的局限性"><a href="#算符优先分析法的局限性" class="headerlink" title="算符优先分析法的局限性"></a>算符优先分析法的局限性</h4><p>很难避免把错误的句子得到正确的归约</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（5）自顶向下语法分析方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:04" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:04+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-14 16:26:16" itemprop="dateModified" datetime="2020-06-14T16:26:16+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>句型的分析——分析算法分类：</p>
<p><strong>自上而下分析法：</strong></p>
<p> 从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<p><strong>自下而上分析法：</strong></p>
<p>从输入符号串开始，逐步进行归约（最右推导的逆过程），直至归约到文法的开始符号。</p>
<h2 id="5-1-自上而下语法分析的一般过程"><a href="#5-1-自上而下语法分析的一般过程" class="headerlink" title="5.1 自上而下语法分析的一般过程"></a>5.1 自上而下语法分析的一般过程</h2><p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文法G：    S → cAd    A → ab |a                  </span><br><span class="line">识别输入串  w=cad</span><br><span class="line">试探：推导过程：S =&gt; cAd =&gt; cabd</span><br><span class="line">回溯:试探推导过程：S =&gt; cAd =&gt; cad</span><br></pre></td></tr></table></figure>

<h3 id="一、自上而下语法分析的问题"><a href="#一、自上而下语法分析的问题" class="headerlink" title="一、自上而下语法分析的问题"></a>一、自上而下语法分析的问题</h3><h4 id="5-1-1-左递归问题"><a href="#5-1-1-左递归问题" class="headerlink" title="5.1.1 左递归问题"></a>5.1.1 左递归问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：一个文法是含有左递归的，如果存在非终结符P</span><br><span class="line">                            P &#x3D;&gt; Pα </span><br><span class="line">含有左递归的文法使上述的自上而下分析过程陷入无限循环。</span><br></pre></td></tr></table></figure>

<p>直接左递归 若 P –&gt; Pα | β     （α、β ∈V*且β不以P开头）</p>
<p>间接左递归 若 P =&gt; Pα           S –&gt; Aa     A–&gt;Sb      A–&gt;b</p>
<h4 id="5-1-2-消除左递归"><a href="#5-1-2-消除左递归" class="headerlink" title="5.1.2 消除左递归"></a>5.1.2 消除左递归</h4><p><strong>消除直接左递归：</strong></p>
<p>​        形如：P –&gt; Pα | β         （ α非ε， β不以P打头）</p>
<p>​        改写为：P –&gt; β P’         P’  –&gt;  α P’ | ε</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： E --&gt; E+T|T</span><br><span class="line"><span class="code">    T --&gt; T*F|F</span></span><br><span class="line"><span class="code">    F --&gt; (E)|i</span></span><br><span class="line">G[E]: (1)E --&gt; TE'  (2)E' --&gt; +TE'|ε  </span><br><span class="line"><span class="code">      (2)T --&gt; FT'  (4)T' --&gt; *FT'|ε </span></span><br><span class="line"><span class="code">      (5)F --&gt; (E)|i</span></span><br></pre></td></tr></table></figure>

<p>一般情况：</p>
<p>A –&gt; Aα1 | Aα2| …| Aαm|β1|β2|…|βn</p>
<p>消除左递归后：</p>
<p>A  –&gt;  β1A’|β2A’|…|βnA’</p>
<p>A’ –&gt;  α1A’ | α2A’| …|αmA’|ε</p>
<p><strong>消除间接左递归</strong></p>
<p>间接左递归定义：给定文法G(S) :<br>            S→Qc∣c        Q→Rb∣b          R→Sa∣a</p>
<p>虽然不存在直接左递归，但S、Q、R 都是左递归的，例如有  S⇒Qc⇒Rbc⇒Sabc </p>
<p>要求文法：1. 无回路（A=&gt;A）   2. 无空产生式（不含以ε为右部的产生式）</p>
<p>消除左递归的算法：</p>
<ol>
<li>把文法G的所有非终结符按任一种顺序排列P1, P2, P3…. Pn;</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例：S--&gt;Ac|c  A--&gt;Bb|b   B--&gt;Sa|a</span><br><span class="line">（1）排序：B  A  S</span><br><span class="line">（2）将B代入A： A--&gt;Sab|ab|b</span><br><span class="line"><span class="code">    将A代入S： S--&gt;Sabc|abc|bc|c</span></span><br><span class="line"> 消除S的直接左递归，得到文法：</span><br><span class="line"><span class="code">    S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    A--&gt;Sab|ab|b</span></span><br><span class="line"><span class="code">    B--&gt;Sa|a</span></span><br><span class="line">（3）化简，最终得到结果：</span><br><span class="line"><span class="code">	S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line">（1）排序：S  A  B</span><br><span class="line">（2）将S代入A： A--&gt;Bb|b</span><br><span class="line"><span class="code">	将S、A代入B： B--&gt;Aca|ca|a</span></span><br><span class="line"><span class="code">	            B--&gt;Bbca|bca|ca|a</span></span><br><span class="line">消除B的直接左递归，得到文法：</span><br><span class="line"><span class="code">	S--&gt;Ac|c</span></span><br><span class="line"><span class="code">	A--&gt;Bb|b</span></span><br><span class="line"><span class="code">	B--&gt;bcaB'|caB'|aB'</span></span><br><span class="line"><span class="code">	B'--&gt;bcaB'|ε</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-回溯问题"><a href="#5-1-3-回溯问题" class="headerlink" title="5.1.3 回溯问题"></a>5.1.3 回溯问题</h4><p>定义：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“<strong>回溯</strong>”。</p>
<h4 id="5-1-4-提取左公因子"><a href="#5-1-4-提取左公因子" class="headerlink" title="5.1.4 提取左公因子"></a>5.1.4 提取左公因子</h4><p>提取左公因子：A →αβ1|αβ2</p>
<p>变为： A →αA’         A’ →β1 |β2</p>
<p>若A →αβ1|αβ2 |…|αβn|r</p>
<p>变为：A →αA’          A’ →β1|β2|…|βn</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：S → iEtS|iEtSeS|a      E→b</span><br><span class="line">提取左公因子： S -→ iEtSS’|a </span><br><span class="line"><span class="code">            S’-→ eS|ε</span></span><br><span class="line"><span class="code">            E -→ b</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-递归下降分析法"><a href="#5-2-递归下降分析法" class="headerlink" title="5.2 递归下降分析法"></a>5.2 递归下降分析法</h2><p>递归下降分析器：在消除了左递归和提取左公因子后，可以构造一个不带回溯的自上而下的分析程序。</p>
<p>这个程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">例：G[ E]:    </span><br><span class="line">   (<span class="number">1</span>)   E → TE’    (<span class="number">2</span>)  E’ → +TE’| ε</span><br><span class="line">   (<span class="number">3</span>)   T → FT’    (<span class="number">4</span>)  T’ → *FT’ |ε</span><br><span class="line">   (<span class="number">5</span>)   F → (E)|i</span><br><span class="line"></span><br><span class="line">Procedure E;</span><br><span class="line">     Begin</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T;</span><br><span class="line">     Begin</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br><span class="line">Procedure F;</span><br><span class="line">   IF sym=‘i’ then advance</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       IF sym=‘(’ then</span><br><span class="line">           Begin</span><br><span class="line">              advance;</span><br><span class="line">              E</span><br><span class="line">       IF sym=‘)’ then advance</span><br><span class="line">              <span class="keyword">else</span>  ERROR</span><br><span class="line">           End;</span><br><span class="line">    <span class="keyword">else</span> ERROR;</span><br><span class="line">Procedure E’;</span><br><span class="line">   IF sym=‘+’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T’;</span><br><span class="line">   IF sym=‘*’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-非递归的预测分析方法（LL-1-）"><a href="#5-3-非递归的预测分析方法（LL-1-）" class="headerlink" title="5.3 非递归的预测分析方法（LL(1)）"></a>5.3 非递归的预测分析方法（LL(1)）</h2><h3 id="一、总控程序"><a href="#一、总控程序" class="headerlink" title="一、总控程序"></a>一、总控程序</h3><img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200601224211773.png" alt="image-20200601224211773" style="zoom:80%;" />

<p>分析算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">   首先把‘#’，然后把文法开始符号推入栈；把第一个输入符号读进a;    FLAG：=TRUE；</span><br><span class="line">WHILE FLAG  DO      </span><br><span class="line">BEGIN</span><br><span class="line">   把栈顶符号上托出去并放在Ｘ中；</span><br><span class="line">   IF X ∈ Vt  </span><br><span class="line">   		THEN  </span><br><span class="line">       		IF X=a  </span><br><span class="line">       			THEN</span><br><span class="line">       				把下一个输入符号读进a</span><br><span class="line">　     	   ELSE ERROR      </span><br><span class="line">   ELSE  IF X=‘#’ </span><br><span class="line">   		THEN</span><br><span class="line">            IF X=a  </span><br><span class="line">       			 THEN  </span><br><span class="line">       				 FLAG:=FALSE</span><br><span class="line">            ELSE ERROR</span><br><span class="line">   ELSE IF M[X,a]=&#123;X-&gt;X1X2..XK&#125;</span><br><span class="line">          THEN   </span><br><span class="line">              把XK，X K<span class="number">-1</span>,..,X1一一推进栈 </span><br><span class="line">          ELSE　ERROR</span><br><span class="line">   END OF WHILE;</span><br><span class="line">STOP<span class="comment">/*分析成功，过程完毕*／</span></span><br><span class="line"><span class="comment">END</span></span><br></pre></td></tr></table></figure>

<h3 id="二、预测分析表M的构造"><a href="#二、预测分析表M的构造" class="headerlink" title="二、预测分析表M的构造"></a>二、预测分析表M的构造</h3><p>​                                                            ——LL（1）文法及其分析程序</p>
<p>FIRST集和FOLLOW集 </p>
<p>设G=(VT, VN, S, P)是上下文无关文法</p>
<p>FIRST（α）= {a|α =&gt; aβ, a∈VT, α, β∈V*}</p>
<p>FOLLOW（A）= {a|S =&gt;…Aa…, a ∈VT}</p>
<h4 id="5-3-1-first集"><a href="#5-3-1-first集" class="headerlink" title="5.3.1 first集"></a>5.3.1 first集</h4><p>（1）为什么要引入first集的概念？</p>
<ul>
<li>因为有公共左因子的问题，公共左公因子是指在文法的产生式集合中，某个非终结符的多个候选式具有相同的前缀。</li>
<li>一般来说，公共左公因子的产生式为 </li>
</ul>
<p>$$<br>A→αβ1│αβ2<br>$$</p>
<ul>
<li><p>如果有公共左因子的问题，那么只能采取试探的方法来分析每一个候选式，分析的过程很可能产生回溯，回溯分析法是一种不确定的方法。</p>
</li>
<li><p>若所有候选式都没有公共左因子就可以选择惟一匹配的候选式，不会产生(公共左公因子引起的)回溯。</p>
</li>
<li><p>为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望 </p>
<p>​        要么只有一个候选式可用</p>
<p>​        要么没有候选式可用</p>
<p>因此引入以下FIRST集合的概念:</p>
</li>
<li><p>对α∈(VT⋃VN)∗,有<br>$$<br>FIRST(α)＝ { {a|α⟹a⋅⋅⋅,a∈VT} }<br>$$<br>特别地，若α⟹ε,  则ε∈FIRST(α)</p>
</li>
</ul>
<p>（2）推导算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对每一文法X∈V，计算first（X）：</span><br><span class="line">	①X∈Vt，则first（X）&#x3D;&#123;X&#125; </span><br><span class="line">    ②X∈Vn（非终结符），且有X-&gt;a , 则a∈first（X）</span><br><span class="line">    ③X∈Vn（非终结符），且有X-&gt;# , 若#∈first（X）</span><br><span class="line">    ④若有X，Y1,Y2,Y3...∈Vn，且有产生式X-&gt;Y1,Y2,Y3&#x3D;&gt;#,则first（Y1）-&#123;#&#125;，first（Y2）-&#123;#&#125;...first（Yi）都属于first（X）找中</span><br><span class="line">	重复②-④</span><br><span class="line">⑤当所有Yi&#x3D;&gt;#   则first（X）&#x3D; first（Y1）-&#123;#&#125; ∪ first（Y2）-&#123;#&#125;..... ∪ first（Yi）</span><br><span class="line">当有X-&gt;# ，才能说#∈first（X）</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-follow集"><a href="#5-3-2-follow集" class="headerlink" title="5.3.2 follow集"></a>5.3.2 follow集</h4><p>（1）为什么要引入follow集的概念？</p>
<p>​        当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了一个文法符号的<strong>后跟符号</strong>集合。 </p>
<p>（2）推导算法（PS：求follow集，都是从开始符号S开始推导）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计算follow集:</span><br><span class="line">	①设S为起始，&#123;#&#125;加入follow（S）</span><br><span class="line">    ②要求follow（B），若A-&gt;aBb是一个产生式，则把first（b）的非空元素加入follow（B）中</span><br><span class="line">	③若b-&gt;#,则把follow（A）加入follow（B）中</span><br><span class="line">解释：因为若D-&gt;xAy,A-&gt;aBb, 则 D-&gt;xaBby,且b&#x3D;#，则first（y）或者说是follow(A)∈follow(B)</span><br><span class="line">就是所求符号的右边如果等于# 则不停找上一级</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-select集"><a href="#5-3-3-select集" class="headerlink" title="5.3.3 select集"></a>5.3.3 select集</h4><p>select(X-&gt;Y)，先求first（Y），如果first（Y）存在#∈first（Y）的情况，则再求follow（X），最后求两者的并集即可</p>
<p>例：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>是否</th>
<th>Frist集</th>
<th>Follow集</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ #,   ’,’ ,  )  }</td>
</tr>
<tr>
<td align="left">T</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ ) }</td>
</tr>
<tr>
<td align="left">N</td>
<td>是</td>
<td>{ ‘,’  ,  # }</td>
<td>{ ) }</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Select(S-&gt;a) &#x3D;first（a）&#x3D; &#123;a&#125;</span><br><span class="line">Select(S-&gt;^) &#x3D;first（^）&#x3D;&#123;^&#125;</span><br><span class="line">Select(S-&gt;(T)) &#x3D;first（ （T）  ）&#x3D;&#123; ( &#125;</span><br><span class="line">Select(T-&gt;SN) &#x3D; first(S)&#x3D;&#123;a,^,(&#125;</span><br><span class="line">Select(N-&gt;,SN)&#x3D;first( , ) &#x3D;&#123; , &#125;</span><br><span class="line">Select(N-&gt;#) &#x3D;follow(N) &#x3D; &#123; ) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-4-预测分析表构造算法"><a href="#5-3-4-预测分析表构造算法" class="headerlink" title="5.3.4 预测分析表构造算法"></a>5.3.4 预测分析表构造算法</h4><p>1.对文法G的每个产生式Ａ→a执行第二步和第三步；</p>
<p>2.对每个终结符a∈FIRST(α)，把Ａ→α加至M[A,a]中，</p>
<p>3.若ε∈FIRST(α)，则对任何b∈FOLLOW(A)， 把Ａ→α加至M[A,b]中，</p>
<p>4.把所有无定义的M[A,a]标上“出错标志”。</p>
<h3 id="三、LL（1）文法"><a href="#三、LL（1）文法" class="headerlink" title="三、LL（1）文法"></a>三、LL（1）文法</h3><p>一个文法G，若它的分析表M不含多重定义入口，则称为LL（1）文法。</p>
<p>例：</p>
<p>文法S→iEtS|iEtSeS|a     E→b</p>
<p>不是LL（1）文法。</p>
<p>一个LL（1）文法是无二义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个文法G是LL（1）的，当且仅当对于G的每一个非终结符Ａ的任何两个不同产生式Ａ→α|β，下面的条件成立：</span><br><span class="line">1.FIRST（α）∩ FIRST(β) &#x3D; φ</span><br><span class="line">	也就是，α和β推导不出以同一个终结符a为首的符号串；它们不应该都能推出空字ε．</span><br><span class="line">2.假若β&#x3D;&gt;ε，那么FIRST（α) ∩ FOLLOW（A）＝ φ</span><br><span class="line">	也就是，若β&#x3D;&gt;ε.则α所能推出的串的首符号不应在FOLLOW(A）中．</span><br><span class="line">  结论：</span><br><span class="line">  		LL(1)文法是无二义的．</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理（4）词法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:39:22" itemprop="dateCreated datePublished" datetime="2020-05-31T22:39:22+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-14 16:18:34" itemprop="dateModified" datetime="2020-06-14T16:18:34+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>词法分析程序亦称为扫描器。</p>
<p>扫描器的任务是识别基本的语法单位——单词；</p>
<p>扫描器的输出是语法分析程序的输入。</p>
<p><strong>词法分析程序的设计和实现</strong>：</p>
<p>首先需要描述和刻画语言中的原子单位——单词，其次需要识别单词和执行某些相关的动作。描述程序设计语言的词法的机制是3型文法和正则表达式，识别机制是有穷状态自动机。</p>
<h2 id="4-1-词法分析程序"><a href="#4-1-词法分析程序" class="headerlink" title="4.1 词法分析程序"></a>4.1 词法分析程序</h2><p><strong>词法分析（lexical analysis）</strong></p>
<p>–逐个读入源程序字符并按照构词规则切分成一系列单词。   </p>
<p>–单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。</p>
<p>–词法分析是编译过程中的一个阶段，在语法分析前进行 。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。</p>
<p>![image-20200612210637695](C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200612210637695.png)</p>
<ul>
<li><p>主要任务：</p>
<p>–读源程序，产生单词符号，并转换为token表示</p>
</li>
<li><p>其他任务：</p>
<p>–滤掉空格，删除注释、换行符</p>
<p>–对行列计数</p>
<p>–发现并定位词法错误，并尽量改正</p>
<p>–建立符号表、常数表等表格，……</p>
</li>
</ul>
<h3 id="4-1-1-词法分析器的输入缓冲区"><a href="#4-1-1-词法分析器的输入缓冲区" class="headerlink" title="4.1.1 词法分析器的输入缓冲区"></a>4.1.1 词法分析器的输入缓冲区</h3><h3 id="4-1-2-词法分析器的输出"><a href="#4-1-2-词法分析器的输出" class="headerlink" title="4.1.2 词法分析器的输出"></a>4.1.2 词法分析器的输出</h3><ul>
<li><p>单词符号一般可分为下列五种：</p>
<p>–基本字，关键字</p>
<p>–标识符</p>
<p>–常数（量）</p>
<p>–运算符</p>
<p>–界符</p>
</li>
<li><p>输出的二元式（token）表示：（单词种别，单词自身的值）</p>
</li>
<li><p>Token的种类：</p>
<p>​    1、有些单词，只需要值，如基本字；</p>
<p>​    2、有些单词，还需要其他信息，如标示符。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： A:&#x3D;B+2                                                            </span><br><span class="line">(Id的整数码,指向A的符号表的入口指针）   ($28, Aaddr)       </span><br><span class="line">(运算符的整数码,’:&#x3D;’)                                                     </span><br><span class="line">(Id的整数码,指向B的符号表的入口指针)        </span><br><span class="line">(运算符的整数码,’+’)                                            </span><br><span class="line">(常数的整数码, 2)</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-以状态转换图为例设计词法分析器"><a href="#4-1-3-以状态转换图为例设计词法分析器" class="headerlink" title="4.1.3 以状态转换图为例设计词法分析器"></a>4.1.3 以状态转换图为例设计词法分析器</h3><img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613110111799.png" alt="image-20200613110111799" style="zoom:50%;" />

<h2 id="4-2-正规表达式与正规集（正规语言）"><a href="#4-2-正规表达式与正规集（正规语言）" class="headerlink" title="4.2 正规表达式与正规集（正规语言）"></a>4.2 正规表达式与正规集（正规语言）</h2><ul>
<li><p>正规表达式（regular expression）是描述单词符号的一种方便工具，也是定义正规集的工具。</p>
</li>
<li><p>定义（正规式和它所表示的正规集）：</p>
<p>–设字母表为Σ，辅助字母表Σ`={Ф，ε，|，·，*，(，)}。</p>
<p>–1) ε和Ф都是Σ上的正规式，它们所表示的正规集分别为{ε}和{ }；</p>
<p>–2) 任何a∈Σ，a是Σ上的一个正规式，它所表示的正规集为{a}；</p>
<p>–3) 假定e1和e2都是Σ上的正规式，它们所表示的正规集分别为L(e1)和L(e2)，那么，(e1), e1| e2, e1·e2, e1* 也都是正规式，它们所表示的正规集分别为L(e1), L(e1)∪L(e2), L(e1)L(e2)和(L(e1))*。</p>
<p>–4) 仅由有限次使用上述三步骤而定义的表达式才是Σ上的正规式，仅由这些正规式所表示的字集才是Σ上的正规集。</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613112425500.png" alt="image-20200613112425500" style="zoom:75%;" />

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例1  令Σ&#x3D;&#123;a，b&#125;， Σ上的正规式和相应的正规集的例子有：</span><br><span class="line">    正规式			 正规集</span><br><span class="line">    a			   &#123;a&#125;</span><br><span class="line">    a|b			   &#123;a,b&#125;</span><br><span class="line">    ab			   &#123;ab&#125;</span><br><span class="line">    (a|b)(a|b)	   &#123;aa,ab,ba,bb&#125;</span><br><span class="line">    a* 			   &#123;ε,a,aa, ……任意个a的串&#125;</span><br><span class="line">    (a|b)*		   &#123;ε,a,b,aa,ab ……所有由a和b组成的串&#125;</span><br><span class="line">	(a|b)*(aa|bb)(a|b)*    &#123;Σ*上所有含有两个相继的a或两个相继的b组成的串&#125;</span><br><span class="line">	</span><br><span class="line">例3 Σ&#x3D;&#123;d，.，e，+，-&#125;,则Σ上的正规式 d*(.dd*|ε)(e(+|-|ε)dd*|ε )</span><br><span class="line">	表示的是无符号数的集合。其中d为0~9的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>若两个正规式e1和e2所表示的正规集相同,则说e1和e2等价,写作e1=e2。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如： e1&#x3D; (a|b)， e2 &#x3D; b|a</span><br><span class="line"></span><br><span class="line">又如： e1&#x3D; b(ab)* ,  e2 &#x3D;(ba)*b				</span><br><span class="line">	  e1&#x3D; (a|b)* ,  e2 &#x3D;(a*|b*)*</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设r,s,t为正规式，正规式服从的代数规律有：</p>
<p>–1、r|s=s|r                    “或”服从交换律</p>
<p>–2、r|(s|t)=(r|s)|t        “或”的可结合律</p>
<p>–3、(rs)t=r(st)                “连接”的可结合律</p>
<p>–4、r(s|t)=rs|rt      (s|t)r=sr|tr    分配律 </p>
<p>–5、εr=r, rε=r                 ε是“连接”的恒等元素 零一律</p>
<p>–6、 r|r=r    <strong>r* =ε|r+    r+=rr*</strong> </p>
</li>
<li><p>文法的定义</p>
<p>–G={VN,VT,P,S}</p>
<p>–VN：非终结符的非空有穷集</p>
<p>–VT：终结符的非空有穷集</p>
<p>–P： 产生式的非空有穷集</p>
<p>​         a→b  a∈( VN∪VT )* 且至少含一个非终结符， b∈( VN∪VT )*</p>
<p>–S：∈VN，称为开始符号</p>
</li>
<li><p>正规文法： G的任何产生式为A→aB或A→a，其中a∈VT ∪ ε ，A，B∈VN</p>
</li>
</ul>
<p><strong>对任意一个正规文法，存在一个定义同一个语言的正规式；反之亦然。</strong></p>
<p>Σ上的<strong>正规式=&gt;正规文法</strong></p>
<p>初始VT= Σ, S∈VN ，生成正规产生式(或定义式) :S→r （r为正规式）     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(R1) 对形如 A→r1r2的正规产生式： A→r1B           </span><br><span class="line">							 B→r2               </span><br><span class="line">							 B∈VN                   </span><br><span class="line">(R2)对形如A→r*r1的正规产生式：   A→rB          </span><br><span class="line">							 A→r1          </span><br><span class="line">							 B→rB          </span><br><span class="line">							 B→r1   B∈VN                                </span><br><span class="line">(R3)对形如A→r1|r2的正规产生式:  A→r1        </span><br><span class="line">							 A→r2</span><br></pre></td></tr></table></figure>

<p>不断应用R做变换，直到每个产生式右端只含一个VN</p>
<p><strong>正规文法=&gt;正规式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正规文法                      正规式</span><br><span class="line">A→xB, B→y      转换成： 	  A&#x3D;xy 			</span><br><span class="line">A→xA|y         转换成：       A&#x3D;x*y </span><br><span class="line">A→x|y          转换成：       A&#x3D;x|y</span><br></pre></td></tr></table></figure>

<h2 id="4-3-有穷自动机"><a href="#4-3-有穷自动机" class="headerlink" title="4.3 有穷自动机"></a>4.3 有穷自动机</h2><h3 id="4-3-1-确定的有穷自动机DFA"><a href="#4-3-1-确定的有穷自动机DFA" class="headerlink" title="4.3.1 确定的有穷自动机DFA"></a>4.3.1 确定的有穷自动机DFA</h3><p><strong>DFA定义：</strong></p>
<p>一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中</p>
<p>​    1、K是一个有穷集，它的每个元素称为一个状态；</p>
<p>​    2、Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号字母表；</p>
<p>​    3、f是转换函数，是在K×Σ→K上的映射，即，如f（ki，a）=kj，（ki∈K，kj∈K）就意味着，当前状态为ki，输入符为a时，将转换为下一个状态kj，我们把kj称作ki的一个后继状态；</p>
<p>​    4、S∈K是唯一的一个初态；</p>
<p>​    5、Z 包含于 K是一个终态集，终态也称可接受状态或结束状态。</p>
<p><strong>DFA例：</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613160754459.png" alt="image-20200613160754459" style="zoom:70%;" />

<p><strong>DFA的状态转换图表示：</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613160815782.png" alt="image-20200613160815782" style="zoom:67%;" />

<p><strong>DFA</strong> <strong>的矩阵表示</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613160908110.png" alt="image-20200613160908110" style="zoom:67%;" />

<p><strong>DFA M的作用：</strong></p>
<p> 对于∑*中的任何字符串t，若存在一条从初态结到某一终态结的道路，且这条路上所有弧的标记符连接成的字符串等于t，则称t可为DFA M所接受（识别）。若M的初态结同时又是终态结，则空字可为M所识别（接受）。</p>
<ul>
<li><p>∑*上的符号串t被M接受的形式叙述：</p>
<p>若t∈∑*，f (S，t)=P，其中S为 M的开始状态，P ∈ Z，Z为终态集。</p>
<p>则称t为DFA M所<strong>接受</strong>（<strong>识别</strong>）。</p>
</li>
<li><p>∑*上的符号串t在M上运行的定义：</p>
<p>一个输入符号串t，（我们将它表示成 t1tx的形式，其中t1 ∈∑，tx∈ ∑<em>）在DFA M上*</em>运行**的定义为：</p>
<p>f（Q， t1 tx ）=f（f（Q， t1 ），tx） 其中Q∈K                         </p>
</li>
</ul>
<p>例：证明t=baab被前例中的DFA所接受</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613183717517.png" alt="image-20200613183717517" style="zoom:50%;" />

<p>所识别的语言：含有相继两个a或相继两个b的串。</p>
<p>DFA M所能接受的符号串的全体记为 L(M)(语言)</p>
<p><strong>结论：</strong></p>
<p>– Σ上一个符号串集V 包含于 Σ*是正规的，当且仅当存在一个Σ上的确定有穷自动机M，使得V=L(M)。</p>
<h3 id="4-3-2-不确定的有穷自动机NFA"><a href="#4-3-2-不确定的有穷自动机NFA" class="headerlink" title="4.3.2 不确定的有穷自动机NFA"></a>4.3.2 不确定的有穷自动机NFA</h3><p>NFA定义：</p>
<p>N={K，Σ，f，S，Z}，其中K为状态的有穷非空集，Σ为有穷输入字母表，f为Kx Σ*到K的子集（2^K）的一种映射，S 包含于 K是初始状态集，Z 包含于 K为终止状态集。</p>
<ul>
<li><p>例子</p>
<p>NFA N=（{S，P，Z}，{0，1}，f，{S，P}，{Z}）</p>
<p>其中 f（S，0）={P}</p>
<p>​        f（S，1）={S，Z}</p>
<p>​        f（P，1）={Z}</p>
<p>​        f（Z，0）={P}</p>
<p>​        f（Z，1）={P}</p>
<p>状态图表示：</p>
</li>
</ul>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613184408840.png" alt="image-20200613184408840" style="zoom:80%;" />

<ul>
<li>∑*上的符号串t在NFA N上运行</li>
<li>∑*上的符号串t被NFA N接受</li>
<li>具有ε转移的不确定的有穷自动机NFA… f为 K x（Σ ∪{ε}）到K的子集（2^K）的一种映射</li>
<li>对任何一个具有ε转移的不确定的有穷自动机NFA　N，一定存在一个不具有ε转移的不确定的有穷自动机NFA　Ｍ ，使得L(M)=L(N)。</li>
</ul>
<h3 id="4-3-3-NFA的确定化"><a href="#4-3-3-NFA的确定化" class="headerlink" title="4.3.3 NFA的确定化"></a>4.3.3 NFA的确定化</h3><p>DFA是NFA的特例。对每个NFA N一定存在一个DFA M ，使得L(M)=L(N)。对每个NFA N存在着与之等价的DFA M。与某一NFA等价的DFA不唯一。</p>
<p><strong>定义对状态集合I的几个有关运算：</strong></p>
<ol>
<li>状态集合 I 的 ε- 闭包，表示为 ε-closure(I)，定义为一状态集，是状态集 I 中的任何状态S经任意条ε弧而能到达的状态的集合。状态集合 I 的任何状态S都属于 ε-closure(I)。</li>
<li>状态集合 I 的a弧转换，表示为 move(I,a) 定义为状态集合 J，其中 J 是所有那些可从 I 的某一状态经过一条a弧而到达的状态的全体。定义 Ia = ε-closure(J)</li>
</ol>
<p>例：</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613190857433.png" alt="image-20200613190857433" style="zoom:80%;" />



<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613190905154.png" alt="image-20200613190905154" style="zoom:80%;" />

<p>假设NFA N=(K, Σ, f, K0, Kt)按如下办法构造一个DFA M=(S, Σ, d, S0, St)，使得L(M)=L(N)：</p>
<ol>
<li><p>M的状态集S由K的一些子集组成。用[S1 S2… Sj ]表示S的元素，其中S1, S2,,… Sj是K的状态。并且约定，状态S1, S2,… Sj 是按某种规则排列的，即对于子集{S1, S2}={ S2, S1,}来说，S的状态就是[S1 S2]；</p>
</li>
<li><p>M和N的输入字母表是相同的，即是 Σ ；</p>
</li>
<li><p>转换函数是这样定义的：                    </p>
<p> d([S1 S2,… Sj],a)= [R1R2… Rt]  其中   {R1,R2,… , Rt} = ε-closure(move({S1, S2,,… Sj},a)) </p>
</li>
<li><p>S0=ε-closure(K0)为M的开始状态；</p>
</li>
<li><p>St={[Si Sk… Se]，其中[Si  Sk… Se]∈S且{Si , Sk,,… Se}∩Kt≠Φ}</p>
</li>
</ol>
<p><strong>NFA确定化例子：</strong></p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613192154391.png" alt="image-20200613192154391" style="zoom:80%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613192229903.png" alt="image-20200613192229903" style="zoom:80%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613205712090.png" alt="image-20200613205712090" style="zoom:80%;" />

<h2 id="4-4-有穷自动机和正规表达式"><a href="#4-4-有穷自动机和正规表达式" class="headerlink" title="4.4 有穷自动机和正规表达式"></a>4.4 有穷自动机和正规表达式</h2><p><strong>有穷自动机和正规表达式的等价性：</strong>   </p>
<ul>
<li>对于∑上的一个NFA M，可以构造一个∑上的正规式R,使得L(R)=L(M)。</li>
<li>对于∑上的一个正规式R，可以构造一个∑上的NFA M，使的L(M)=L(R)。</li>
</ul>
<p><strong>正规式 =&gt;有穷自动机</strong></p>
<p>设给定正规式W，则构造相应自动机的方法如下：</p>
<p>若W=ø，则对应的NFA为<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613210019996.png" alt="image-20200613210019996" style="zoom:50%;" /></p>
<p>若W&lt;&gt;ø，则对应的NFA为<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613210048337.png" alt="image-20200613210048337" style="zoom:50%;" /></p>
<p>然后利用以下规则加入结点和箭弧，直到得到自动机为止。</p>
<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613210135127.png" alt="image-20200613210135127" style="zoom:70%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613210145552.png" alt="image-20200613210145552" style="zoom:70%;" />

<img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613210156741.png" alt="image-20200613210156741" style="zoom:70%;" />

<p><strong>有穷自动机=&gt;正规式</strong></p>
<p>首先检查是否只有一个终态结点，若有多个，则引入新结点T，从所有终态结点引ε边到T结点，并令T为唯一的终态结点。</p>
<p>然后按以下规则消除结点与箭弧：</p>
<p>![image-20200613223618156](C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613223618156.png)</p>
<h2 id="4-5-有穷自动机和正规文法"><a href="#4-5-有穷自动机和正规文法" class="headerlink" title="4.5 有穷自动机和正规文法"></a>4.5 有穷自动机和正规文法</h2><p><strong>有穷自动机和正规文法的等价性：</strong>     </p>
<ul>
<li>对于一个NFA M，都存在 一个正规文法G，使得L(G)=L(M).               </li>
<li>对于一个正规文法G,都存在一个NFA M，使得L(M)=L(G). </li>
</ul>
<p><strong>正规文法=&gt;自动机</strong></p>
<ul>
<li>字母表与G的终结符集相同；</li>
<li>G中的非终结符对应状态，开始符对应开始状态</li>
<li>增加一个新的终结状态Z。</li>
<li>G中的A-&gt;tB构造转换函数f(A,t)=B</li>
<li>G中的A-&gt;t构造转换函数f(A,t)=Z</li>
</ul>
<p><strong>自动机=&gt;正规文法</strong></p>
<ul>
<li>对转换函数f(A,t)=B，对应产生式：   A-&gt;tB</li>
<li>对终态Z，增加一产生式： Z-&gt;ε</li>
<li>NFA的初态对应文法的开始符号；</li>
<li>NFA的字母表对应文法的终结符号集。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编译原理（2）文法和语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:38:54" itemprop="dateCreated datePublished" datetime="2020-05-31T22:38:54+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-14 16:47:13" itemprop="dateModified" datetime="2020-06-14T16:47:13+08:00">2020-06-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="2-1-符号、符号串及其集合的运算"><a href="#2-1-符号、符号串及其集合的运算" class="headerlink" title="2.1 符号、符号串及其集合的运算"></a>2.1 符号、符号串及其集合的运算</h2><p>任何一种语言都是由该语言的基本符号组成的符号串的集合。</p>
<ul>
<li>​    基本符号集</li>
<li>​    任何语言的单词符号就是定义在它的字符集上的字符串</li>
<li>​    该语言的任何语句就是定义在其单词符号集上的单词串(符号串)</li>
</ul>
<h3 id="2-1-1-字母表和符号串"><a href="#2-1-1-字母表和符号串" class="headerlink" title="2.1.1 字母表和符号串"></a>2.1.1 字母表和符号串</h3><p>字母表：是元素的非空有穷集合，把字母表中的元素称为符号，因此字母表也称符号集。</p>
<p>符号串：字母表中的符号串组成的任何有穷序列。</p>
<h3 id="2-1-2-符号串及其集合的运算"><a href="#2-1-2-符号串及其集合的运算" class="headerlink" title="2.1.2 符号串及其集合的运算"></a>2.1.2 符号串及其集合的运算</h3><p>① 符号串的长度：如果某符号串x中有m个符号，则其长度为m，记为|x|=m。例</p>
<p>② 符号串的联接：设x和y是符号串，它们的联接xy是把y的符号写在x的符号之后得到的符号串。</p>
<p>③ 符号串的方幂：设x是符号串，把x自身连接n次得到符号串z，即z=xxx….xx，称为符号串x的方幂。</p>
<p>④ 符号串集合：若集合A中的一切元素都是某字母表上的符号串，则称A为字母表上的符号串集合。</p>
<ul>
<li>语言：表示某个确定的字母表上的符号串的任何集合。</li>
</ul>
<p>⑤ 集合的乘积：AB={xy|x∈A且y∈B}。</p>
<p>⑥ 集合A的闭包A*和正闭包A+：</p>
<img src="F:\blog\source\_posts\编译原理（2）文法和语言\微信截图_20200614164611.png" alt="微信截图_20200614164611" style="zoom:80%;" />

<h2 id="2-2-文法的直观概念"><a href="#2-2-文法的直观概念" class="headerlink" title="2.2 文法的直观概念"></a>2.2 文法的直观概念</h2><p>文法的定义∶对语言结构的描述和定义，即在形式上用来描述和规定语言结构的称为“文法”(或“语法”)。</p>
<p><strong>规则</strong></p>
<p>​    句子的语法结构，可以用一组规则来描述。</p>
<p>​    规则也称为“产生式”，规则中的“∷=”也常用“→”表示。</p>
<p>​    注意∶文法中，描述某个特定的语法成分的规则可能不只一条。</p>
<p><strong>由规则推导句子</strong></p>
<p>如果用一组规则来描述句子的结构，就可以利用这组规则按照一定的方式去推导产生句子。</p>
<p>推导方法∶使用一条规则，代替=&gt;左边的某个符号，产生=&gt;右端的符号串</p>
<h2 id="2-3-文法和语言的形式定义"><a href="#2-3-文法和语言的形式定义" class="headerlink" title="2.3 文法和语言的形式定义"></a>2.3 文法和语言的形式定义</h2><h3 id="2-3-1-文法的形式定义"><a href="#2-3-1-文法的形式定义" class="headerlink" title="2.3.1 文法的形式定义"></a>2.3.1 文法的形式定义</h3><p>① 规则、产生式(或重写规则)∶形如α→β或α∷=β的（α，β）有序对，且α∈V+，β∈V* ， V为某字母表。</p>
<ul>
<li>α称为规则的左部(或产生式的左部)。</li>
<li>β称为规则的右部(或产生式的右部)。</li>
</ul>
<p>②文法的定义</p>
<p>（1）文法G定义为四元组（VN，VT，P，S）</p>
<p>​        –VN：非终结符集</p>
<p>​        –VT ：终结符集</p>
<p>​        –P：产生式（规则）集合</p>
<p>​        –S：开始符号</p>
<p>​    VN ∩ VT = φ，S∈VN</p>
<p>​    V=VN∪VT，称为文法G的文法符号集合</p>
<p>（2）习惯上只将产生式写出。并有如下约定：</p>
<p>​        –第一条产生式的左部是开始符号</p>
<p>​        –用尖括号括起的是非终结符，否则为终结符。或者大写字母表示非终结符，小写字母表示终结符</p>
<p>​        –G可写成G[S]，S是开始符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G：S→aAb      A→ab    A→aAb    A→ε </span><br><span class="line">G[S]： A→ab    A→aAb    A→ε  S→aSb </span><br><span class="line">缩写形式 G[S]：A→ab|aAb|ε      S→aSb</span><br><span class="line">注意：元符号“|”读作“或”</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-推导的形式定义"><a href="#2-3-2-推导的形式定义" class="headerlink" title="2.3.2 推导的形式定义"></a>2.3.2 推导的形式定义</h3><p>直接推导“=&gt;”</p>
<p>​         α→β是文法G的产生式，若有v,w满足：</p>
<p>​         v=γ α δ, w= γ β δ, 其中 γ∈V* , δ∈V*</p>
<pre><code> 则称v直接推导出w, 记作 v =&gt; w

或w直接归约到v</code></pre><p>若存在v=&gt;w0=&gt;w1 =&gt;… =&gt;wn=w, (n&gt;0)，则称v  <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" /> w，v推导出w，或w归约到v。</p>
<p>若有v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" />  w，或v=w，则记为v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608221128579.png" alt="image-20200608221128579" style="zoom:50%;" />  w</p>
<p><strong>句型</strong></p>
<p>​    – 有文法G，若S =*&gt;  x，则称x是文法G的句型。</p>
<p>​    一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。</p>
<p><strong>句子</strong></p>
<p>​    – 有文法G，若S =+&gt; x，且x∈VT*，则称x是文法G的句子。</p>
<p>​    句子是不包含非终结符的句型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如：有下列文法：</span><br><span class="line">　　S→AB</span><br><span class="line">　　A→aA|a</span><br><span class="line">　　B→bB|b</span><br><span class="line">用上述文法推导字符串aaabbb过程如下：</span><br><span class="line">　　S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbb</span><br><span class="line">AB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型</span><br><span class="line">只有终结符的句型为句子。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T          </span><br><span class="line">	T→T*F|F          </span><br><span class="line">	F→(E)|a</span><br><span class="line">E&#x3D;&gt;E+T&#x3D;&gt;T+T&#x3D;&gt;F+T&#x3D;&gt;a+T&#x3D;&gt;a+T*F&#x3D;&gt;a+F*F&#x3D;&gt;a+a*F&#x3D;&gt;a+a*a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-语言的形式定义"><a href="#2-3-3-语言的形式定义" class="headerlink" title="2.3.3 语言的形式定义"></a>2.3.3 语言的形式定义</h3><p>由文法G生成的语言记为L(G),它是文法G的一切句子的集合:                    </p>
<p>​        L(G)={x|S =+&gt; x，其中S为文法的开始符号，且x ∈VT*}</p>
<p><strong>文法的等价</strong></p>
<p>若L（G1）=L（G2），则称文法G1和G2是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如文法G1[A]：A→0R    与   G2[S]：S→0S1 等价</span><br><span class="line">           A→01                S→01</span><br><span class="line">           R→A1</span><br></pre></td></tr></table></figure>

<p>练习：已知语言描述，写出文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：若语言由0、1符号串组成，串中0和1的个数相同，构造其文法。</span><br><span class="line"> A → 0B|1C</span><br><span class="line"> B → 1|1A|0BB</span><br><span class="line"> C → 0|0A|1CC</span><br></pre></td></tr></table></figure>

<p>练习：已知文法，写出语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T</span><br><span class="line">         T→T*F|F</span><br><span class="line">         F→(E)|a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h2 id="2-4-文法的类型"><a href="#2-4-文法的类型" class="headerlink" title="2.4 文法的类型"></a>2.4 文法的类型</h2><p><strong>Chomsky</strong> <strong>将文法分为四种类型：</strong></p>
<p>（1）0型文法（短语文法）：G=(VN,VT,P,S)对任一产生式α→β，都有α∈(VN∪VT) *，且至少含有一个非终结符， β∈(VN∪VT) *</p>
<p>（2）1型文法（上下文有关文法）：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外，1型文法也可描述为α1Aα2→α1βα2</p>
<p>（3）2型文法（上下文无关文法）：对任一产生式α→β，都有α∈VN ， β∈(VN∪VT)*</p>
<p>（4）3型文法（正规文法）：任一产生式α→β的形式都为A→aB或A→a，其中A∈VN，B∈VN，a∈VT</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1型（上下文有关）文法：</span><br><span class="line">   文法G[S]：	 S→CD		Ab→bA</span><br><span class="line">			   C→aCA	  Ba→aB</span><br><span class="line">			   C→bCB	  Bb→bB</span><br><span class="line">			   AD→aD	  C→ε</span><br><span class="line">			   BD→bD	  D→ε</span><br><span class="line">			   Aa→bD</span><br><span class="line">L(G)&#x3D;&#123;w|w∈&#123;a,b&#125;*&#125;</span><br><span class="line"></span><br><span class="line">2型（上下文无关）文法：</span><br><span class="line">   文法G[S]：	S→aB|bA</span><br><span class="line">			  A→a|aS|bAA</span><br><span class="line">			  B→b|bS|aBB</span><br><span class="line">   文法G[S]：	S→0A|1B|0</span><br><span class="line">			  A→0A|1B|0S</span><br><span class="line">			  B→1B|1|0</span><br><span class="line"></span><br><span class="line">定义标识符的3型（正规）文法：</span><br><span class="line">   文法G[I]：	I → iT</span><br><span class="line">			 I → i</span><br><span class="line">			 T → iT</span><br><span class="line">			 T → dT</span><br><span class="line">			 T → i</span><br><span class="line">             T → d</span><br></pre></td></tr></table></figure>

<p><strong>文法和语言</strong></p>
<p>0型文法产生的语言称为0型语言</p>
<p>1型文法或上下文有关文法（ CSG ）产生的语言称为1型语言或上下文有关语言（CSL）</p>
<p>2型文法或上下文无关文法（ CFG ）产生的语言称为2型语言或上下文无关语言（ CF L ） </p>
<p>3型文法或正则（正规）文法（ RG ）产生的语言称为3型语言正则（正规）语言（ RL ）</p>
<p><strong>文法和识别系统</strong></p>
<p>0型文法（短语文法）的能力相当于图灵机，可以表征任何递归可枚举集，而且任何0型语言都是递归可枚举的</p>
<p>1型文法（上下文有关文法）：产生式的形式为α1Aα2→α1βα2，即只有A出现在α1和α2的上下文中时，才允许β取代A。其识别系统是线性界限自动机。</p>
<p>2型文法（上下文无关文法、CFG）：产生式的形式为A→β，β取代A时与A的上下文无关。其识别系统是不确定的下推自动机。</p>
<p>3型文法（正规文法、右线性文法）：产生的语言是有穷自动机（FA）所接受的集合</p>
<h2 id="2-5-上下文无关文法及其语法树"><a href="#2-5-上下文无关文法及其语法树" class="headerlink" title="2.5 上下文无关文法及其语法树"></a>2.5 上下文无关文法及其语法树</h2><h3 id="2-5-1-上下文无关文法的语法树"><a href="#2-5-1-上下文无关文法的语法树" class="headerlink" title="2.5.1 上下文无关文法的语法树"></a>2.5.1 上下文无关文法的语法树</h3><p>用于描述上下文无关文法的句型推导的直观方法</p>
<p>叶子结点：树中没有子孙的结点。</p>
<p>从左到右读出推导树的叶子标记，所得的句型为推导树的结果。也把该推导树称为该句型的语法树。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定文法G，对于G的任何句型都能构造与之关联的语法树（推导树）。这棵树满足下列4个条件：</span><br><span class="line">1、每个结点都有一个V中的符号作标记</span><br><span class="line">2、根的标记是开始符号S</span><br><span class="line">3、若一结点n至少有一个它自己除外的子孙，并且n有标记A，则A∈VN</span><br><span class="line">4、如果结点n的直接子孙，从左到右的次序是结点n1,n2,…,nk，其标记分别为A1,A2,…,Ak，那么A→A1A2,…,Ak一定是P中的一个产生式</span><br></pre></td></tr></table></figure>

<p>推导过程中使用产生式的顺序：</p>
<ul>
<li>最左（最右）推导：在推导的任何一步α=&gt;β，其中α、β是句型，都是对α中的最左（右）非终结符进行替换</li>
<li><strong>最右推导被称为规范推导</strong>。 <strong>最左归约–&gt;规范规约</strong></li>
<li>由规范推导所得的句型称为规范句型</li>
</ul>
<h3 id="2-5-2-二义性"><a href="#2-5-2-二义性" class="headerlink" title="2.5.2 二义性"></a>2.5.2 二义性</h3><p><strong>二义文法</strong></p>
<p>若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是<em>二义</em> 的。</p>
<p>或者，若一个文法存在某个句子有两个不同的最左（右）推导，则称这个文法是<em>二义</em> 的。</p>
<p>产生某上下文无关语言的每一个文法都是二义的，则称此语言是<em>先天二义</em>的。</p>
<p>二义文法改造为无二义文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G[E]: E → i         G[E]：E → T|E+T</span><br><span class="line">	  E → E+E             T → F|T*F</span><br><span class="line">	  E → E*E             F →（E）|i</span><br><span class="line">	  E → (E)       规定优先顺序和结合律</span><br></pre></td></tr></table></figure>

<h2 id="2-6-句型的分析"><a href="#2-6-句型的分析" class="headerlink" title="2.6 句型的分析"></a>2.6 句型的分析</h2><p><strong>句型分析</strong> 就是识别一个符号串是否为某文法的句型，是某个推导的构造过程。</p>
<p>在语言的编译实现中，把完成句型分析的程序称为<em>分析程序</em> 或<em>识别程序</em>。分析算法又称<em>识别算法</em>。</p>
<p><em>从左到右的分析算法</em> ，即总是从左到右地识别输入符号串，首先识别符号串中的最左符号，进而依次识别右边的一个符号。</p>
<p><strong>分析算法可分为：</strong></p>
<p><strong><em>自上而下分析法</em>：</strong> </p>
<p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的推导。</p>
<p><strong><em>自下而上分析法</em>：</strong></p>
<p> 从输入符号串开始，逐步进行归约，直至归约到文法的开始符号。</p>
<p>两种方法反映了两种不同的语法树的构造过程</p>
<p><strong>句型分析的有关问题</strong></p>
<p>1）如何选择使用哪个产生式进行推导？</p>
<p>2）如何识别可归约的串？</p>
<p><strong>句型分析</strong></p>
<p>短语、直接短语、句柄的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒+ γ，则称γ是句型αγβ的相对于非终结符A的&#96;短语&#96; 。</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒ γ，则称γ是句型αγβ的相对于规则A→γ的&#96;直接(简单)短语&#96;。</span><br><span class="line">直接短语中的最左直接短语为该句型的句柄。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">短语：</span><br><span class="line">一个句型的分析树中的每一棵子树的边缘(所有叶节点)所组成的符号串称为该句型的一个短语(phrase)。 </span><br><span class="line">直接短语：</span><br><span class="line">如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语(immediate phrase)；</span><br><span class="line">所有子树中，深度为2的子树的叶子节点串就是直接短语（因为直接短语必须是由子树根节点用一步推出来的，所以深度为2）；</span><br><span class="line">即如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。</span><br><span class="line"></span><br><span class="line">句柄：</span><br><span class="line">“可规约串”，句柄对应某个产生式的右部，是某个，但不是任意一个。</span><br><span class="line">作为一种规约对象，句柄表示最左直接短语。</span><br><span class="line">语法树： 在语法树上，则表示为最左边的只包含相邻父子节点的短语（最左直接短语）</span><br></pre></td></tr></table></figure>

<p>素短语和最左素短语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">素短语：</span><br><span class="line">是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象。</span><br><span class="line">语法树：通过语法树分析时，要注意先判断是否为素短语，再找相对最左端的素短语。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">素短语 ：</span><br><span class="line">指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line">从短语集合中找出所有含有终结符的短语，然后选出除它自身之外不再含更小的素短语。</span><br><span class="line">（这个小的概念是集合中没有被包含的元素，如有两个短语aAA和aAAA，aAA含于aAAA，所以aAA比aAAA小）</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">从素短语集合中找出最左边的素短语。</span><br></pre></td></tr></table></figure>

<h2 id="2-7文法实用中的一些说明"><a href="#2-7文法实用中的一些说明" class="headerlink" title="2.7文法实用中的一些说明"></a>2.7文法实用中的一些说明</h2><h3 id="2-7-1-有关文法的实用限制"><a href="#2-7-1-有关文法的实用限制" class="headerlink" title="2.7.1 有关文法的实用限制"></a>2.7.1 有关文法的实用限制</h3><p>文法中不得含有<em>有害规则</em> 和<em>多余规则</em></p>
<ul>
<li><p>有害规则：形如U→U的产生式。会引起文法的二义性</p>
</li>
<li><p>多余规则：指文法中任何句子的推导都不会用到的规则</p>
<p>1）文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达</p>
<p>2）文法中某些非终结符，由它不能推出终结符号串来，称为不可终止的</p>
</li>
</ul>
<p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p>
<p>​        1）A必须在某句型中出现。</p>
<p>​        2）必须能从A推出终结符号串t来。</p>
<h3 id="2-7-2-上下文无关文法中的ε规则"><a href="#2-7-2-上下文无关文法中的ε规则" class="headerlink" title="2.7.2 上下文无关文法中的ε规则"></a>2.7.2 上下文无关文法中的ε规则</h3><p>具有形式A→ε的规则称为ε规则，其中A∈VN</p>
<p>某些著作和讲义中限制这种规则的出现。因为ε规则会使有关文法的一些讨论和证明变得复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理（1）编译概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:05:01" itemprop="dateCreated datePublished" datetime="2020-05-31T11:05:01+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-30 23:16:30" itemprop="dateModified" datetime="2020-07-30T23:16:30+08:00">2020-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h3 id="1-1-程序设计语言"><a href="#1-1-程序设计语言" class="headerlink" title="1.1 程序设计语言"></a>1.1 程序设计语言</h3><p>Machine Code</p>
<p>Assembly Language</p>
<p>High-level Language</p>
<p>如Algol, Fortran, Pascal, C语言等。</p>
<h3 id="1-2-什么叫编译程序"><a href="#1-2-什么叫编译程序" class="headerlink" title="1.2 什么叫编译程序"></a>1.2 什么叫编译程序</h3><p>翻译程序：就是将源程序转换成目标程序的程序。</p>
<p>source program —–&gt;  Translator  ——&gt;  target program</p>
<p>翻译程序和解释程序的区别：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" alt="1"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释方式最终不生成目标程序，这是编译方式和解释方式的根本区别。</span><br><span class="line">编译方式：是将源程序经编译得到可执行文件后，就可脱离源程序和编译程序单独执行，所以编译方式的效率高，执行速度快；</span><br><span class="line">解释方式：在执行时，必须源程序和解释程序同时参与才能运行，其不产生可执行程序文件，效率低，执行速度慢。</span><br></pre></td></tr></table></figure>

<p>编译程序和汇编程序的区别：</p>
<p>​        如果源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，这样的一个翻译程序称为编译程序。如果源语言是汇编语言，而目标语言是机器语言，这样的一个翻译程序称为汇编程序。</p>
<p>解释性语言：</p>
<p>（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行：  源代码—&gt;中间代码—&gt;机器语言</p>
<p>（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；</p>
<p>（3）解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；</p>
<p>（4）运行效率一般相对比较低，依赖解释器，跨平台性好；</p>
<p>（5）Java是编译性-解释性语言，因为其同时具备编译性和解释性两种特性。</p>
<h3 id="1-3-编译程序的组成"><a href="#1-3-编译程序的组成" class="headerlink" title="1.3 编译程序的组成"></a>1.3 编译程序的组成</h3><p>一个典型的编译程序应具有以下的组成：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0%5Cimage-20200531200636454.png" alt="image-20200531200636454"></p>
<p>编译程序的两个主要任务：</p>
<p>一是分析，二是综合。</p>
<p>编译程序结构(components)</p>
<ul>
<li>词法分析程序</li>
<li>语法分析程序</li>
<li>语义分析程序</li>
<li>中间代码生成程序</li>
<li>代码优化程序</li>
<li>目标代码生成程序</li>
<li>符号表管理程序</li>
<li>出错处理程序</li>
</ul>
<p>（1）Scanner （词法分析）</p>
<p>任务：识别单词符号，是最初级的语法分析。</p>
<p>依循的规则：语言的构词规则。</p>
<p>（2）Parser （语法分析）</p>
<p>任务∶对词法分析的输出即单词符号串进行分析，识别出一个个语法成分，并进行语法检查。</p>
<p>依循的规则：语法规则。</p>
<p>（语法单位：算术表达式、短语、句子、子程序……）</p>
<p>（3）Semantic Analyzer （语义分析）</p>
<p>任务：对语法分析所识别的各种语法成分的意义(即语义)进行确定并加以处理。</p>
<p>依循的规则：语义规则</p>
<p>（4）Intermediate Code Generator</p>
<p>任务：从源程序的树形或其它形式，产生源程序的中间代码。</p>
<p>中间代码：四元式、三元式……</p>
<p>（5）Target Code Generator</p>
<p>任务：将中间代码转换成汇编程序或者机器语言。</p>
<p>（6）代码优化</p>
<p>代码优化程序的功能是将中间代码中重复和冗余部分进行优化，提高目标程序的执行效率。</p>
<p>（7）符号表管理</p>
<ul>
<li>符号表管理是一个贯穿编译全过程的工作。</li>
<li>编译程序在分析源程序时，需要记录标识符的各种属性信息；</li>
<li>在语义分析和代码生成阶段，还要对建立的符号表进行检索，提取相应的属性信息。–类型、作用域、分配存储信息</li>
</ul>
<p>（8）Error Handler （错误检测及处理）</p>
<ul>
<li>错误可发生在编译的各个阶段，错误处理也是贯穿编译全过程。</li>
<li>词法分析阶段可查出的错误，如标识符的组成不符合词法规则； </li>
<li>语句结构错误是在语法分析中可查出的错误；</li>
<li>语义分析阶段可查出的错误，即结构正确，但所涉及的操作无意义或错误。</li>
<li>在编译时查出的，叫Comple-time error，在运行时表现才表现出来的错误叫Run-time error。</li>
</ul>
<p>（9）前端和后端</p>
<ul>
<li>前端包括编译逻辑结构中的分析部分，即词法分析、语法分析、语义分析和中间代码生成，除此还包括符号表建造及相应分析中的错误处理以及与机器无关的优化部分。</li>
<li>后端包括与目标机有关的部分，即综合部分，它包括目标代码生成及生成期间对符号表的相应检索操作和错误处理操作，以及与机器相关的代码优化部分。</li>
<li>将编译系统划分为前后端，有利于移植编译系统和利用后端为同一目标机配置不同语言的编译系统。</li>
</ul>
<p>（10）遍（pass）</p>
<p>​        对源程序(或其中间形式)从头至尾扫描一次并进行有关加工处理，生成新的中间形式或最终目标程序，称为一遍。</p>
<p>分遍原则∶</p>
<ul>
<li>目标质量高低(高则多遍) </li>
<li>机器内存大小(小则多遍)</li>
<li>源语言简繁(繁则多遍)</li>
<li>设计人员多少(多则多遍)</li>
</ul>
<p>多遍扫描编译程序的优缺点∶</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：（1）可以减少内存容量的需求，分便后，以遍为单位分别调用编译的各个子程序，各遍程序可以相互覆盖；</span><br><span class="line">（2）可使各遍的编译程序相互独立，结构清晰；</span><br><span class="line">（3）能够进行充分的优化，产生高质量的目标程序；</span><br><span class="line">（4）可将编译程序分为“前端”和“后端”，有利于编译程序的移植。</span><br><span class="line">缺点：每遍都要读符号、送符号，增加了许多重复性工作，降低了编译效率。</span><br></pre></td></tr></table></figure>

<h3 id="1-4-编译程序的生成"><a href="#1-4-编译程序的生成" class="headerlink" title="1.4 编译程序的生成"></a>1.4 编译程序的生成</h3><p><strong>实现工具：</strong>Low-level Language；</p>
<p>​                   High-level Language；</p>
<p>​                   Automatic Builder。</p>
<p><strong>生成方法：</strong>Self-compiler;</p>
<p>​                   transplant</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">python基础语法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 00:00:00" itemprop="dateCreated datePublished" datetime="2020-05-30T00:00:00+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-31 11:03:35" itemprop="dateModified" datetime="2020-05-31T11:03:35+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><hr>
<h4 id="python常用数据类型"><a href="#python常用数据类型" class="headerlink" title="python常用数据类型"></a>python常用数据类型</h4><p>1）在python中变量不直接存储值，而是存储值的内存地址或引用</p>
<p>2）在python中，不需要事先声明变量名及其类型，使用赋值语句可以直接创建任意类型的变量，变量的类型取决于等号右侧表达式值的类型。</p>
<p>3）赋值（比如a=’ABC’）时，python解释器干了两件事：</p>
<p>​                在内存中创建一个 ‘ABC’ 的字符串；</p>
<p>​                在内存中创建一个名为a的变量，并把它指向 ‘ABC’</p>
<h4 id="python的核心数据类型"><a href="#python的核心数据类型" class="headerlink" title="python的核心数据类型"></a>python的核心数据类型</h4><h5 id="（1）Number（数字）"><a href="#（1）Number（数字）" class="headerlink" title="（1）Number（数字）"></a>（1）Number（数字）</h5><p>python支持int、float、complex三种不同的数字类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;b = <span class="number">3.14</span></span><br><span class="line">&gt;&gt;&gt;c = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line">&gt;&gt;&gt;print(type(a), type(b), type(c))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt; &lt;<span class="title">class</span> '<span class="title">float</span>'&gt; &lt;<span class="title">class</span> '<span class="title">complex</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;<span class="title">isinstance</span><span class="params">(a, int)</span></span></span><br><span class="line"><span class="class"><span class="title">True</span></span></span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">print(math.factorial(<span class="number">32</span>))  <span class="comment">#计算32的阶乘</span></span><br><span class="line">print(<span class="number">0.4</span><span class="number">-0.3</span> == <span class="number">0.1</span>)      <span class="comment">#false 实数之间尽量避免直接比较大小</span></span><br><span class="line">print(math.isclose(<span class="number">0.4</span><span class="number">-0.3</span>, <span class="number">0.1</span>)) <span class="comment">#true 测试两个实数是否足够接近</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">3</span>+<span class="number">4j</span></span><br><span class="line">print(c+c)   <span class="comment">#复数相加</span></span><br><span class="line">print(c.real)  <span class="comment">#查看复数的实部</span></span><br><span class="line">print(c.imag)  <span class="comment">#查看复数的虚部</span></span><br><span class="line">print(<span class="number">3</span>+<span class="number">4j</span>.imag) <span class="comment">#相当于3+(4j).imag</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）String（字符串）"><a href="#（2）String（字符串）" class="headerlink" title="（2）String（字符串）"></a>（2）String（字符串）</h5><p>python中的字符串可以使用单引号、双引号和三引号括起来，使用反斜杠 \ 转义特殊字符</p>
<p>python3源码文件默认以UTF-8编码，所有字符串都是Unicode字符串</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">'''Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.'''</span></span><br><span class="line"></span><br><span class="line">print(len(text))            <span class="comment">#字符串长度，即所有字符的数量</span></span><br><span class="line">print(text.count(<span class="string">'is'</span>))     <span class="comment">#字符串中单词is出现的次数</span></span><br><span class="line">print(<span class="string">'beautiful'</span> <span class="keyword">in</span> text)  <span class="comment">#测试字符串中是否包含单词beautiful(大小写敏感)</span></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">20</span>)   			<span class="comment">#字符串重复</span></span><br><span class="line">print(<span class="string">'Good '</span>+<span class="string">'Morning'</span>)    <span class="comment">#字符串连接</span></span><br></pre></td></tr></table></figure>

<h5 id="（3）List（列表）"><a href="#（3）List（列表）" class="headerlink" title="（3）List（列表）"></a>（3）List（列表）</h5><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字、字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在[]之间，用逗号分隔开的元素列表。</p>
<p>列表索引值以 0 为开始值，-1为从末尾的开始位置。</p>
<p>列表可以使用+操作符进行拼接，使用*表示重复。</p>
<h5 id="（4）Tuple（元组）"><a href="#（4）Tuple（元组）" class="headerlink" title="（4）Tuple（元组）"></a>（4）Tuple（元组）</h5><p>tuple 和 list 类似，不同之处在于tuple的元素不能修改。tuple 写在小括号里，元素之间用逗号隔开。（注：定义只有1个元素的tuple，必须加逗号）</p>
<p>元组的元素不可变，但可以包含可变对象，如 list。</p>
<h5 id="（5）dict（字典）"><a href="#（5）dict（字典）" class="headerlink" title="（5）dict（字典）"></a>（5）dict（字典）</h5><p>字典是无序的对象集合，使用键-值（key-value）存储，具有极快的查找速度。</p>
<p>键（key）必须使用不可变类型。</p>
<p>同一个字典中，键（key）必须是唯一的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michacl'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">65</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michacl'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/25/first-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/first-md/" class="post-title-link" itemprop="url">first.md</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 17:02:24" itemprop="dateCreated datePublished" datetime="2020-05-25T17:02:24+08:00">2020-05-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artemisaturn.github.io/2020/05/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 16:22:53" itemprop="dateCreated datePublished" datetime="2020-05-25T16:22:53+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-30 23:19:06" itemprop="dateModified" datetime="2020-07-30T23:19:06+08:00">2020-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">#generate 生成静态文件</span></span><br><span class="line">hexo s <span class="comment">#server 启动服务器。在本地预览效果，默认情况下，访问网址为： http://localhost:4000/</span></span><br><span class="line">hexo d <span class="comment">#deploy 部署网站同步到github。部署网站前，需要预先生成静态文件</span></span><br><span class="line">hexo clean <span class="comment">#clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span></span><br></pre></td></tr></table></figure>

<h5 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h5><p>删除那篇文章，然后重新运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Daphne Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daphne Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>

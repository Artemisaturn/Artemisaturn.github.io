<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"artemisaturn.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://artemisaturn.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Daphne Wang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://artemisaturn.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/23/Taichi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/Taichi/" class="post-title-link" itemprop="url">Taichi</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-23 23:09:03" itemprop="dateCreated datePublished" datetime="2020-08-23T23:09:03+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-30 17:35:36" itemprop="dateModified" datetime="2020-08-30T17:35:36+08:00">2020-08-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、The-Taichi-Programming-Language"><a href="#1、The-Taichi-Programming-Language" class="headerlink" title="1、The Taichi Programming Language"></a>1、The Taichi Programming Language</h1><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h3 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a>Data types</h3><p>Taichi is strongly typed. Supported basics types include:</p>
<ul>
<li>Signed integers:  ti.i8/i16/i32/i64</li>
<li>Unsigned integers:  ti.u8/u16/u32/u64</li>
<li>Float-point numbers:  ti.f32/f64</li>
</ul>
<h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Taichi is a data-oriented programming language where tensors are first-class citizens.</p>
<ul>
<li>Tensors are essentially multi-dimensional arrays.（在Taichi种，tensor和matrix是两个完全不同的概念）</li>
<li>An element of a tensor can be either a scalar(var), a vector(ti.Vector), or a matrix(ti.Matrix)</li>
<li>Tensor elements are always accessed via the a[i, j, k] syntax. (No pointers! 编译器不易优化)</li>
<li>Access out-of-bound is undefined behavior.</li>
<li>Tensors can be spatially  sparse.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init()</span><br><span class="line">a = ti.var(dt=ti.f32, shape=(<span class="number">42</span>, <span class="number">63</span>)) <span class="comment"># A tensor of 42x63 scalars</span></span><br><span class="line">b = ti.Vector(<span class="number">3</span>, dt=ti.f32, shape=<span class="number">4</span>) <span class="comment"># A tensor of 4x3D vectors</span></span><br><span class="line">C = ti.Matrix(<span class="number">2</span>, <span class="number">2</span>, dt=ti.f32, shape=(<span class="number">3</span>, <span class="number">5</span>)) <span class="comment"># A tensor pf 3x5 2x2 matrices</span></span><br><span class="line">loss = ti.var(dt=ti.f32, shape=()) <span class="comment"># A (0-D) tensor of a single scalar</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">3</span>, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">print(<span class="string">'a[3, 4] = '</span>, a[<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># "a[3, 4] = 1.000000"</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">2</span>] = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">print(<span class="string">'b[0] ='</span>, b[<span class="number">0</span>][<span class="number">0</span>], b[<span class="number">0</span>][<span class="number">1</span>], b[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="comment"># print(b[0]) is not yet supported</span></span><br><span class="line"></span><br><span class="line">loss[<span class="literal">None</span>] = <span class="number">3</span> <span class="comment"># 没有下标</span></span><br><span class="line">print(loss[<span class="literal">None</span>]) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>a（标量张量）：有42x63个元素，每个元素是一个标量</p>
<p>b（向量张量）：tensor长度为4，向量有3个元素，4个3D vectors组成的张量</p>
<p>c（矩阵张量）：3x5的tensor，里面每个元素是一个2x2的矩阵</p>
<p>loss：0-D的张量，只有一个标量元素</p>
<h2 id="computation"><a href="#computation" class="headerlink" title="computation"></a>computation</h2><h3 id="Kernels"><a href="#Kernels" class="headerlink" title="Kernels"></a>Kernels</h3><p>Kernels——用来计算的函数。</p>
<ul>
<li>The language used in Taichi kernels and functions is similar to Python.（区别：该语言会被即时编译，Taichi自带一个编译器，把kernel里的语言编译成高性能kernel，能够运行的更快。）</li>
<li>The Taichi kernel lanuage is compiled, statically-typed, lexically-scoped, parallel and differentiable.</li>
<li>Kernels must be decorated with @ti.kernel.</li>
<li>Kernel arguments and return values must be type-hinted.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(i: ti.i32)</span>:</span></span><br><span class="line">    a = <span class="number">40</span></span><br><span class="line">    print(<span class="string">'Hello world!'</span>, a + i)</span><br><span class="line">    </span><br><span class="line">hello(<span class="number">2</span>) <span class="comment"># Hello world! 42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">()</span> -&gt; ti.i32:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s  <span class="comment"># 45</span></span><br></pre></td></tr></table></figure>

<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Taichi Functions 可以被 Taichi Kernels 调用，但是Taichi Function 不能被 python 调用。（<strong>device</strong> functions；<strong>global</strong> kernels）</p>
<p>Taichi functions can be called by Taichi kernels and other Taichi functions. They must be decorated with @ti.func.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triple_array</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">128</span>):</span><br><span class="line">        a[i] = triple(a[i])</span><br></pre></td></tr></table></figure>

<p>Taichi Function will be force-inlined(不通过压栈的方式调用，将函数体直接插入调用处). 暂时不支持递归。一个Taichi Function最多只能包含一条return statement。</p>
<h3 id="Matrices-and-linear-algebra"><a href="#Matrices-and-linear-algebra" class="headerlink" title="Matrices and linear algebra"></a>Matrices and linear algebra</h3><ul>
<li>ti.Matrix is for small matrices(e.g. 3x3) only.</li>
<li>ti.Vector is the same as ti.Matrix, except that it has only one column.</li>
</ul>
<p><strong>Note:</strong>  Differentiate element-wise product * and matrix product @</p>
<h4 id="Parallel-for-loops"><a href="#Parallel-for-loops" class="headerlink" title="Parallel for-loops"></a>Parallel for-loops</h4><p>For loops in Taichi have two forms:</p>
<ul>
<li><strong>Range-for loops</strong>, which are no different from Python for loops, except that it will be parallelized when used at the outermost scope. Range-for loops can be nested.</li>
<li><strong>Struct-for loops</strong>, which iterates over (sparse) tensor elements. </li>
</ul>
<p>For loops at the outermost scope in a Taichi kernel is <strong>automatically parallelized</strong>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># Parallelized</span></span><br><span class="line">        x[i] += i</span><br><span class="line">        </span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):  <span class="comment"># Serialized in each parallel thread</span></span><br><span class="line">            s += j</span><br><span class="line">         </span><br><span class="line">        y[i] = s</span><br><span class="line">      </span><br><span class="line"><span class="meta">@ti,kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_3d</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Parallelized for all 3&lt;=i&lt;8, 1&lt;=j&lt;6, 0&lt;=k&lt;9</span></span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> ti.ndrange((<span class="number">3</span>, <span class="number">8</span>), (<span class="number">1</span>, <span class="number">6</span>), <span class="number">9</span>):</span><br><span class="line">        x[i, j, k] = i + j + k</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> It is the loop at the outermost scope that gets parallelized, not the outermost loop.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># Parallelized</span></span><br><span class="line">        ...</span><br><span class="line">      </span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(k: ti.i32)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">42</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># Serical</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<h4 id="Struct-for-loops"><a href="#Struct-for-loops" class="headerlink" title="Struct-for loops"></a>Struct-for loops</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"></span><br><span class="line">ti.init(arch=ti.gpu)</span><br><span class="line"></span><br><span class="line">n = <span class="number">320</span></span><br><span class="line">pixels = ti.var(dt=ti.f32, shape=(n * <span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(t: ti.f32)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> pixels:  <span class="comment"># Parallelized over all pixels</span></span><br><span class="line">        pixels[i, j] = i * <span class="number">0.001</span> + j * <span class="number">0.002</span> + t</span><br><span class="line">        </span><br><span class="line">paint(<span class="number">0</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><p>In Taichi, augmented assignments (e.g.  x[i] += 1) are automatically atomic.</p>
<p>When modifying global variables in parallel, make sure you use atomic operations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">	<span class="comment"># Approach 1: OK</span></span><br><span class="line">	total[<span class="literal">None</span>] += x[i]  <span class="comment"># total 0-D tensor</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment"># Approach 2: OK</span></span><br><span class="line">	ti.atomic_add(total[<span class="literal">None</span>], x[i])</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># Approach 3: Wrong result (the operation is not atomic .)</span></span><br><span class="line">	total[<span class="literal">None</span>] = total[<span class="literal">None</span>] + x[i]</span><br></pre></td></tr></table></figure>

<h3 id="Taichi-scope-v-s-Python-scope"><a href="#Taichi-scope-v-s-Python-scope" class="headerlink" title="Taichi-scope v.s. Python-scope"></a>Taichi-scope v.s. Python-scope</h3><p><strong>Definition：</strong></p>
<ul>
<li>Taichi-scope: Everything decorated with ti.kernel and ti.func.</li>
<li>Python-scope: Code outside the Taichi-scope.</li>
</ul>
<p><strong>Note：</strong></p>
<ul>
<li>Code in Taichi-scope will be compiled by the Taichi compiler and run on parallel devices.</li>
<li>Code in Python-scope is simply Python code and will be executed by the Python interpreter.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init()</span><br><span class="line"></span><br><span class="line">a = ti.var(dt=ti.f32, shape=(<span class="number">42</span>, <span class="number">63</span>)) <span class="comment"># A tensor of 42x63 scalars</span></span><br><span class="line">b = ti.Vector(<span class="number">3</span>, dt=ti.f32, shape=<span class="number">4</span>) <span class="comment"># A tensor of 4x3D vectors</span></span><br><span class="line">C = ti.Matrix(<span class="number">2</span>, <span class="number">2</span>, dt=ti.f32, shape=(<span class="number">3</span>,<span class="number">5</span>)) <span class="comment"># A tensor of 3x5 2x2 matrices</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a[<span class="number">3</span>, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'a[3, 4] ='</span>, a[<span class="number">3</span>, <span class="number">4</span>]) </span><br><span class="line">    <span class="comment"># a[3, 4] = 1.000000</span></span><br><span class="line">    </span><br><span class="line">    b[<span class="number">2</span>] = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    print(<span class="string">'b[0] ='</span>, b[<span class="number">0</span>], <span class="string">', b[2] ='</span>, b[<span class="number">2</span>])</span><br><span class="line">    <span class="comment"># b[0] = [0.000000, 0.000000, 0.000000] , b[2] = [6.000000, 7.000000, 8.000000]</span></span><br><span class="line">    </span><br><span class="line">    C[<span class="number">2</span>, <span class="number">1</span>][<span class="number">0</span>, <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    print(<span class="string">'C[2, 1] ='</span>, C[<span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># C[2, 1] = [[0.000000, 1.000000], [0.000000, 0.000000]]</span></span><br><span class="line">    </span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<h3 id="Phases-of-a-Taichi-program"><a href="#Phases-of-a-Taichi-program" class="headerlink" title="Phases of a Taichi program"></a>Phases of a Taichi program</h3><ol>
<li>Initialization: ti.init(…)</li>
<li>Tensor allocation: ti.var, ti.Vector, ti.Matrix</li>
<li>Computation (launch kernels, access tensors in Python-scope)</li>
<li>Optional: restart the Taichi system (clear memory, destroy all variables and kernels): ti.reset()</li>
</ol>
<p><strong>Note</strong></p>
<p>For now, after the first kernel launch or tensor access in Python-scope, no more tensor allocation is allowed.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fractal.py</span></span><br><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init(arch=ti.gpu)</span><br><span class="line"></span><br><span class="line">n = <span class="number">320</span></span><br><span class="line">pixels = ti.var(dt=ti.f32, shape=(n * <span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complex_sqr</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> ti.Vector([z[<span class="number">0</span>]**<span class="number">2</span> - z[<span class="number">1</span>]**<span class="number">2</span>, z[<span class="number">1</span>]*z[<span class="number">0</span>]*<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(t: ti.f32)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> pixels: <span class="comment"># Parallelized over all pixels</span></span><br><span class="line">        c = ti.Vector([<span class="number">-0.8</span>, ti.cos(t)*<span class="number">0.2</span>])</span><br><span class="line">        z = ti.Vector([i/n<span class="number">-1</span>, j/n<span class="number">-0.5</span>]) * <span class="number">2</span></span><br><span class="line">        iterations = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> z.norm() &lt; <span class="number">20</span> <span class="keyword">and</span> iterations &lt;<span class="number">50</span>:</span><br><span class="line">            z = complex_sqr(z) + c</span><br><span class="line">            iterations += <span class="number">1</span></span><br><span class="line">        pixels[i, j] = <span class="number">1</span> - iterations * <span class="number">0.02</span></span><br><span class="line">        </span><br><span class="line">gui = ti.GUI(<span class="string">"Julia Set"</span>, res=(n*<span class="number">2</span>, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    paint(i * <span class="number">0.03</span>)</span><br><span class="line">    gui.set_image(pixels)</span><br><span class="line">    gui.show()</span><br></pre></td></tr></table></figure>

<h2 id="Debugging"><a href="#Debugging" class="headerlink" title="Debugging"></a>Debugging</h2><h3 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h3><p> ti.init(debug=True, arch=ti.cpu) initializes Taichi in debug mode, which enables bound checkers (CPU only).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line">ti.init(debug=<span class="literal">True</span>, arch=ti.cpu)</span><br><span class="line"></span><br><span class="line">a = ti.var(ti.i32, shape=(<span class="number">10</span>))</span><br><span class="line">b = ti.var(ti.i32, shape=(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        a[i] = b[i+<span class="number">1</span>] <span class="comment"># Runtime error in debug mode</span></span><br><span class="line">        </span><br><span class="line">shift()</span><br></pre></td></tr></table></figure>



<p>ti example: 查看example demo </p>
<p>python -m taichi example mpm128 (demo_name)</p>
<h1 id="2、Lagrangian-Simulation-Approaches"><a href="#2、Lagrangian-Simulation-Approaches" class="headerlink" title="2、Lagrangian Simulation Approaches"></a>2、Lagrangian Simulation Approaches</h1><h2 id="Mass-Spring-Systems-弹簧质点系统"><a href="#Mass-Spring-Systems-弹簧质点系统" class="headerlink" title="Mass-Spring Systems (弹簧质点系统)"></a>Mass-Spring Systems (弹簧质点系统)</h2><img src="F:\blog\source\_posts\Taichi\mass_spring.png" alt="mass_spring" style="zoom:57%;" />

<p>k: spring stiffness; l<sub>ij</sub>: spring rest length between particle i and particle j;</p>
<p>m<sub>i</sub>: the mass of particle i. (<strong>x<sub>i</sub></strong> − <strong>x<sub>j</sub></strong>): direction vector from particle j to particle i;</p>
<h2 id="Time-integration"><a href="#Time-integration" class="headerlink" title="Time integration"></a>Time integration</h2><p><strong>1、Forward Euler</strong> (explicit)：</p>
<p>​        前向欧拉法：根据现有的状态推测以后的状态：</p>
<p><img src="F:%5Cblog%5Csource_posts%5CTaichi%5Cforward_euler.png" alt="forward_euler"></p>
<p><strong>2、Semi-implicit Euler</strong> (aka. symplectic Euler, explicit)：</p>
<p><img src="F:%5Cblog%5Csource_posts%5CTaichi%5CSemi-implicit_euler.png" alt="Semi-implicit_euler"></p>
<p><strong>3、Backward Euler</strong> (often with Newton’s method, implicit)：</p>
<h3 id="Implementing-a-mass-spring-system-with-symplectic-Euler"><a href="#Implementing-a-mass-spring-system-with-symplectic-Euler" class="headerlink" title="Implementing a mass-spring system with symplectic Euler"></a>Implementing a mass-spring system with symplectic Euler</h3><ol>
<li>Compute new velocity using<br>$$<br>v_{t+1} = v_t + \Delta t\frac{f_t}{m}<br>$$</li>
</ol>
<ol start="2">
<li><p>Collision with ground</p>
</li>
<li><p>Compute new position using<br>$$<br>x_{t+1} = x_t + \Delta tv_{t+1}<br>$$</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/23/Weakly-compressible-SPH-for-free-surface-flows/" class="post-title-link" itemprop="url">Weakly compressible SPH for free surface flows</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-23 16:58:36 / 修改时间：23:05:31" itemprop="dateCreated datePublished" datetime="2020-08-23T16:58:36+08:00">2020-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">交互式应用中基于粒子的流体模拟</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-13 09:52:09" itemprop="dateCreated datePublished" datetime="2020-08-13T09:52:09+08:00">2020-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-19 15:12:52" itemprop="dateModified" datetime="2020-08-19T15:12:52+08:00">2020-08-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realistically animated fluids can add substantial realism to interactive applications such as virtual surgery simulators or computer games. In this paper we propose an interactive method based on Smoothed Particle Hydrodynamics(SPH) to simulate fluids with free surfaces. The method is an extension of the SPH-based technique by Desbrun to animate highly deformable bodies. We gear the method towards fluid simulation by deriving the force density fields directly from the Navier-Stokes equation and by adding a term to model surface tension effects. In contrast to Eulerian grid-based approaches, the particle-based approach makes mass conservation equations and convection terms dispensable which reduces the complexity of the simulation. In addition, the particles can directly be used to render the surface of the fluid. We propose methods to track and visualize the free surface using point splatting and marching cubes-based surface reconstruction. Our animation method is fast enough to be used in interactive systems and to allow for user interaction with models consisting of up to 5000 particles.</span><br></pre></td></tr></table></figure>

<p><strong>Smoothed Particle Hydrodynamics (SPH)</strong></p>
<p>​        光滑粒子流体动力学。拉格朗日视角，一种无网格方法。该方法的基本思想是将连续的流体(或固体)用相互作用的质点组来描述，各个物质点上承载各种物理量，包括质量、速度等，通过求解质点组的动力学方程和跟踪每个质点的运动轨道，求得整个系统的力学行为。</p>
<p>​        对于流体的研究，有两种不同的坐标系，分别是欧拉法和拉格朗日法。欧拉视角的坐标系是固定的，如同站在河边观察河水的流动一样，用这种视角分析流体需要建立网格单元，还会涉及到有限元等复杂的工程方法，一般用在离线的应用中。而拉格朗日视角则将流体视为流动的单元，例如将一片羽毛放入风中，那么羽毛的轨迹可以帮我们指示空气的流动规律。SPH算法是典型的拉格朗日视角，它的基本原理就是通过粒子模拟流体的运动规律，然后再转换成网格进行流体渲染。</p>
<p><strong>force density</strong></p>
<p>​        力密度</p>
<p><strong>Navier-Stokes equation</strong></p>
<p>​        纳维-斯托克斯方程，描述粘性不可压缩流体动量守恒的运动方程。简称N-S方程。粘性流体的运动方程首先由Navier在1827年提出，只考虑了不可压缩流体的流动。Poisson在1831年提出可压缩流体的运动方程。Saint-Venant在1845年，Stokes在1845年独立提出粘性系数为一常数的形式，都称为Navier-Stokes方程，简称N-S方程。</p>
<p><strong>surface tension</strong></p>
<p>​        表面张力。水等液体会产生使表面尽可能缩小的力，这个力称为“表面张力”。液体具有内聚性和吸附性，这两者都是分子引力的表现形式。内聚性使液体能抵抗拉伸应力，而吸附性则使液体可以黏附在其他物体上面。在液体和气体的分界处，即液体表面及两种不能混合的液体之间的界面处，由于分子之间的吸引力，产生了极其微小的拉力。假想在表面处存在一个薄膜层，它承受着此表面的拉伸力，液体的这一拉力称为表面张力。</p>
<p><strong>Eulerian</strong></p>
<p>​        欧拉法。是以流体质点流经流场中各空间点的运动即以流场作为描述对象研究流动的方法——流场法。它不直接追究质点的运动过程，而是以充满运动液体质点的空间——流场为对象。研究各时刻质点在流场中的变化规律。将个别流体质点运动过程置之不理，而固守于流场各空间点。通过观察在流动空间中的每一个空间点上运动要素随时间的变化，把足够多的空间点综合起来而得出的整个流体的运动情况。</p>
<p><strong>流体运动的数学描述</strong></p>
<p>​        <strong>拉格朗日（Lagrange ）法——随体法</strong></p>
<p>​        拉格朗日法着眼于研究各个流体质点的运动，描述的流体质点至始至终的运动过程以及它们的物理量随时间t的变化规律。</p>
<p>​        <strong>欧拉（Euler ）法——当地法</strong></p>
<p>​        欧拉法着眼于空间点，描述的是各个时刻，各个空间点（场论的概念）中流体质点物理量的变化情况。物理量在空间中的分布称为物理场，如速度场、压力场、密度场等，这些所有的物理量场统称为流场。</p>
<p><strong>mass conservation</strong></p>
<p>​        质量守恒。</p>
<p><strong>convection terms</strong></p>
<p>​        对流项。速度运输动量。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><strong>1.1 Motivation</strong></p>
<p>​        不太精确的方法允许实时模拟流体效应，这开辟了各种新的应用。实时方法有助于在设计阶段测试某个概念是否有前途。流体实时模拟技术的其他应用包括医学模拟器、计算机游戏或任何类型的虚拟环境。</p>
<p><strong>1.2 Related Work</strong></p>
<p>​        Computational Fluid Dynamics (CFD) 计算流体力学 历史：</p>
<p>​        1822年Claude Navier和1845年George Stokes建立了著名的Navier-Stokes方程，描述了流体动力学；</p>
<p>​        描述质量守恒的连续性方程和描述能量守恒的状态方程；</p>
<p>​        1983年，T. Reeves引入了粒子系统作为一种建模一类模糊对象的技术。此后，基于粒子的拉格朗日方法和基于网格的欧拉方法被用于计算机图形学中流体的模拟；</p>
<p>​        Desbrun和Cani和Tonnesen使用粒子使软物体产生动画效果；</p>
<p>​        本文提出了一种基于光滑粒子流体动力学的基于质点的方法来实现任意流体运动的动画。</p>
<p><strong>1.3. Our Contribution</strong></p>
<p>​        提出了一种基于光滑粒子流体动力学(SPH)的方法来模拟具有自由表面的流体。Stam和Fiume首先将SPH引入图形界，以描述火和其他气体现象。后来，德斯布伦使用SPH动画高度可变形的物体。我们将他的方法扩展到流体的模拟上。为此，我们直接从Navier-Stokes方程推导出粘性力场和压力场，并提出了一种表面张力的建模方法。为了实现交互性，我们设计了新的专用平滑核。在交互速率下的表面跟踪和表面绘制是一个困难的问题，我们描述了可能的解决方案。</p>
<h2 id="2-Smoothed-Particle-Hydrodynamics"><a href="#2-Smoothed-Particle-Hydrodynamics" class="headerlink" title="2. Smoothed Particle Hydrodynamics"></a>2. Smoothed Particle Hydrodynamics</h2><p>​        SPH是粒子系统的一种插值方法。有了SPH，仅在离散粒子位置定义的场量可以在空间的任何地方计算。为此，SPH在每个粒子的局部邻域分布数量使用径向对称平滑核。</p>
<p>​        “平滑核”可以这样理解这个概念，粒子的属性都会“扩散”到周围，并且随着距离的增加影响逐渐变小，这种随着距离而衰减的函数被称为“平滑核”函数，最大影响半径为“平滑核半径”。</p>
<p>​        根据SPH，在<strong>r</strong>位置，平滑核半径h范围内有数个粒子，位置为<strong>r<sub>0</sub></strong>到<strong>r<sub>j</sub></strong>，用所有粒子贡献的加权和表示插值标量A:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F1.png" alt="公式1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F1.png" class="" title="This is image1">

<p><em>其中A<sub>j</sub>是在r<sub>j</sub>位置要迭代的某种属性，m<sub>j</sub>和ρ<sub>j</sub>是粒子j的质量和密度，<strong>r<sub>j</sub></strong>是该粒子的位置，h是平滑核半径。函数W就是平滑核函数。</em></p>
<p>​        函数W(r,h)称为核半径为h的平滑核，由于我们只使用有限支撑集（support，也就是函数值不为0的点所组成的集合）的核，因此在公式中我们使用h作为支撑集半径。如果W为偶函数(即W(r,h) =W(−r,h))并归一化，插值具有二阶精度。平滑核函数是标准化的：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F2.png" alt="公式2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F2.png" class="" title="This is image2">

<p>​        粒子质量和密度出现在公式(1)中，每个粒子i的体积V<sub>i</sub> = m<sub>i</sub> /ρ<sub>i</sub> ，在整个模拟过程中质量m<sub>i</sub> 是恒定的，密度ρ<sub>i</sub> 是变化的，并且需要在每个时间步长进行评估。通过代入公式(1)得到位置r处的密度:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F3.png" alt="公式3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F3.png" class="" title="This is image3">

<p>​        在大多数流体方程中，出现了场量的导数，并需要计算。在SPH方法中，这些导数只影响平滑核。A的梯度：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F4.png" alt="公式4"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F4.png" class="" title="This is image4">

<p>​        A的拉普拉斯式求值是：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F5.png" alt="公式5"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F5.png" class="" title="This is image5">

<p>​        SPH存在一些固有的问题。当用SPH推导粒子的流体方程时，这些方程不能保证满足某些物理原理，如力的对称性和动量守恒。</p>
<h2 id="3-Modelling-Fluids-with-Particles"><a href="#3-Modelling-Fluids-with-Particles" class="headerlink" title="3. Modelling Fluids with Particles"></a>3. Modelling Fluids with Particles</h2><p>​        这部分介绍基于SPH的模型和技术，以解决这些SPH相关的问题。</p>
<p>​        在基于网格的欧拉公式中，等温流体由速度场v、密度场ρ和压力场p来描述。这些量随时间的变化由两个方程给出。第一个方程保证了质量守恒：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F6.png" alt="公式6"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F6.png" class="" title="This is image6">

<p>​        Navier-Stokes方程则表示动量守恒：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F7.png" alt="公式7"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F7.png" class="" title="This is image7">

<p><em>g为重力加速度，μ为流体的粘度（粘性系数）。公式(7)表示不可压缩流体的简化形式。</em></p>
<p>​        使用粒子而不是静止网格大大简化了这两个方程。首先，因为粒子的数量是恒定的，每个粒子的质量恒定，质量守恒是有保证的，公式(6)可以完全省略。第二，公式(7)左边的 <u>∂v/∂t+v·∇v</u> 可以用随体导数Dv/Dt代替。由于粒子随流体运动，速度的随体导数仅仅是粒子速度的时间导数，这意味着粒子系统不需要对流项v·∇v。</p>
<p>​        在公式(7)的右边有三个力密度场。建模压力(−∇p)、外力(ρ<strong>g</strong>)、粘度(μ∇<sup>2</sup><strong>v</strong>)。这些力密度场<strong>f</strong> =−∇p+ρ<strong>g</strong>+μ∇<sup>2</sup><strong>v</strong>的和决定了左边粒子的动量变化量ρDv/Dt。对于粒子i的加速度，则有:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F8.png" alt="公式8"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F8.png" class="" title="This is image8">



<p>下面使用SPH来建模力密度项</p>
<h3 id="3-1-Pressure"><a href="#3-1-Pressure" class="headerlink" title="3.1 Pressure"></a>3.1 Pressure</h3><p>​        将SPH规则应用到压力项−∇p：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F9.png" alt="公式9"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F9.png" class="" title="This is image9">

<p>​        不幸的是，当只有两个粒子相互作用时，这种力是不平衡的。由于核函数在中心的梯度为零，粒子i只使用粒子j的压力来计算其压力，反之亦然。由于两个粒子位置上的压力一般不相等，所以压力不会是平衡的。文献中提出了公式(9)不同的平衡方法。我们建议了一个非常简单的解决方案，发现它最适合我们的速度和稳定的目的：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F10.png" alt="公式10"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F10.png" class="" title="This is image10">

<p>​        这样计算出来的压力是平衡的，因为它使用了相互作用粒子压力的算术平均值。</p>
<p>​        由于粒子只携带质量、位置和速度三个量，因此必须首先评估粒子位置处的压力。这需要两个步骤。公式(3)产生粒子所在位置的密度。然后，通过理想气体状态方程计算压强：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F11.png" alt="公式11"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F11.png" class="" title="This is image11">

<p><em>k是一个气体常数，它只与温度有关</em></p>
<p>​        改进：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F12.png" alt="公式12"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F12.png" class="" title="This is image12">

<p>​        ρ<sub>0</sub>是流体的静态密度（标准密度）。</p>
<p>​        由于压力依赖于压力场的梯度，从数学上讲，偏移量对压力没有影响。然而，偏移量对SPH平滑场的梯度有一定的影响，使数值模拟更加稳定。</p>
<h3 id="3-2-Viscosity"><a href="#3-2-Viscosity" class="headerlink" title="3.2 Viscosity"></a>3.2 Viscosity</h3><p>​        将SPH规则应用到粘度项μ∇<sup>2</sup><strong>v</strong>，得到不平衡的作用力：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F13.png" alt="公式13"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F13.png" class="" title="This is image13">

<p><em>速度场随粒子而变化。</em></p>
<p>​        由于粘滞力只依赖于速度差而不依赖于绝对速度，因此有一种利用速度差来对称粘滞力的自然方法:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F14.png" alt="公式14"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F14.png" class="" title="This is image14">

<p>​        公式(14)的一种可能的解释是从粒子i自身的运动参照系观察粒子i的邻域。那么粒子i就会朝着它周围环境的相对速度方向加速。</p>
<h3 id="3-3-Surface-Tension"><a href="#3-3-Surface-Tension" class="headerlink" title="3.3 Surface Tension"></a>3.3 Surface Tension</h3><p>​        基于Morris的思想模拟表面张力。流体中的分子受到邻近分子的引力。在流体内部，这些分子间的力在各个方向上是相等的，并且相互平衡。相反，作用在自由表面分子上的力是不平衡的。净力(即表面张力)作用于表面垂直于流体的方向。他们也倾向于最小化表面的曲率。曲率越大，力就越大。表面张力还取决于张力系数σ，该系数取决于形成表面的两种流体。</p>
<p>​        流体的表面可以通过使用一个附加的场量来找到，这个场量在存在粒子的位置上为1，不存在粒子的位置为0。这个场称为色场。对于平滑的色场，我们得到:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F15.png" alt="公式15"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F15.png" class="" title="This is image15">

<p>​        平滑的色场的梯度：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F16.png" alt="公式16"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F16.png" class="" title="This is image16">

<p>​        产生指向流体的表面法向场，n的散度测量表面的曲率：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F17.png" alt="公式17"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F17.png" class="" title="This is image17">

<p>​        对于凸面的流体体积，负曲率是得到正曲率的必要条件。综上所述，我们得到了表面牵引力:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F18.png" alt="公式18"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F18.png" class="" title="This is image18">

<p>​        为了在表面附近的粒子之间分配表面牵引力，并获得力密度，我们乘以一个归一化标量场δs=| <strong>n</strong> |，该场仅在表面附近是非零的。对于作用在表面附近的力密度，我们得到：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F19.png" alt="公式19"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F19.png" class="" title="This is image19">

<p>​        在|<strong>n</strong>|较小的位置计算<strong>n</strong>/|<strong>n</strong>|会造成数值问题。我们只在|<strong>n</strong>|超过某个阈值时计算力。</p>
<h3 id="3-4-External-Forces"><a href="#3-4-External-Forces" class="headerlink" title="3.4 External Forces"></a>3.4 External Forces</h3><p>​        我们的模拟器支持外力，如重力，碰撞力和用户交互引起的力。这些力直接施加在粒子上，而不使用SPH。在我们的例子中，当粒子与固体物体（如玻璃）碰撞时，我们只需将它们推出物体，并反射垂直于物体表面的速度分量。</p>
<h3 id="3-5-Smoothing-Kernels"><a href="#3-5-Smoothing-Kernels" class="headerlink" title="3.5 Smoothing Kernels"></a>3.5 Smoothing Kernels</h3><p>​        SPH方法的稳定性、精度和速度在很大程度上取决于平滑核的选择。由于核函数都是偶函数且归一化的，所以我们使用的核函数有二阶插值误差（见图1）。</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%9B%BE1.png" alt="图1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%9B%BE1.png" class="" title="This is image_1">

<p><em>我们在模拟中使用的三个平滑核W<sub>poly6</sub>、W<sub>spiky</sub>和W<sub>viscosity</sub>（从左到右）。粗线表示核函数，细线表示向中心方向的梯度，虚线表示拉普拉斯函数。请注意，这些图的比例不同。曲线显示沿一个轴通过平滑长度h=1的中心的三维核函数。</em></p>
<p>​        此外，在边界处导数为零的核有利于稳定性。除了这些约束，人们还可以自由地为特殊目的设计核函数。我们设计了下面的核函数：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F20.png" alt="公式20"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F20.png" class="" title="This is image20">

<p>​    除了两种情况外，所有情况下都使用它。这个简单核函数的一个重要特征是r只出现平方，这意味着在距离计算中不需要计算平方根。然而，如果用这个核函数来计算压力，粒子往往会在高压下形成团簇。当粒子彼此非常接近时，斥力消失，Poly6核的梯度在中心变为0，因此它不适用于插值压力，为了使粒子接近时具有较大的压力，必须使用另一种梯度在0点有较大取值的平滑核来插值压力，称为Spiky核，该内核在中心附近有一个非消失的梯度。对于压力的计算，我们使用Debrun的Spiky核：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F21.png" alt="公式21"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F21.png" class="" title="This is image21">

<p>​        这产生了必要的斥力。在边界处，一阶导数和二阶导数都为零。</p>
<p>​        粘性是一种由摩擦引起的现象，通过将流体加热来降低流体的动能。因此，粘性只对速度场有平滑作用。然而，如果用一个标准核来计算粘度，则产生的粘性力并不总是具有这种性质。对于两个相互靠近的粒子，平滑速度场的拉普拉斯系数（粘性力依赖于此）可能会变为负值，从而导致粘性力增加其相对速度。在粗采样的速度场中会出现伪影。在粒子数相对较少的实时应用中，这种影响会导致稳定性问题。因此需要使用另一种平滑核插值粘性力，称为粘度核：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F22.png" alt="公式22"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F22.png" class="" title="This is image22">

<p>​        它的拉普拉斯方程处处为正，并具有以下附加性质:</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cproperties.png" alt="properties"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/properties.png" class="" title="This is image_2">

<p>​        使用此核来进行黏性力计算，大大提高了模拟的稳定性，可以省略任何类型的附加阻尼。</p>
<h3 id="3-6-Simulation"><a href="#3-6-Simulation" class="headerlink" title="3.6 Simulation"></a>3.6 Simulation</h3><p>​        对于公式(8)的积分，我们采用蛙跳法。作为一个只需计算一次力的二阶方案，它最适合我们的目的，在我们的例子中允许时间步长达10毫秒。对于这些例子，我们使用恒定的时间步长。如果基于Courant-Friedrichs-Lewy条件使用自适应时间步长，我们预计会有更好的性能。</p>
<p><strong>蛙跳差分格式</strong></p>
<p>​        蛙跳格式是一个很常用的差分格式，它在时间和空间上都采用中心差分。（通过解差分方程来求微分方程的近似解，是连续问题离散化）假设离散化如下图所示：</p>
<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog1.png" alt="leap_frog1" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog1.png" class="" title="This is image_3">

<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog2.png" alt="leap_frog2" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog2.png" class="" title="This is image_4">

<p>​        蛙跳格式是时间和空间上均为二阶精度的，三层一步显式差分格式。因而，为了计算(n+1)层的值，需要(n-1)层和n层的已知值。另外，还可以看出，后一偶数层的值实际上等于前一偶数层的值加上一个变化量，而跳过其间的奇数层，这就是蛙跳式这个名称的来历。</p>
<img src="F:\blog\source\_posts\交互式应用中基于粒子的流体模拟\leap_frog3.png" alt="leap_frog3" style="zoom:80%;" />

<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog3.png" class="" title="This is image_5">

<p><strong>CFL收敛条件判断数</strong></p>
<p>​        CFL数是计算流体力学中，判断计算的收敛条件，具体是差分方程的依赖域必须包含相应微分方程的依赖域，最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。Time stepping technique是指时间推进技术，一般有统一时间步长和当地时间步长，而选择当地时间步长也就是当地CFL条件允许的最大时间步长，采用这种方法能够加速收敛，节省计算时间。</p>
<h2 id="4-Surface-Tracking-and-Visualization"><a href="#4-Surface-Tracking-and-Visualization" class="headerlink" title="4. Surface Tracking and Visualization"></a>4. Surface Tracking and Visualization</h2><p>​        第3.3节中定义的色场c<sub>S</sub>及其梯度<strong>n</strong>=∇c<sub>S</sub>可用于识别表面粒子和计算表面法线。</p>
<p>​        我们把粒子i定义为表面粒子，如果：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F23.png" alt="公式23"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F23.png" class="" title="This is image23">

<p>​        其中l是阈值参数。粒子i位置处的表面法线方向由下式给出：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5C%E5%85%AC%E5%BC%8F24.png" alt="公式24"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E5%85%AC%E5%BC%8F24.png" class="" title="This is image24">

<h3 id="4-1-Point-Splatting"><a href="#4-1-Point-Splatting" class="headerlink" title="4.1 Point Splatting"></a>4.1 Point Splatting</h3><p>​        我们现在有一组法线但没有连通性信息的点。这正是point splatting（把点变成有面积的简单几何形状渲染）所需的信息类型。然而，这些方法被设计用于处理从通常至少包含10,000到100,000个点的扫描仪获得的点云。我们只使用了几千个粒子，其中一小部分被确定存在于表面。如结果部分所示，静止表面飞溅会产生似乎合理的结果。我们目前正在研究提高液体表面采样率的方法。因此，插值表面粒子的颜色场信息，在仅用于渲染的表面上寻找附加粒子的位置。</p>
<h3 id="4-2-Marching-Cubes"><a href="#4-2-Marching-Cubes" class="headerlink" title="4.2 Marching Cubes"></a>4.2 Marching Cubes</h3><p>​        另一种可视化自由表面的方法是绘制色场c<sub>S</sub>的等值面。我们使用移动立方体算法对等值面进行三角剖分。在空间固定的网格中，首先识别包含表面的单元格。我们从包含表面粒子的所有单元格开始搜索，然后沿着表面递归地遍历网格。使用哈希表，我们可以确保单元格不会被访问超过一次。对于识别出包含表面的每个单元格，三角形是通过快速查表生成的。</p>
<p><strong>Marching Cubes算法</strong></p>
<p>​        Marching Cubes算法是三维离散数据场中提取等值面的经典算法。算法主要的思想是在三维离散数据场中通过线性插值来逼近等值面，具体如下：三维离散数据场中每个栅格单元作为一个体素，体素的每个顶点都存在对应的标量值。如果体素顶点上的值大于或等于等值面值，则定义该顶点位于等值面之外，标记为“0”；而如果体素顶点上的值小于等值面值，则定义该顶点位于等值面之内，标记为“1”。由于每个体素单元有8个顶点，每个顶点有2种状态，那么共存在2<sup>8</sup> = 256种情形。但由于反转状态不变，所以可以减少一半，为128种。再根据旋转不变形，又可以减少到15种情况。</p>
<p>​        如图所示：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/MC_15%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="MC_15种情况"></p>
<p>​        每个体素单元上顶点和边的索引规则如下图左所示，假如体素下方的顶点3的值小于等值面值，其他顶点上的值都大于等值面值（如下图右所示），那么我们可以生成一个与体素边2，3，11相交的三角面片，而三角面片顶点的具体位置则需要根据等值面值和边顶点3-2，3-0，3-7的值线性插值计算得到。</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E7%AD%89%E5%80%BC%E9%9D%A2.png" alt="等值面"></p>
<p>​        对于与等值面存在交点的体素边，交点坐标用P表示，P1、P2代表边上两个端点的坐标，V1、V2代表这两个端点上的值，V代表等值面值，那么交点坐标的计算公式：P = P1 + (V – V1)·(P2 – P1)/(V2 – V1)</p>
<p><strong>算法第一步：</strong>通过edgeTable表判断等值面和体素单元哪一条边相交</p>
<p>​        体素单元顶点状态的索引号定义规则如下：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E9%A1%B6%E7%82%B9%E7%8A%B6%E6%80%81%E7%B4%A2%E5%BC%95.png" alt="顶点状态索引"></p>
<p>​        以上图所示为例，仅顶点3标记为“1”，其他顶点标记为“0”，那么体素单元的顶点状态为0000 1000或者8，通过查找表得到edgeTable[8] = 1000 0000 1100，意味着体素单元的边2，3，11和等值面相交，然后通过线性插值计算各个交点的位置。</p>
<p><strong>算法第二步：</strong>通过triTable表生成对应三角面片的组成情况</p>
<p>　　还是以上图所示为例，通过查找表得到triTable[8] = {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}，意味着该种顶点状态可以生成三角面片(3, 11, 2)，代表三角面片的3个顶点为边3，11，2和等值面相交的交点。</p>
<p>　　经过上述步骤之后，我们可以得到等值面的点面信息。为了进一步完善显示效果，需要调整顶点法向。假设顶点(i, j, k)上的值为f(i, j, k)，采用中心差分方法可以计算该点处的梯度矢量：</p>
<img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/%E4%B8%AD%E5%BF%83%E5%B7%AE%E5%88%86%E6%B3%95.png" alt="中心差分法" style="zoom:90%;" />

<p>​        对G进行归一化，得到顶点(i, j, k)上的单位法向量，然后对体素单元上8个顶点的法向量进行线性插值就可得到三角面片各个顶点的显示法向量。</p>
<h2 id="5-Implementation"><a href="#5-Implementation" class="headerlink" title="5. Implementation"></a>5. Implementation</h2><p>​        由于SPH中使用的平滑核具有有限的支持集h，降低计算复杂度的一种常用方法是使用h大小的网格，然后只需在粒子自己的单元和所有相邻的单元中搜索粒子i的潜在交互伙伴。该技术将力计算步骤的时间复杂度从O（n<sup>2</sup>）降低到O（nm），m是每个网格单元的平均粒子数。</p>
<p>​        通过一个简单的附加技巧，我们可以将模拟速度提高10倍。我们将粒子对象的副本存储在网格单元中(使内存消耗加倍)，而不是存储对粒子的引用。加速的原因是内存中接近插值所需的信息，这大大提高了cash命中率。通过使用希尔伯特空间填充曲线进行更好的聚类，可能进一步加速。快速近邻搜索的数据结构也用于曲面跟踪和渲染。</p>
<p><strong>SPH的求解过程</strong></p>
<p>​        标准SPH的求解过程可以由下图概括（[Kelager2006] ）</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/SPH%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.png" alt="SPH求解过程"></p>
<p>详细的算法过程如下：</p>
<ol>
<li>对于全部的粒子建立空间索引；</li>
<li>对于全部的粒子计算粘性力、合外力，压强，密度，并根据这些力的作用计算粒子的加速度；</li>
<li>根据粒子的加速度与时间步长得到下一时刻的速度和位置（时间积分, Time integration），并处理必要的碰撞。</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li>对于步骤1，由于SPH是考察一个粒子被周围粒子影响效应的叠加，我们需要在整个粒子空间中遍历多次，时间复杂度为<strong>O</strong>(<strong>n</strong>)。加速方法可以采用快速最近邻查找算法（原始文献参见[Teschner2003]）。[Kelager2006] 给这个算法做了一个简单的概括；</li>
<li>对于步骤2，对于某些确定的物理量，我们需要决定哪些粒子对我们考察的粒子产生影响。这些粒子的范围是由核函数的支撑集长度决定的；流体的不可压缩性是由我们人为引入的压强所保证的；</li>
<li>对于步骤3，我们可以使用很多时间积分方法，比如前向欧拉（Forward Euler），蛙跳（Leap Frog）等。蛙跳法的具体形式如下：</li>
</ol>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog4.png" alt="leap_frog4"></p>
<p>​        其中：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/leap_frog5.png" alt="leap_frog5"></p>
<h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6. Results"></a>6. Results</h2><p>​        图R1所示，用2200个粒子对玻璃中的水进行采样。外部旋转力使流体形成漩涡。第一张图（a）显示了单个粒子。对于第二幅图像（b），仅用point splatting渲染自由表面。在这两种模式下，动画以每秒20帧的速度在1.8GHz的Pentium IV PC上运行，并带有Gforce4显卡。当使用marching cubes算法将颜色场的等值面可视化时，会产生最令人信服的结果，如图（c）所示。但是，在这种模式下，帧速率下降到每秒5帧。尽管如此，这种帧速率仍然明显高于大多数离线流体模拟技术，而且随着下一代图形硬件的发展，实时性能将成为可能。</p>
<p>​        图R2所示的图像序列演示了与流体的交互作用。通过鼠标移动，用户产生一个使水飞溅的外力场。自由表面使用point splatting进行渲染，而孤立的粒子绘制为单个液滴。对1300个粒子的模拟以每秒25帧的速度运行。</p>
<p>​        对于图R3中所示的动画，我们使用了3000个粒子，并以每秒5帧的速度用marching cubes技术渲染了表面。</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult1.png" alt="result1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result1.png" class="" title="This is image_result1">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult2.png" alt="result2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result2.png" class="" title="This is image_result2">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Cresult3.png" alt="result3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/result3.png" class="" title="This is image_result3">

<h2 id="7-Conclusions-and-FutureWork"><a href="#7-Conclusions-and-FutureWork" class="headerlink" title="7. Conclusions and FutureWork"></a>7. Conclusions and FutureWork</h2><p>​        提出了一种基于粒子的交互式流体模拟与绘制方法。物理模型基于平滑粒子流体力学，并使用特殊用途的核来提高稳定性和速度。我们介绍了跟踪和渲染流体自由表面的技术。结果还不如离线计算的动画那样逼真。然而，考虑到仿真模拟是以交互速率运行的，而不是像今天的离线方法那样每帧花费几分钟或几小时，结果是相当有希望的。</p>
<p>​        在满足物理模型要求的前提下，流体表面的实时跟踪与渲染仍然是一个有待研究的课题。在未来，我们将研究提高采样技术以及提高基于marching cubes算法性能的方法。</p>
<h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>​        <strong>哈密顿算子𝛁</strong></p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5CNabla.png" alt="Nabla"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/Nabla.png" class="" title="This is Hamiltonian">

<p>​        𝛁在运算中既有微分又有矢量的双重运算性质。</p>
<p>​        与梯度、散度、旋度的关系：</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct2.png" alt="t2"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t2.png" class="" title="This is image_t2">

<p>​        把它作用在一个标量场A=f(x,y,z)上，那么：</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/grad.png" alt="grad"></p>
<p>​        这个运算可以视为一个矢量和标量的乘法，得到的∇A是一个矢量场，称为A的“梯度”，表示标量场A在某处的变化快慢和方向。</p>
<p>​        而如果把哈密顿算子作用在一个矢量场A上，得到的∇·A称为矢量场A的“散度”，散度的计算和矢量的点积运算相似，得到的是一个标量场。</p>
<p><img src="https://hexo-1257922593.cos.ap-beijing.myqcloud.com/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/div.png" alt="div"></p>
<p>​        <strong>拉普拉斯算子</strong></p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct3.png" alt="t3"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t3.png" class="" title="This is image_t3">

<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct4.png" alt="t4"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t4.png" class="" title="This is image_t4">

<p>​        </p>
<p>​        在一个时空连续变化的物理场φ(<strong>r</strong>,t)中，运动的观察点观察到的物理量φ的时间变化可以写</p>
<p>为（式中 𝜹𝒓为观察点在微元时间 𝛿𝑡中的矢量位移， 𝜹𝒓=𝛿𝑡 𝒗<sub>𝑂</sub> ，𝛁是哈密顿算子）</p>
<p><img src="F:%5Cblog%5Csource_posts%5C%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F%5Ct1.png" alt="t1"></p>
<img src="/2020/08/13/%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%BA%94%E7%94%A8%E4%B8%AD%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E7%9A%84%E6%B5%81%E4%BD%93%E6%A8%A1%E6%8B%9F/t1.png" class="" title="This is image_t1">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">数据结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 15:58:49" itemprop="dateCreated datePublished" datetime="2020-08-12T15:58:49+08:00">2020-08-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/" class="post-title-link" itemprop="url">编译原理（7）L R分析程序及其自动构造</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:41:36" itemprop="dateCreated datePublished" datetime="2020-05-31T22:41:36+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 10:05:07" itemprop="dateModified" datetime="2020-08-01T10:05:07+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="7-1-LR分析概述"><a href="#7-1-LR分析概述" class="headerlink" title="7.1 LR分析概述"></a>7.1 LR分析概述</h2><p>shift 移进</p>
<p>reduce 归约</p>
<p>acc 接受</p>
<p>空格 error</p>
<p><strong>LR（K）</strong></p>
<ul>
<li>L  从左至右扫描输入符号串</li>
<li>R 构造一个最右推导的逆过程</li>
<li>K 向右顺序查看输入串的K个符号</li>
<li>LR（0）:在分析过程中不需向右查看输入符号。</li>
</ul>
<p>四种分析器： LR(0)  SLR(1)  LR(1)  LALR(1)</p>
<p>SLR(1)和LALR(1)分别是LR(0)和LR(1)的一种改进。</p>
<h3 id="LR分析器模型"><a href="#LR分析器模型" class="headerlink" title="LR分析器模型"></a>LR分析器模型</h3><img src="编译原理（7）L-R分析程序及其自动构造\image-20200614142419341.png" alt="image-20200614142419341" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614142419341.png" class="" title="This is image_a">

<h3 id="LR分析算法"><a href="#LR分析算法" class="headerlink" title="LR分析算法"></a>LR分析算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">置ip指向输入串w的第一个符号</span><br><span class="line">令S为栈顶状态</span><br><span class="line">   a是ip指向的符号</span><br><span class="line">重复 begin</span><br><span class="line">if  ACTION[S,a]&#x3D;Sj</span><br><span class="line">       then   begin  PUSH j,a(进栈)</span><br><span class="line">                     ip 前进(指向下一输入符号)</span><br><span class="line">               end</span><br><span class="line">else if ACTION[S,a]&#x3D;rj     (第j条产生式为A→B)</span><br><span class="line">	then begin</span><br><span class="line">    pop  |β|  项</span><br><span class="line">    令当前栈顶状态为S’</span><br><span class="line">    push GOTO[S’,A]和A(进栈)</span><br><span class="line">    end</span><br><span class="line">    else if ACTION[s,a]&#x3D;acc</span><br><span class="line">        then return (成功）</span><br><span class="line">        else error</span><br><span class="line">    end.重复</span><br><span class="line"></span><br><span class="line">其中，Sj&#x3D;GOTO[Si,X]表示当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj</span><br></pre></td></tr></table></figure>

<h3 id="LR分析程序"><a href="#LR分析程序" class="headerlink" title="LR分析程序"></a>LR分析程序</h3><p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">G[S]: S → a A c B e   [1]   </span><br><span class="line">      A → b           [2] </span><br><span class="line">      A → Ab          [3]		</span><br><span class="line">      B → d           [4]</span><br><span class="line">w&#x3D;abbcde#</span><br><span class="line"></span><br><span class="line">Step   states.   Syms.   The rest of input	action goto</span><br><span class="line">1        0        #            abbcde#           s2</span><br><span class="line">2        02       #a           bbcde#            s4</span><br><span class="line">3        024      #ab          bcde#             r2   goto(2,A)</span><br><span class="line">4        023      #aA          bcde#             s6</span><br><span class="line">5        0236     #aAb         cde#              r3</span><br><span class="line">6        023      #aA          cde#              s5</span><br><span class="line">7        0235     #aAc         de#               s8</span><br><span class="line">8        02358    #aAcd        e#                r4 </span><br><span class="line">9        02357    #aAcB        e#                s9</span><br><span class="line">10       023579   #aAcBe       #                 r1</span><br><span class="line">11       01       #S           #                 acc</span><br></pre></td></tr></table></figure>

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143324736.png" alt="image-20200614143324736" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143324736.png" class="" title="This is image_b">

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143850915.png" alt="image-20200614143850915" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143850915.png" class="" title="This is image_c">

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614143916188.png" alt="image-20200614143916188" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614143916188.png" class="" title="This is image_d">

<h3 id="构造LR分析表的预备知识"><a href="#构造LR分析表的预备知识" class="headerlink" title="构造LR分析表的预备知识"></a>构造LR分析表的预备知识</h3><p><strong>ＬＲ文法</strong></p>
<ul>
<li>对于一个上下文无关文法, 如果能够构造一张 LR 分析表, 使得它的每一个入口均是唯一的（Sj,rj,acc,空白），则称该上下文无关是LR 文法．</li>
</ul>
<p><strong>活前缀</strong></p>
<ul>
<li>规范句型的前缀，若不含句柄以后的任何符号，则称它为该规范句型的活前缀。</li>
</ul>
<h2 id="7-2-LR（0）分析"><a href="#7-2-LR（0）分析" class="headerlink" title="7.2 LR（0）分析"></a>7.2 LR（0）分析</h2><p> <strong>LR(0)文法</strong></p>
<pre><code>能力最弱，理论上最重要</code></pre><ul>
<li>存在FA 识别活前缀</li>
<li>识别活前缀的DFA如何构造（LR(0)项目集规范族的构造）</li>
<li>LR(0)分析表的构造</li>
</ul>
<p><strong>活前缀</strong></p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614145819899.png" alt="image-20200614145819899" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614145819899.png" class="" title="This is image_e">

<p><strong>LR分析需要构造识别活前缀的有穷自动机</strong></p>
<p>​        我们可以把文法的终结符和非终结符都看成有穷自动机的输入符号，每次把一个符号进栈看成已识别过了该符号，同时状态进行转换，当识别到可归前缀时，相当于在栈中形成句柄，认为达到了识别句柄的终态。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0%5Cimage-20200614150627057.png" alt="f"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614150627057.png" class="" title="This is image_f">

<h3 id="构造识别文法活前缀DFA的三种方法"><a href="#构造识别文法活前缀DFA的三种方法" class="headerlink" title="构造识别文法活前缀DFA的三种方法"></a>构造识别文法活前缀DFA的三种方法</h3><ol>
<li>根据形式定义求出活前缀的正规表达式，然后由此正规表达式构造NFA再确定化为DFA</li>
<li>求出文法的所有项目，按一定规则构造识别活前缀的NFA再确定化为DFA</li>
<li><strong>使用闭包函数（CLOSURE）和转向函数(GOTO(I,X))构造文法G’的LR(0)的项目集规范族，再由转换函数建立状态之间的连接关系得到识别活前缀的DFA</strong></li>
</ol>
<h3 id="构造LR（0）项目集规范族"><a href="#构造LR（0）项目集规范族" class="headerlink" title="构造LR（0）项目集规范族"></a>构造LR（0）项目集规范族</h3><p>LR(0)项目集规范族(构成识别一个文法的活前缀的DFA的状态的全体) 。 </p>
<p>LR（0）项目或配置（ <em>item</em> or <em>configuration）</em>.</p>
<p>—在右端某一位置有圆点的G的产生式</p>
<p>   A → xyz   A → .xyz </p>
<p>​                    A → x.yz</p>
<p>​                    A → xy.z</p>
<p>​                    A → xyz.</p>
<h3 id="活前缀和句柄的关系"><a href="#活前缀和句柄的关系" class="headerlink" title="活前缀和句柄的关系"></a>活前缀和句柄的关系</h3><ol>
<li>活前缀已含有句柄的全部符号，表明产生式A→β的 右部β已出现在栈顶</li>
<li>活前缀只含句柄的一部分符号表明A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>活前缀不含有句柄的任何符号，此时期望A→β的右部所推出的符号串</li>
</ol>
<h3 id="活前缀-与句柄-与-LR-0-项目"><a href="#活前缀-与句柄-与-LR-0-项目" class="headerlink" title="活前缀,与句柄 ,与 LR(0)项目"></a>活前缀,与句柄 ,与 LR(0)项目</h3><p>​        为刻划这种分析过程中的文法G的每一个产生式的右部符号已有多大一部分被识别（出现在栈顶）的情况，分别用标有圆点的产生式来指示位置。</p>
<ul>
<li>A→β．刻划产生式A→β的 右部β已出现在栈顶</li>
<li>A→β1．β2 刻划A→β1β2的右部子串β1已出现在栈顶，期待从输入串中看到β2推出的符号</li>
<li>A→．β 刻划没有句柄的任何符号在栈顶，此时期望A→β的右部所推出的符号串</li>
<li>对于A→ε的LR(0)项目只有A→．</li>
</ul>
<p><strong>LR（0）项目</strong></p>
<p>根据圆点所在的位置和圆点后是终结符还是非终结符或为空把项目分为以下几种：</p>
<ul>
<li>移进项目，形如 A →a • ab  a是终结符, a ,b ∈V* 以下同</li>
<li>待约项目，形如 A →a • Bb</li>
<li>归约项目，形如 A →a • </li>
<li>接受项目，形如 S’ →S • </li>
</ul>
<p>A→ε的LR(0)项目只有A→ •  是归约项目</p>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：文法G:</span><br><span class="line">（0）S&#96;→E     (1) E→aA     (2) E→bB</span><br><span class="line"> (3) A→cA    (4) A→d      (5) B→cB</span><br><span class="line"> (7) B→d</span><br></pre></td></tr></table></figure>

<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153148449.png" alt="image-20200614153148449" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153148449.png" class="" title="This is image_g">

<h3 id="LR（0）分析表的构造"><a href="#LR（0）分析表的构造" class="headerlink" title="LR（0）分析表的构造"></a>LR（0）分析表的构造</h3><p>如果每个入口不含多重定义，则称它为文法G的一张LR(0)表。具有LR(0)表的文法G称为一个LR（0）文法。</p>
<p>LR(0)文法是无二义的。</p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614153440192.png" alt="image-20200614153440192" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614153440192.png" class="" title="This is image_h">

<p>若含有移进/归约冲突，则文法不是LR(0)的</p>
<h2 id="7-3-SLR（1）分析"><a href="#7-3-SLR（1）分析" class="headerlink" title="7.3 SLR（1）分析"></a>7.3 SLR（1）分析</h2><p>若 LR(0) 项目集规范族中有项目集IK含 移进/归约、 归约/归约冲突：</p>
<p>IK   :{ …A→ α .bβ , P ® α . ,   Q ® α .  , …}</p>
<p>存在“移进-归约”和“归约-归约”冲突。</p>
<p>解决冲突的方法是分析含P和Q的句型即考察FOLLOW(P)和FOLLOW(Q)</p>
<p><strong>则解决冲突的SLR(1)技术：</strong></p>
<p>当状态K面临当前输入符号a时：</p>
<ul>
<li>若a=b，则移进</li>
<li>对a ∈ FOLLOW (P) 则  action [ K,a ] =用 P → α  归约 </li>
<li>对a ∈ FOLLOW (Q) 则  action [ K,a ] =用 Q → α 归约</li>
<li>能用SLR(1)技术解决冲突的文法称为SLR(1)文法。</li>
</ul>
<p><strong>SLR(1)文法是无二义的。</strong></p>
<p>数字1的意思是，在分析过程中顶多只要向前看一个符号。</p>
<img src="编译原理（7）L-R分析程序及其自动构造\image-20200614154824752.png" alt="image-20200614154824752" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%887%EF%BC%89L-R%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%8F%8A%E5%85%B6%E8%87%AA%E5%8A%A8%E6%9E%84%E9%80%A0/image-20200614154824752.png" class="" title="This is image_i">














      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（6）自底向上的优先分析法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:34" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:34+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:55:29" itemprop="dateModified" datetime="2020-08-01T09:55:29+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="6-1-自底向上语法分析概述"><a href="#6-1-自底向上语法分析概述" class="headerlink" title="6.1 自底向上语法分析概述"></a>6.1 自底向上语法分析概述</h2><ul>
<li>自底向上语法分析试图将一个字符串归约至开始符号。</li>
<li>自下而上语法分析比自顶向下语法分析更有效率，对语法的限制更少</li>
<li>“移进-归约”：从输入字符串开始，逐步进行归约直到归约到文法的开始符号。</li>
</ul>
<img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613225725172.png" alt="image-20200613225725172" style="zoom:50%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225725172.png" class="" title="This is image_a">

<ul>
<li>归约过程恰好是最右推导（规范推导）的逆过程：</li>
</ul>
<img src="编译原理（6）自底向上的优先分析法\image-20200613225824198.png" alt="image-20200613225824198" style="zoom:60%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613225824198.png" class="" title="This is image_b">

<ul>
<li><p>规范归约定义：</p>
<p>假定α是文法G的一个句子，我们称序列αn, αn-1,… α0是α的一个规范归约。如果此序列满足：</p>
<p>​      1、 αn= α</p>
<p>​      2、 α0为开始符号。</p>
<pre><code>3、对任何 i, 0&lt;i&lt;=n, αi-1是从αi经把句柄替换为相应产生式的左部符号而得到的。</code></pre></li>
<li><p>规范归约也称最左归约，最右推导称为规范推导。规范推导得到的句型成为规范句型。</p>
</li>
<li><p>如果文法G无二义，则规范推导的逆过程一定是规范归约。</p>
</li>
</ul>
<h3 id="“移进—归约”法的栈实现"><a href="#“移进—归约”法的栈实现" class="headerlink" title="“移进—归约”法的栈实现"></a>“移进—归约”法的栈实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">自顶向下：初始：分析栈：#S    输入串:a1a2…an#</span><br><span class="line">        结束：      #            #（成功）</span><br><span class="line">   分析过程：用产生式的右部替换左部。</span><br><span class="line">   </span><br><span class="line">自底向上：初始：分析栈：#     输入串:a1a2…an#</span><br><span class="line">        结束：      #S           #（成功）</span><br><span class="line">   分析过程：自左至右把输入符号串W的符号一一移进栈里，一旦发现栈顶的一部分符号形成一个可归约串，就把栈中这个子串用相应的归约符号替换。</span><br><span class="line"></span><br><span class="line">四类操作：移进，归约，接受，出错处理。</span><br><span class="line">缺点</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>文法G[E]：<br> E → T + E | T</p>
<p>T → int * T | int | (E)</p>
<img src="F:\blog\source\_posts\编译原理（6）自底向上的优先分析法\image-20200613231423602.png" alt="image-20200613231423602" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613231423602.png" class="" title="This is image_c">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|int * int + int		移进</span><br><span class="line">int | * int + int	    移进</span><br><span class="line">int  * | int + int	    移进</span><br><span class="line">int * int | + int       规约 T→int</span><br><span class="line">int * T | + int			规约 T→int * T</span><br><span class="line">T | + int				移进</span><br><span class="line">T + | int				移进</span><br><span class="line">T + int | 				规约T → int</span><br><span class="line">T + T |					规约E → T</span><br><span class="line">T + E |					规约E → T + E</span><br><span class="line">E |</span><br></pre></td></tr></table></figure>

<h2 id="6-2-自底向上的优先分析算法"><a href="#6-2-自底向上的优先分析算法" class="headerlink" title="6.2 自底向上的优先分析算法"></a>6.2 自底向上的优先分析算法</h2><h3 id="6-2-1-简单优先分析法"><a href="#6-2-1-简单优先分析法" class="headerlink" title="6.2.1 简单优先分析法"></a>6.2.1 简单优先分析法</h3><ul>
<li>按照文法符号（包括终结符和非终结符）的优先关系确定句柄。</li>
<li>例：</li>
</ul>
<img src="编译原理（6）自底向上的优先分析法\image-20200613235831008.png" alt="image-20200613235831008" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200613235831008.png" class="" title="This is image_d">

<h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>•优先关系</p>
<p>​    –X=Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XY…</p>
<p>​    –X&lt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…XB…， </p>
<p>​                     且 B=+&gt; Y…</p>
<p>​    –X&gt;Y <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200613235957826.png" alt="image-20200613235957826" style="zoom:70%;" /> 文法G中存在产生式A<strong>→</strong>…BD…， </p>
<p>​                     且B =+&gt; …X,D =*&gt; Y…</p>
<p>•#的优先级&lt;所有符号，所有符号的优先级&gt;#，这里仅对与#相邻的文法符号而言。</p>
<h4 id="简单优先文法的定义"><a href="#简单优先文法的定义" class="headerlink" title="简单优先文法的定义"></a>简单优先文法的定义</h4><p>满足以下条件的文法是简单优先文法：</p>
<p>（1）在文法符号集V中，任意两个符号之间最多只有一种优先关系成立。（简单优先关系矩阵不含多重入口）</p>
<p>（2）在文法中任意两个产生式没有相同的右部。（例如：F–&gt;a ; B–&gt;a）</p>
<h4 id="简单优先分析法的算法步骤"><a href="#简单优先分析法的算法步骤" class="headerlink" title="简单优先分析法的算法步骤"></a>简单优先分析法的算法步骤</h4><ul>
<li>将输入符号串a1a2…an#依次逐个存入符号栈S中，直到遇到栈顶符号ai的优先性&gt;下一个待输入符号aj为止。</li>
<li>栈顶当前符号ai为句柄尾，由此向左在栈中找句柄的头符号ak，即找到ak-1&lt;ak为止。</li>
<li>由句柄ak…ai在文法的产生式中查找右部为ak…ai的产生式，若找到则用相应左部代替句柄，若找不到则为出错。</li>
<li>重复1，2，3步，直到栈中只剩开始符。</li>
</ul>
<h3 id="6-2-2-算符优先分析法"><a href="#6-2-2-算符优先分析法" class="headerlink" title="6.2.2 算符优先分析法"></a>6.2.2 算符优先分析法</h3><ul>
<li><p>某些文法具有“算符”特性</p>
<p>​        –表达式运算符（优先级、结合性）</p>
<p>​        –人为地规定其算符的优先顺序，即给出优先级别和同一级别的结合性</p>
</li>
<li><p>只考虑算符之间的优先关系</p>
</li>
</ul>
<p><img src="F:%5Cblog%5Csource_posts%5C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602175422247.png" alt="image-20200602175422247"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602175422247.png" class="" title="This is image_e">

<h4 id="如何确定算符优先关系"><a href="#如何确定算符优先关系" class="headerlink" title="如何确定算符优先关系"></a>如何确定算符优先关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（1）i的优先级最高</span><br><span class="line">（1）↑优先级次于i，右结合</span><br><span class="line">（2）*和&#x2F;优先级次之，左结合</span><br><span class="line">（3）+和-优先级最低，左结合</span><br><span class="line">（4）括号‘(’,‘)’的优先级大于括号外的运算符，小于括号内的运算符，内括号的优先性大于外括号</span><br><span class="line">（5）#的优先性低于与其相邻的算符</span><br></pre></td></tr></table></figure>

<h4 id="算符文法的定义"><a href="#算符文法的定义" class="headerlink" title="算符文法的定义"></a>算符文法的定义</h4><ul>
<li>定义  如果不含空产生式的上下文无关文法 G 中没有形如 U→…VW…的产生式，其中V,W∈VN则称G 为算符文法（OG）。</li>
<li>性质1：在算符文法中任何句型都不包含两个相邻的非终结符.(数学归纳法)</li>
<li>性质2：如 Vx 或 xV 出现在算符文法的句型 a 中，其中V∈VN,x∈VT, 则 a 中任何含 x 的短语必含有V.（反证法）（&lt;+&gt;归约，归约时把E带上&lt;E+E&gt;）</li>
</ul>
<h4 id="算符优先关系的定义"><a href="#算符优先关系的定义" class="headerlink" title="算符优先关系的定义"></a>算符优先关系的定义</h4><p>在OG中 定义 （算符优先关系）</p>
<ul>
<li><p>x = y    G中有形如.U→…xy…或U –&gt; …xVy…的产生式。    </p>
</li>
<li><p>x &lt; y     G中有形如.U →…xW…的产生式,而       W =+&gt; y….或W =+&gt; Vy…</p>
</li>
<li><p>x &gt; y     G中有形如.U → …Wy…的产生式,而        W =+&gt; …x或W =+&gt; … xV</p>
</li>
</ul>
<ul>
<li><p>规定 若 S =+&gt; x… 或  S =+&gt; Vx…  则  # &lt; x</p>
<p>​             S =+&gt; …x  或 S =+&gt; …xV  则  x &gt; #</p>
</li>
</ul>
<h4 id="算符优先文法的定义"><a href="#算符优先文法的定义" class="headerlink" title="算符优先文法的定义"></a>算符优先文法的定义</h4><ul>
<li><p>在 OG文法 G 中，若任意两个终结符间至多有一种算符优先关系存在，则称G 为算符优先文法(OPG)。</p>
<p><strong>–结论 算符优先文法是无二义的。</strong></p>
</li>
</ul>
<h4 id="算符优先关系表的构造"><a href="#算符优先关系表的构造" class="headerlink" title="算符优先关系表的构造"></a>算符优先关系表的构造</h4><ul>
<li>由定义直接构造</li>
<li>由关系图法构造算符优先关系表</li>
</ul>
<p><strong>FIRSTVT</strong> 和 <strong>LASTVT</strong></p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614112149299.png" alt="image-20200614112149299" style="zoom:40%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614112149299.png" class="" title="This is image_f">

<p><strong>如何计算算符优先关系</strong></p>
<p>（1） ‘=‘关系</p>
<p>​        –直接看产生式的右部，若出现了  A →…ab…或A →…aBb,则a=b</p>
<p>（2）’&lt;‘关系</p>
<p>​        –求出每个非终结符B的FIRSTVT(B)</p>
<p>​        –若A→…aB…,则”b∈FIRSTVT(B),a&lt;b</p>
<p>（3）’&gt;’关系</p>
<p>​        –求出每个非终结符B的LASTVT(B)</p>
<p>​        –若A→…Bb…,则”a∈LASTVT(B),a&gt;b</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">文法G[E]：(0) E’→#E#                         FIRSTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (1) E→E+T							FIRSTVT(E)&#x3D;&#123;+,*,↑,(,i&#125;</span><br><span class="line">		 (2) E→T							FIRSTVT(T)&#x3D;&#123;*,↑,(,i&#125;</span><br><span class="line">		 (3) T→T*F							FIRSTVT(F)&#x3D;&#123;↑,(,i&#125;</span><br><span class="line">		 (4) T→F							FIRSTVT(P)&#x3D;&#123;(,i&#125;</span><br><span class="line">		 (5) F→P↑F|P						LASTVT(E’)&#x3D;&#123;#&#125;</span><br><span class="line">		 (6) P→(E)							LASTVT(E)&#x3D;&#123;+,*,↑,),i&#125;   LASTVT(F)&#x3D;&#123;↑,),i&#125;</span><br><span class="line">		 (7) P→i							LASTVT(T)&#x3D;&#123;*,↑,),i&#125;     LASTVT(P)&#x3D;&#123;),i&#125;</span><br><span class="line"></span><br><span class="line">1)‘&#x3D;’关系</span><br><span class="line">	由产生式(0)和(6),得#&#x3D;#，（&#x3D;）</span><br><span class="line">2）‘&lt;’关系</span><br><span class="line">    找形如：A→…aB…的产生式</span><br><span class="line">    #E：则#&lt;FIRSTVT(E)</span><br><span class="line">    +T: 则+&lt;FIRSTVT(T)  </span><br><span class="line">    *F: 则*&lt;FIRSTVT(F)</span><br><span class="line">    ↑F: 则↑&lt;FIRSTVT(F)</span><br><span class="line">    (E: 则(&lt;FIRSTVT(E)</span><br><span class="line">3)‘&gt;’关系</span><br><span class="line">    找形如：A→…Bb…的产生式</span><br><span class="line">    E# ,则 LASTVT(E)&gt;#</span><br><span class="line">    E+ ,则 LASTVT(E)&gt;+ </span><br><span class="line">    T* ,则 LASTVT(T)&gt;* </span><br><span class="line">    P↑ ,则 LASTVT(P)&gt;↑ </span><br><span class="line">    E) ,则 LASTVT(E)&gt;)</span><br></pre></td></tr></table></figure>

<img src="编译原理（6）自底向上的优先分析法\image-20200614113542961.png" alt="image-20200614113542961" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614113542961.png" class="" title="This is image_g">

<h4 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h4><ul>
<li>归约过程中，只考虑终结符之间的优先关系来确定句柄，而与非终结符无关。这样去掉了对非终结符的归约，所以用算符优先分析法的规约过程与规范归约是不同的，P110.</li>
<li>为解决在算符优先分析过程中如何寻找可归约串，引进<strong>最左素短语</strong>的概念</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算符文法的任一句型有如下形式：</span><br><span class="line">	#N1a1N2a2......NnanNn+1#</span><br><span class="line">	若Niai......NjajNj+1为句柄，则有ai-1&lt;ai&#x3D;ai+1&#x3D;...&#x3D; aj-1 &#x3D; aj&gt; ai+1</span><br><span class="line"></span><br><span class="line">对于算符优先文法，如果aNb(或ab)出现在句型r中</span><br><span class="line">    若a&lt;b，则在r中必含有b而不含a的短语存在</span><br><span class="line">    若a&gt;b，则在r中必含有a而不含b的短语存在</span><br><span class="line">    若a&#x3D;b，则在r中含有a的短语必含有b，反之亦然</span><br></pre></td></tr></table></figure>

<p>定义  </p>
<p>cfg G 的句型的素短语是一个短语，它<strong>至少包含一个终结符</strong>，且除自身外<strong>不再包含其他素短语</strong>。处于句型最左边的素短语为<strong>最左素短语</strong>。</p>
<p>例如：</p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614114837340.png" alt="image-20200614114837340" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614114837340.png" class="" title="This is image_h">

<h4 id="优先函数"><a href="#优先函数" class="headerlink" title="优先函数"></a>优先函数</h4><ul>
<li>优先函数比优先矩阵节省空间</li>
<li>优先函数:从终结符号映射到整数的函数。</li>
<li>若a&lt;b,则f(a)&lt;g(b)</li>
<li>若a=b,则f(a)=g(b)</li>
<li>若a&gt;b,则f(a)&gt;g(b)</li>
</ul>
<p>例如：</p>
<img src="编译原理（6）自底向上的优先分析法\image-20200614115252192.png" alt="image-20200614115252192" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200614115252192.png" class="" title="This is image_i">

<p>​    f( * )&lt;g( i ) =&gt; *&lt;i，但f( i )&gt;g( i ) =&gt; i&gt;i是不存在的，所以错误检查能力损失。</p>
<p>​    可通过检查栈顶和输入符号a来发现那些不可比较的情形。</p>
<h4 id="构造优先函数"><a href="#构造优先函数" class="headerlink" title="构造优先函数"></a>构造优先函数</h4><p>（如果有环路则没有优先函数）</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95%5Cimage-20200602185248232.png" alt="j"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%886%EF%BC%89%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E7%9A%84%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/image-20200602185248232.png" class="" title="This is image_j">

<ol>
<li>设a是一个终结符或#，对每一个a建立两个符号fa和ga.</li>
<li>将所有fa和ga组成的集合分为若干组，办法是若a=b则fa和gb在同一组。</li>
<li>画图，结点是2建立的组。对任何a和b，若a&lt;b，则从gb所在的组画一箭弧到fa所在的组；若a&gt;b，则从fa 所在的组画一箭弧到gb所在的组.</li>
<li>若第3步构造的图中有环路，则没有优先函数。若没有环路，令f(a)是从fa 所在的组出发的沿箭弧前进的最长路径的长度。 g(a)是从ga 所在的组出发的沿箭弧前进的最长路径的长度。</li>
</ol>
<h4 id="算符优先分析法的局限性"><a href="#算符优先分析法的局限性" class="headerlink" title="算符优先分析法的局限性"></a>算符优先分析法的局限性</h4><p>很难避免把错误的句子得到正确的归约</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">编译原理（5）自顶向下语法分析方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:40:04" itemprop="dateCreated datePublished" datetime="2020-05-31T22:40:04+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:36:41" itemprop="dateModified" datetime="2020-08-01T09:36:41+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>句型的分析——分析算法分类：</p>
<p><strong>自上而下分析法：</strong></p>
<p> 从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<p><strong>自下而上分析法：</strong></p>
<p>从输入符号串开始，逐步进行归约（最右推导的逆过程），直至归约到文法的开始符号。</p>
<h2 id="5-1-自上而下语法分析的一般过程"><a href="#5-1-自上而下语法分析的一般过程" class="headerlink" title="5.1 自上而下语法分析的一般过程"></a>5.1 自上而下语法分析的一般过程</h2><p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的最左推导。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文法G：    S → cAd    A → ab |a                  </span><br><span class="line">识别输入串  w=cad</span><br><span class="line">试探：推导过程：S =&gt; cAd =&gt; cabd</span><br><span class="line">回溯:试探推导过程：S =&gt; cAd =&gt; cad</span><br></pre></td></tr></table></figure>

<h3 id="一、自上而下语法分析的问题"><a href="#一、自上而下语法分析的问题" class="headerlink" title="一、自上而下语法分析的问题"></a>一、自上而下语法分析的问题</h3><h4 id="5-1-1-左递归问题"><a href="#5-1-1-左递归问题" class="headerlink" title="5.1.1 左递归问题"></a>5.1.1 左递归问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义：一个文法是含有左递归的，如果存在非终结符P</span><br><span class="line">                            P &#x3D;&gt; Pα </span><br><span class="line">含有左递归的文法使上述的自上而下分析过程陷入无限循环。</span><br></pre></td></tr></table></figure>

<p>直接左递归 若 P –&gt; Pα | β     （α、β ∈V*且β不以P开头）</p>
<p>间接左递归 若 P =&gt; Pα           S –&gt; Aa     A–&gt;Sb      A–&gt;b</p>
<h4 id="5-1-2-消除左递归"><a href="#5-1-2-消除左递归" class="headerlink" title="5.1.2 消除左递归"></a>5.1.2 消除左递归</h4><p><strong>消除直接左递归：</strong></p>
<p>​        形如：P –&gt; Pα | β         （ α非ε， β不以P打头）</p>
<p>​        改写为：P –&gt; β P’         P’  –&gt;  α P’ | ε</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： E --&gt; E+T|T</span><br><span class="line"><span class="code">    T --&gt; T*F|F</span></span><br><span class="line"><span class="code">    F --&gt; (E)|i</span></span><br><span class="line">G[E]: (1)E --&gt; TE'  (2)E' --&gt; +TE'|ε  </span><br><span class="line"><span class="code">      (2)T --&gt; FT'  (4)T' --&gt; *FT'|ε </span></span><br><span class="line"><span class="code">      (5)F --&gt; (E)|i</span></span><br></pre></td></tr></table></figure>

<p>一般情况：</p>
<p>A –&gt; Aα1 | Aα2| …| Aαm|β1|β2|…|βn</p>
<p>消除左递归后：</p>
<p>A  –&gt;  β1A’|β2A’|…|βnA’</p>
<p>A’ –&gt;  α1A’ | α2A’| …|αmA’|ε</p>
<p><strong>消除间接左递归</strong></p>
<p>间接左递归定义：给定文法G(S) :<br>            S→Qc∣c        Q→Rb∣b          R→Sa∣a</p>
<p>虽然不存在直接左递归，但S、Q、R 都是左递归的，例如有  S⇒Qc⇒Rbc⇒Sabc </p>
<p>要求文法：1. 无回路（A=&gt;A）   2. 无空产生式（不含以ε为右部的产生式）</p>
<p>消除左递归的算法：</p>
<ol>
<li>把文法G的所有非终结符按任一种顺序排列P1, P2, P3…. Pn;</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">例：S--&gt;Ac|c  A--&gt;Bb|b   B--&gt;Sa|a</span><br><span class="line">（1）排序：B  A  S</span><br><span class="line">（2）将B代入A： A--&gt;Sab|ab|b</span><br><span class="line"><span class="code">    将A代入S： S--&gt;Sabc|abc|bc|c</span></span><br><span class="line"> 消除S的直接左递归，得到文法：</span><br><span class="line"><span class="code">    S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    A--&gt;Sab|ab|b</span></span><br><span class="line"><span class="code">    B--&gt;Sa|a</span></span><br><span class="line">（3）化简，最终得到结果：</span><br><span class="line"><span class="code">	S--&gt;abcS'|bcS'|cS'</span></span><br><span class="line"><span class="code">    S'--&gt;abcS'|ε</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line">（1）排序：S  A  B</span><br><span class="line">（2）将S代入A： A--&gt;Bb|b</span><br><span class="line"><span class="code">	将S、A代入B： B--&gt;Aca|ca|a</span></span><br><span class="line"><span class="code">	            B--&gt;Bbca|bca|ca|a</span></span><br><span class="line">消除B的直接左递归，得到文法：</span><br><span class="line"><span class="code">	S--&gt;Ac|c</span></span><br><span class="line"><span class="code">	A--&gt;Bb|b</span></span><br><span class="line"><span class="code">	B--&gt;bcaB'|caB'|aB'</span></span><br><span class="line"><span class="code">	B'--&gt;bcaB'|ε</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-回溯问题"><a href="#5-1-3-回溯问题" class="headerlink" title="5.1.3 回溯问题"></a>5.1.3 回溯问题</h4><p>定义：分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的。出错时，不得不“<strong>回溯</strong>”。</p>
<h4 id="5-1-4-提取左公因子"><a href="#5-1-4-提取左公因子" class="headerlink" title="5.1.4 提取左公因子"></a>5.1.4 提取左公因子</h4><p>提取左公因子：A →αβ1|αβ2</p>
<p>变为： A →αA’         A’ →β1 |β2</p>
<p>若A →αβ1|αβ2 |…|αβn|r</p>
<p>变为：A →αA’          A’ →β1|β2|…|βn</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：S → iEtS|iEtSeS|a      E→b</span><br><span class="line">提取左公因子： S -→ iEtSS’|a </span><br><span class="line"><span class="code">            S’-→ eS|ε</span></span><br><span class="line"><span class="code">            E -→ b</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-递归下降分析法"><a href="#5-2-递归下降分析法" class="headerlink" title="5.2 递归下降分析法"></a>5.2 递归下降分析法</h2><p>递归下降分析器：在消除了左递归和提取左公因子后，可以构造一个不带回溯的自上而下的分析程序。</p>
<p>这个程序由一组递归过程组成，每个过程对应文法的一个非终结符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">例：G[ E]:    </span><br><span class="line">   (<span class="number">1</span>)   E → TE’    (<span class="number">2</span>)  E’ → +TE’| ε</span><br><span class="line">   (<span class="number">3</span>)   T → FT’    (<span class="number">4</span>)  T’ → *FT’ |ε</span><br><span class="line">   (<span class="number">5</span>)   F → (E)|i</span><br><span class="line"></span><br><span class="line">Procedure E;</span><br><span class="line">     Begin</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T;</span><br><span class="line">     Begin</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br><span class="line">Procedure F;</span><br><span class="line">   IF sym=‘i’ then advance</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       IF sym=‘(’ then</span><br><span class="line">           Begin</span><br><span class="line">              advance;</span><br><span class="line">              E</span><br><span class="line">       IF sym=‘)’ then advance</span><br><span class="line">              <span class="keyword">else</span>  ERROR</span><br><span class="line">           End;</span><br><span class="line">    <span class="keyword">else</span> ERROR;</span><br><span class="line">Procedure E’;</span><br><span class="line">   IF sym=‘+’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         T;E’</span><br><span class="line">     End;</span><br><span class="line">Procedure T’;</span><br><span class="line">   IF sym=‘*’ then</span><br><span class="line">     Begin</span><br><span class="line">         advance;</span><br><span class="line">         F;T’</span><br><span class="line">     End;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-非递归的预测分析方法（LL-1-）"><a href="#5-3-非递归的预测分析方法（LL-1-）" class="headerlink" title="5.3 非递归的预测分析方法（LL(1)）"></a>5.3 非递归的预测分析方法（LL(1)）</h2><h3 id="一、总控程序"><a href="#一、总控程序" class="headerlink" title="一、总控程序"></a>一、总控程序</h3><img src="编译原理（5）自顶向下语法分析方法\image-20200601224211773.png" alt="image-20200601224211773" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%885%EF%BC%89%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/image-20200601224211773.png" class="" title="This is image_a">

<p>分析算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">   首先把‘#’，然后把文法开始符号推入栈；把第一个输入符号读进a;    FLAG：=TRUE；</span><br><span class="line">WHILE FLAG  DO      </span><br><span class="line">BEGIN</span><br><span class="line">   把栈顶符号上托出去并放在Ｘ中；</span><br><span class="line">   IF X ∈ Vt  </span><br><span class="line">   		THEN  </span><br><span class="line">       		IF X=a  </span><br><span class="line">       			THEN</span><br><span class="line">       				把下一个输入符号读进a</span><br><span class="line">　     	   ELSE ERROR      </span><br><span class="line">   ELSE  IF X=‘#’ </span><br><span class="line">   		THEN</span><br><span class="line">            IF X=a  </span><br><span class="line">       			 THEN  </span><br><span class="line">       				 FLAG:=FALSE</span><br><span class="line">            ELSE ERROR</span><br><span class="line">   ELSE IF M[X,a]=&#123;X-&gt;X1X2..XK&#125;</span><br><span class="line">          THEN   </span><br><span class="line">              把XK，X K<span class="number">-1</span>,..,X1一一推进栈 </span><br><span class="line">          ELSE　ERROR</span><br><span class="line">   END OF WHILE;</span><br><span class="line">STOP<span class="comment">/*分析成功，过程完毕*／</span></span><br><span class="line"><span class="comment">END</span></span><br></pre></td></tr></table></figure>

<h3 id="二、预测分析表M的构造"><a href="#二、预测分析表M的构造" class="headerlink" title="二、预测分析表M的构造"></a>二、预测分析表M的构造</h3><p>​                                                            ——LL（1）文法及其分析程序</p>
<p>FIRST集和FOLLOW集 </p>
<p>设G=(VT, VN, S, P)是上下文无关文法</p>
<p>FIRST（α）= {a|α =&gt; aβ, a∈VT, α, β∈V*}</p>
<p>FOLLOW（A）= {a|S =&gt;…Aa…, a ∈VT}</p>
<h4 id="5-3-1-first集"><a href="#5-3-1-first集" class="headerlink" title="5.3.1 first集"></a>5.3.1 first集</h4><p>（1）为什么要引入first集的概念？</p>
<ul>
<li>因为有公共左因子的问题，公共左公因子是指在文法的产生式集合中，某个非终结符的多个候选式具有相同的前缀。</li>
<li>一般来说，公共左公因子的产生式为 </li>
</ul>
<p>$$<br>A→αβ1│αβ2<br>$$</p>
<ul>
<li><p>如果有公共左因子的问题，那么只能采取试探的方法来分析每一个候选式，分析的过程很可能产生回溯，回溯分析法是一种不确定的方法。</p>
</li>
<li><p>若所有候选式都没有公共左因子就可以选择惟一匹配的候选式，不会产生(公共左公因子引起的)回溯。</p>
</li>
<li><p>为了消除回溯，对任何一个非终结符和当前的待匹配符号，期望 </p>
<p>​        要么只有一个候选式可用</p>
<p>​        要么没有候选式可用</p>
<p>因此引入以下FIRST集合的概念:</p>
</li>
<li><p>对α∈(VT⋃VN)∗,有<br>$$<br>FIRST(α)＝ { {a|α⟹a⋅⋅⋅,a∈VT} }<br>$$<br>特别地，若α⟹ε,  则ε∈FIRST(α)</p>
</li>
</ul>
<p>（2）推导算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对每一文法X∈V，计算first（X）：</span><br><span class="line">	①X∈Vt，则first（X）&#x3D;&#123;X&#125; </span><br><span class="line">    ②X∈Vn（非终结符），且有X-&gt;a , 则a∈first（X）</span><br><span class="line">    ③X∈Vn（非终结符），且有X-&gt;# , 若#∈first（X）</span><br><span class="line">    ④若有X，Y1,Y2,Y3...∈Vn，且有产生式X-&gt;Y1,Y2,Y3&#x3D;&gt;#,则first（Y1）-&#123;#&#125;，first（Y2）-&#123;#&#125;...first（Yi）都属于first（X）找中</span><br><span class="line">	重复②-④</span><br><span class="line">⑤当所有Yi&#x3D;&gt;#   则first（X）&#x3D; first（Y1）-&#123;#&#125; ∪ first（Y2）-&#123;#&#125;..... ∪ first（Yi）</span><br><span class="line">当有X-&gt;# ，才能说#∈first（X）</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-follow集"><a href="#5-3-2-follow集" class="headerlink" title="5.3.2 follow集"></a>5.3.2 follow集</h4><p>（1）为什么要引入follow集的概念？</p>
<p>​        当某一非终结符的产生式中含有空产生式时，它的非空产生式右部的开始符号集两两不相交，并与在推导过程中紧跟该非终结符右部可能出现的终结符集也不相交，则仍可构造确定的自顶向下分析。因此，引入了一个文法符号的<strong>后跟符号</strong>集合。 </p>
<p>（2）推导算法（PS：求follow集，都是从开始符号S开始推导）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">计算follow集:</span><br><span class="line">	①设S为起始，&#123;#&#125;加入follow（S）</span><br><span class="line">    ②要求follow（B），若A-&gt;aBb是一个产生式，则把first（b）的非空元素加入follow（B）中</span><br><span class="line">	③若b-&gt;#,则把follow（A）加入follow（B）中</span><br><span class="line">解释：因为若D-&gt;xAy,A-&gt;aBb, 则 D-&gt;xaBby,且b&#x3D;#，则first（y）或者说是follow(A)∈follow(B)</span><br><span class="line">就是所求符号的右边如果等于# 则不停找上一级</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-select集"><a href="#5-3-3-select集" class="headerlink" title="5.3.3 select集"></a>5.3.3 select集</h4><p>select(X-&gt;Y)，先求first（Y），如果first（Y）存在#∈first（Y）的情况，则再求follow（X），最后求两者的并集即可</p>
<p>例：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>是否</th>
<th>Frist集</th>
<th>Follow集</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ #,   ’,’ ,  )  }</td>
</tr>
<tr>
<td align="left">T</td>
<td>否</td>
<td>{ a, ^, ( }</td>
<td>{ ) }</td>
</tr>
<tr>
<td align="left">N</td>
<td>是</td>
<td>{ ‘,’  ,  # }</td>
<td>{ ) }</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Select(S-&gt;a) &#x3D;first（a）&#x3D; &#123;a&#125;</span><br><span class="line">Select(S-&gt;^) &#x3D;first（^）&#x3D;&#123;^&#125;</span><br><span class="line">Select(S-&gt;(T)) &#x3D;first（ （T）  ）&#x3D;&#123; ( &#125;</span><br><span class="line">Select(T-&gt;SN) &#x3D; first(S)&#x3D;&#123;a,^,(&#125;</span><br><span class="line">Select(N-&gt;,SN)&#x3D;first( , ) &#x3D;&#123; , &#125;</span><br><span class="line">Select(N-&gt;#) &#x3D;follow(N) &#x3D; &#123; ) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-4-预测分析表构造算法"><a href="#5-3-4-预测分析表构造算法" class="headerlink" title="5.3.4 预测分析表构造算法"></a>5.3.4 预测分析表构造算法</h4><p>1.对文法G的每个产生式Ａ→a执行第二步和第三步；</p>
<p>2.对每个终结符a∈FIRST(α)，把Ａ→α加至M[A,a]中，</p>
<p>3.若ε∈FIRST(α)，则对任何b∈FOLLOW(A)， 把Ａ→α加至M[A,b]中，</p>
<p>4.把所有无定义的M[A,a]标上“出错标志”。</p>
<h3 id="三、LL（1）文法"><a href="#三、LL（1）文法" class="headerlink" title="三、LL（1）文法"></a>三、LL（1）文法</h3><p>一个文法G，若它的分析表M不含多重定义入口，则称为LL（1）文法。</p>
<p>例：</p>
<p>文法S→iEtS|iEtSeS|a     E→b</p>
<p>不是LL（1）文法。</p>
<p>一个LL（1）文法是无二义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个文法G是LL（1）的，当且仅当对于G的每一个非终结符Ａ的任何两个不同产生式Ａ→α|β，下面的条件成立：</span><br><span class="line">1.FIRST（α）∩ FIRST(β) &#x3D; φ</span><br><span class="line">	也就是，α和β推导不出以同一个终结符a为首的符号串；它们不应该都能推出空字ε．</span><br><span class="line">2.假若β&#x3D;&gt;ε，那么FIRST（α) ∩ FOLLOW（A）＝ φ</span><br><span class="line">	也就是，若β&#x3D;&gt;ε.则α所能推出的串的首符号不应在FOLLOW(A）中．</span><br><span class="line">  结论：</span><br><span class="line">  		LL(1)文法是无二义的．</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">编译原理（4）词法分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:39:22" itemprop="dateCreated datePublished" datetime="2020-05-31T22:39:22+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:34:30" itemprop="dateModified" datetime="2020-08-01T09:34:30+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<p>词法分析程序亦称为扫描器。</p>
<p>扫描器的任务是识别基本的语法单位——单词；</p>
<p>扫描器的输出是语法分析程序的输入。</p>
<p><strong>词法分析程序的设计和实现</strong>：</p>
<p>首先需要描述和刻画语言中的原子单位——单词，其次需要识别单词和执行某些相关的动作。描述程序设计语言的词法的机制是3型文法和正则表达式，识别机制是有穷状态自动机。</p>
<h2 id="4-1-词法分析程序"><a href="#4-1-词法分析程序" class="headerlink" title="4.1 词法分析程序"></a>4.1 词法分析程序</h2><p><strong>词法分析（lexical analysis）</strong></p>
<p>–逐个读入源程序字符并按照构词规则切分成一系列单词。   </p>
<p>–单词是语言中具有独立意义的最小单位，包括保留字、标识符、运算符、标点符号和常量等。</p>
<p>–词法分析是编译过程中的一个阶段，在语法分析前进行 。也可以和语法分析结合在一起作为一遍，由语法分析程序调用词法分析程序来获得当前单词供语法分析使用。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" alt="a"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200612210637695.png" class="" title="This is image_a">

<ul>
<li><p>主要任务：</p>
<p>–读源程序，产生单词符号，并转换为token表示</p>
</li>
<li><p>其他任务：</p>
<p>–滤掉空格，删除注释、换行符</p>
<p>–对行列计数</p>
<p>–发现并定位词法错误，并尽量改正</p>
<p>–建立符号表、常数表等表格，……</p>
</li>
</ul>
<h3 id="4-1-1-词法分析器的输入缓冲区"><a href="#4-1-1-词法分析器的输入缓冲区" class="headerlink" title="4.1.1 词法分析器的输入缓冲区"></a>4.1.1 词法分析器的输入缓冲区</h3><h3 id="4-1-2-词法分析器的输出"><a href="#4-1-2-词法分析器的输出" class="headerlink" title="4.1.2 词法分析器的输出"></a>4.1.2 词法分析器的输出</h3><ul>
<li><p>单词符号一般可分为下列五种：</p>
<p>–基本字，关键字</p>
<p>–标识符</p>
<p>–常数（量）</p>
<p>–运算符</p>
<p>–界符</p>
</li>
<li><p>输出的二元式（token）表示：（单词种别，单词自身的值）</p>
</li>
<li><p>Token的种类：</p>
<p>​    1、有些单词，只需要值，如基本字；</p>
<p>​    2、有些单词，还需要其他信息，如标示符。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例： A:&#x3D;B+2                                                            </span><br><span class="line">(Id的整数码,指向A的符号表的入口指针）   ($28, Aaddr)       </span><br><span class="line">(运算符的整数码,’:&#x3D;’)                                                     </span><br><span class="line">(Id的整数码,指向B的符号表的入口指针)        </span><br><span class="line">(运算符的整数码,’+’)                                            </span><br><span class="line">(常数的整数码, 2)</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-以状态转换图为例设计词法分析器"><a href="#4-1-3-以状态转换图为例设计词法分析器" class="headerlink" title="4.1.3 以状态转换图为例设计词法分析器"></a>4.1.3 以状态转换图为例设计词法分析器</h3><img src="编译原理（4）词法分析/image-20200613110111799.png" alt="image-20200613110111799" style="zoom:60%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613110111799.png" class="" title="This is image_b">

<h2 id="4-2-正规表达式与正规集（正规语言）"><a href="#4-2-正规表达式与正规集（正规语言）" class="headerlink" title="4.2 正规表达式与正规集（正规语言）"></a>4.2 正规表达式与正规集（正规语言）</h2><ul>
<li><p>正规表达式（regular expression）是描述单词符号的一种方便工具，也是定义正规集的工具。</p>
</li>
<li><p>定义（正规式和它所表示的正规集）：</p>
<p>–设字母表为Σ，辅助字母表Σ`={Ф，ε，|，·，*，(，)}。</p>
<p>–1) ε和Ф都是Σ上的正规式，它们所表示的正规集分别为{ε}和{ }；</p>
<p>–2) 任何a∈Σ，a是Σ上的一个正规式，它所表示的正规集为{a}；</p>
<p>–3) 假定e1和e2都是Σ上的正规式，它们所表示的正规集分别为L(e1)和L(e2)，那么，(e1), e1| e2, e1·e2, e1* 也都是正规式，它们所表示的正规集分别为L(e1), L(e1)∪L(e2), L(e1)L(e2)和(L(e1))*。</p>
<p>–4) 仅由有限次使用上述三步骤而定义的表达式才是Σ上的正规式，仅由这些正规式所表示的字集才是Σ上的正规集。</p>
<img src="编译原理（4）词法分析/image-20200613112425500.png" alt="image-20200613112425500" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613112425500.png" class="" title="This is image_c">

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例1  令Σ&#x3D;&#123;a，b&#125;， Σ上的正规式和相应的正规集的例子有：</span><br><span class="line">    正规式			 正规集</span><br><span class="line">    a			   &#123;a&#125;</span><br><span class="line">    a|b			   &#123;a,b&#125;</span><br><span class="line">    ab			   &#123;ab&#125;</span><br><span class="line">    (a|b)(a|b)	   &#123;aa,ab,ba,bb&#125;</span><br><span class="line">    a* 			   &#123;ε,a,aa, ……任意个a的串&#125;</span><br><span class="line">    (a|b)*		   &#123;ε,a,b,aa,ab ……所有由a和b组成的串&#125;</span><br><span class="line">	(a|b)*(aa|bb)(a|b)*    &#123;Σ*上所有含有两个相继的a或两个相继的b组成的串&#125;</span><br><span class="line">	</span><br><span class="line">例3 Σ&#x3D;&#123;d，.，e，+，-&#125;,则Σ上的正规式 d*(.dd*|ε)(e(+|-|ε)dd*|ε )</span><br><span class="line">	表示的是无符号数的集合。其中d为0~9的数字。</span><br></pre></td></tr></table></figure>

<ul>
<li>若两个正规式e1和e2所表示的正规集相同,则说e1和e2等价,写作e1=e2。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如： e1&#x3D; (a|b)， e2 &#x3D; b|a</span><br><span class="line"></span><br><span class="line">又如： e1&#x3D; b(ab)* ,  e2 &#x3D;(ba)*b				</span><br><span class="line">	  e1&#x3D; (a|b)* ,  e2 &#x3D;(a*|b*)*</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设r,s,t为正规式，正规式服从的代数规律有：</p>
<p>–1、r|s=s|r                    “或”服从交换律</p>
<p>–2、r|(s|t)=(r|s)|t        “或”的可结合律</p>
<p>–3、(rs)t=r(st)                “连接”的可结合律</p>
<p>–4、r(s|t)=rs|rt      (s|t)r=sr|tr    分配律 </p>
<p>–5、εr=r, rε=r                 ε是“连接”的恒等元素 零一律</p>
<p>–6、 r|r=r    <strong>r* =ε|r+    r+=rr*</strong> </p>
</li>
<li><p>文法的定义</p>
<p>–G={VN,VT,P,S}</p>
<p>–VN：非终结符的非空有穷集</p>
<p>–VT：终结符的非空有穷集</p>
<p>–P： 产生式的非空有穷集</p>
<p>​         a→b  a∈( VN∪VT )* 且至少含一个非终结符， b∈( VN∪VT )*</p>
<p>–S：∈VN，称为开始符号</p>
</li>
<li><p>正规文法： G的任何产生式为A→aB或A→a，其中a∈VT ∪ ε ，A，B∈VN</p>
</li>
</ul>
<p><strong>对任意一个正规文法，存在一个定义同一个语言的正规式；反之亦然。</strong></p>
<p>Σ上的<strong>正规式=&gt;正规文法</strong></p>
<p>初始VT= Σ, S∈VN ，生成正规产生式(或定义式) :S→r （r为正规式）     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(R1) 对形如 A→r1r2的正规产生式： A→r1B           </span><br><span class="line">							 B→r2               </span><br><span class="line">							 B∈VN                   </span><br><span class="line">(R2)对形如A→r*r1的正规产生式：   A→rB          </span><br><span class="line">							 A→r1          </span><br><span class="line">							 B→rB          </span><br><span class="line">							 B→r1   B∈VN                                </span><br><span class="line">(R3)对形如A→r1|r2的正规产生式:  A→r1        </span><br><span class="line">							 A→r2</span><br></pre></td></tr></table></figure>

<p>不断应用R做变换，直到每个产生式右端只含一个VN</p>
<p><strong>正规文法=&gt;正规式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正规文法                      正规式</span><br><span class="line">A→xB, B→y      转换成： 	  A&#x3D;xy 			</span><br><span class="line">A→xA|y         转换成：       A&#x3D;x*y </span><br><span class="line">A→x|y          转换成：       A&#x3D;x|y</span><br></pre></td></tr></table></figure>

<h2 id="4-3-有穷自动机"><a href="#4-3-有穷自动机" class="headerlink" title="4.3 有穷自动机"></a>4.3 有穷自动机</h2><h3 id="4-3-1-确定的有穷自动机DFA"><a href="#4-3-1-确定的有穷自动机DFA" class="headerlink" title="4.3.1 确定的有穷自动机DFA"></a>4.3.1 确定的有穷自动机DFA</h3><p><strong>DFA定义：</strong></p>
<p>一个确定的有穷自动机（DFA）M是一个五元组：M=（K，Σ，f，S，Z）其中</p>
<p>​    1、K是一个有穷集，它的每个元素称为一个状态；</p>
<p>​    2、Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称Σ为输入符号字母表；</p>
<p>​    3、f是转换函数，是在K×Σ→K上的映射，即，如f（ki，a）=kj，（ki∈K，kj∈K）就意味着，当前状态为ki，输入符为a时，将转换为下一个状态kj，我们把kj称作ki的一个后继状态；</p>
<p>​    4、S∈K是唯一的一个初态；</p>
<p>​    5、Z 包含于 K是一个终态集，终态也称可接受状态或结束状态。</p>
<p><strong>DFA例：</strong></p>
<img src="编译原理（4）词法分析/image-20200613160754459.png" alt="image-20200613160754459" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160754459.png" class="" title="This is image_d">

<p><strong>DFA的状态转换图表示：</strong></p>
<img src="编译原理（4）词法分析\image-20200613160815782.png" alt="image-20200613160815782" style="zoom:75%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160815782.png" class="" title="This is image_e">

<p><strong>DFA</strong> <strong>的矩阵表示</strong></p>
<img src="编译原理（4）词法分析\image-20200613160908110.png" alt="image-20200613160908110" style="zoom:70%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613160908110.png" class="" title="This is image_f">

<p><strong>DFA M的作用：</strong></p>
<p> 对于∑*中的任何字符串t，若存在一条从初态结到某一终态结的道路，且这条路上所有弧的标记符连接成的字符串等于t，则称t可为DFA M所接受（识别）。若M的初态结同时又是终态结，则空字可为M所识别（接受）。</p>
<ul>
<li><p>∑*上的符号串t被M接受的形式叙述：</p>
<p>若t∈∑*，f (S，t)=P，其中S为 M的开始状态，P ∈ Z，Z为终态集。</p>
<p>则称t为DFA M所<strong>接受</strong>（<strong>识别</strong>）。</p>
</li>
<li><p>∑*上的符号串t在M上运行的定义：</p>
<p>一个输入符号串t，（我们将它表示成 t1tx的形式，其中t1 ∈∑，tx∈ ∑<em>）在DFA M上*</em>运行**的定义为：</p>
<p>f（Q， t1 tx ）=f（f（Q， t1 ），tx） 其中Q∈K                         </p>
</li>
</ul>
<p>例：证明t=baab被前例中的DFA所接受</p>
<img src="编译原理（4）词法分析\image-20200613183717517.png" alt="image-20200613183717517" style="zoom:55%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613183717517.png" class="" title="This is image_g">

<p>所识别的语言：含有相继两个a或相继两个b的串。</p>
<p>DFA M所能接受的符号串的全体记为 L(M)(语言)</p>
<p><strong>结论：</strong></p>
<p>– Σ上一个符号串集V 包含于 Σ*是正规的，当且仅当存在一个Σ上的确定有穷自动机M，使得V=L(M)。</p>
<h3 id="4-3-2-不确定的有穷自动机NFA"><a href="#4-3-2-不确定的有穷自动机NFA" class="headerlink" title="4.3.2 不确定的有穷自动机NFA"></a>4.3.2 不确定的有穷自动机NFA</h3><p>NFA定义：</p>
<p>N={K，Σ，f，S，Z}，其中K为状态的有穷非空集，Σ为有穷输入字母表，f为Kx Σ*到K的子集（2^K）的一种映射，S 包含于 K是初始状态集，Z 包含于 K为终止状态集。</p>
<ul>
<li><p>例子</p>
<p>NFA N=（{S，P，Z}，{0，1}，f，{S，P}，{Z}）</p>
<p>其中 f（S，0）={P}</p>
<p>​        f（S，1）={S，Z}</p>
<p>​        f（P，1）={Z}</p>
<p>​        f（Z，0）={P}</p>
<p>​        f（Z，1）={P}</p>
<p>状态图表示：</p>
</li>
</ul>
<img src="编译原理（4）词法分析\image-20200613184408840.png" alt="image-20200613184408840" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613184408840.png" class="" title="This is image_h">

<ul>
<li>∑*上的符号串t在NFA N上运行</li>
<li>∑*上的符号串t被NFA N接受</li>
<li>具有ε转移的不确定的有穷自动机NFA… f为 K x（Σ ∪{ε}）到K的子集（2^K）的一种映射</li>
<li>对任何一个具有ε转移的不确定的有穷自动机NFA　N，一定存在一个不具有ε转移的不确定的有穷自动机NFA　Ｍ ，使得L(M)=L(N)。</li>
</ul>
<h3 id="4-3-3-NFA的确定化"><a href="#4-3-3-NFA的确定化" class="headerlink" title="4.3.3 NFA的确定化"></a>4.3.3 NFA的确定化</h3><p>DFA是NFA的特例。对每个NFA N一定存在一个DFA M ，使得L(M)=L(N)。对每个NFA N存在着与之等价的DFA M。与某一NFA等价的DFA不唯一。</p>
<p><strong>定义对状态集合I的几个有关运算：</strong></p>
<ol>
<li>状态集合 I 的 ε- 闭包，表示为 ε-closure(I)，定义为一状态集，是状态集 I 中的任何状态S经任意条ε弧而能到达的状态的集合。状态集合 I 的任何状态S都属于 ε-closure(I)。</li>
<li>状态集合 I 的a弧转换，表示为 move(I,a) 定义为状态集合 J，其中 J 是所有那些可从 I 的某一状态经过一条a弧而到达的状态的全体。定义 Ia = ε-closure(J)</li>
</ol>
<p>例：</p>
<img src="编译原理（4）词法分析\image-20200613190857433.png" alt="image-20200613190857433" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190857433.png" class="" title="This is image_i">

<img src="编译原理（4）词法分析\image-20200613190905154.png" alt="image-20200613190905154" style="zoom:90%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613190905154.png" class="" title="This is image_j">

<p>假设NFA N=(K, Σ, f, K0, Kt)按如下办法构造一个DFA M=(S, Σ, d, S0, St)，使得L(M)=L(N)：</p>
<ol>
<li><p>M的状态集S由K的一些子集组成。用[S1 S2… Sj ]表示S的元素，其中S1, S2,,… Sj是K的状态。并且约定，状态S1, S2,… Sj 是按某种规则排列的，即对于子集{S1, S2}={ S2, S1,}来说，S的状态就是[S1 S2]；</p>
</li>
<li><p>M和N的输入字母表是相同的，即是 Σ ；</p>
</li>
<li><p>转换函数是这样定义的：                    </p>
<p> d([S1 S2,… Sj],a)= [R1R2… Rt]  其中   {R1,R2,… , Rt} = ε-closure(move({S1, S2,,… Sj},a)) </p>
</li>
<li><p>S0=ε-closure(K0)为M的开始状态；</p>
</li>
<li><p>St={[Si Sk… Se]，其中[Si  Sk… Se]∈S且{Si , Sk,,… Se}∩Kt≠Φ}</p>
</li>
</ol>
<p><strong>NFA确定化例子：</strong></p>
<img src="编译原理（4）词法分析\image-20200613192154391.png" alt="image-20200613192154391" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192154391.png" class="" title="This is image_k">

<img src="编译原理（4）词法分析\image-20200613192229903.png" alt="image-20200613192229903" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613192229903.png" class="" title="This is image_l">

<img src="编译原理（4）词法分析\image-20200613205712090.png" alt="image-20200613205712090" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613205712090.png" class="" title="This is image_m">

<h2 id="4-4-有穷自动机和正规表达式"><a href="#4-4-有穷自动机和正规表达式" class="headerlink" title="4.4 有穷自动机和正规表达式"></a>4.4 有穷自动机和正规表达式</h2><p><strong>有穷自动机和正规表达式的等价性：</strong>   </p>
<ul>
<li>对于∑上的一个NFA M，可以构造一个∑上的正规式R,使得L(R)=L(M)。</li>
<li>对于∑上的一个正规式R，可以构造一个∑上的NFA M，使的L(M)=L(R)。</li>
</ul>
<p><strong>正规式 =&gt;有穷自动机</strong></p>
<p>设给定正规式W，则构造相应自动机的方法如下：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" alt="n"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801092900.png" class="" title="This is image_n">

<p>然后利用以下规则加入结点和箭弧，直到得到自动机为止。</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" alt="o"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image_20200801093105.png" class="" title="This is image_o">

<p><strong>有穷自动机=&gt;正规式</strong></p>
<p>首先检查是否只有一个终态结点，若有多个，则引入新结点T，从所有终态结点引ε边到T结点，并令T为唯一的终态结点。</p>
<p>然后按以下规则消除结点与箭弧：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" alt="p"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%884%EF%BC%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/image-20200613223618156.png" class="" title="This is image_p">

<h2 id="4-5-有穷自动机和正规文法"><a href="#4-5-有穷自动机和正规文法" class="headerlink" title="4.5 有穷自动机和正规文法"></a>4.5 有穷自动机和正规文法</h2><p><strong>有穷自动机和正规文法的等价性：</strong>     </p>
<ul>
<li>对于一个NFA M，都存在 一个正规文法G，使得L(G)=L(M).               </li>
<li>对于一个正规文法G,都存在一个NFA M，使得L(M)=L(G). </li>
</ul>
<p><strong>正规文法=&gt;自动机</strong></p>
<ul>
<li>字母表与G的终结符集相同；</li>
<li>G中的非终结符对应状态，开始符对应开始状态</li>
<li>增加一个新的终结状态Z。</li>
<li>G中的A-&gt;tB构造转换函数f(A,t)=B</li>
<li>G中的A-&gt;t构造转换函数f(A,t)=Z</li>
</ul>
<p><strong>自动机=&gt;正规文法</strong></p>
<ul>
<li>对转换函数f(A,t)=B，对应产生式：   A-&gt;tB</li>
<li>对终态Z，增加一产生式： Z-&gt;ε</li>
<li>NFA的初态对应文法的开始符号；</li>
<li>NFA的字母表对应文法的终结符号集。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编译原理（2）文法和语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 22:38:54" itemprop="dateCreated datePublished" datetime="2020-05-31T22:38:54+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:04:12" itemprop="dateModified" datetime="2020-08-01T09:04:12+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="2-1-符号、符号串及其集合的运算"><a href="#2-1-符号、符号串及其集合的运算" class="headerlink" title="2.1 符号、符号串及其集合的运算"></a>2.1 符号、符号串及其集合的运算</h2><p>任何一种语言都是由该语言的基本符号组成的符号串的集合。</p>
<ul>
<li>​    基本符号集</li>
<li>​    任何语言的单词符号就是定义在它的字符集上的字符串</li>
<li>​    该语言的任何语句就是定义在其单词符号集上的单词串(符号串)</li>
</ul>
<h3 id="2-1-1-字母表和符号串"><a href="#2-1-1-字母表和符号串" class="headerlink" title="2.1.1 字母表和符号串"></a>2.1.1 字母表和符号串</h3><p>字母表：是元素的非空有穷集合，把字母表中的元素称为符号，因此字母表也称符号集。</p>
<p>符号串：字母表中的符号串组成的任何有穷序列。</p>
<h3 id="2-1-2-符号串及其集合的运算"><a href="#2-1-2-符号串及其集合的运算" class="headerlink" title="2.1.2 符号串及其集合的运算"></a>2.1.2 符号串及其集合的运算</h3><p>① 符号串的长度：如果某符号串x中有m个符号，则其长度为m，记为|x|=m。例</p>
<p>② 符号串的联接：设x和y是符号串，它们的联接xy是把y的符号写在x的符号之后得到的符号串。</p>
<p>③ 符号串的方幂：设x是符号串，把x自身连接n次得到符号串z，即z=xxx….xx，称为符号串x的方幂。</p>
<p>④ 符号串集合：若集合A中的一切元素都是某字母表上的符号串，则称A为字母表上的符号串集合。</p>
<ul>
<li>语言：表示某个确定的字母表上的符号串的任何集合。</li>
</ul>
<p>⑤ 集合的乘积：AB={xy|x∈A且y∈B}。</p>
<p>⑥ 集合A的闭包A*和正闭包A+：</p>
<img src="编译原理（2）文法和语言/a.png" alt="a" style="zoom:80%;" />

<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%882%EF%BC%89%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E8%A8%80/a.png" class="" title="This is image_a">

<h2 id="2-2-文法的直观概念"><a href="#2-2-文法的直观概念" class="headerlink" title="2.2 文法的直观概念"></a>2.2 文法的直观概念</h2><p>文法的定义∶对语言结构的描述和定义，即在形式上用来描述和规定语言结构的称为“文法”(或“语法”)。</p>
<p><strong>规则</strong></p>
<p>​    句子的语法结构，可以用一组规则来描述。</p>
<p>​    规则也称为“产生式”，规则中的“∷=”也常用“→”表示。</p>
<p>​    注意∶文法中，描述某个特定的语法成分的规则可能不只一条。</p>
<p><strong>由规则推导句子</strong></p>
<p>如果用一组规则来描述句子的结构，就可以利用这组规则按照一定的方式去推导产生句子。</p>
<p>推导方法∶使用一条规则，代替=&gt;左边的某个符号，产生=&gt;右端的符号串</p>
<h2 id="2-3-文法和语言的形式定义"><a href="#2-3-文法和语言的形式定义" class="headerlink" title="2.3 文法和语言的形式定义"></a>2.3 文法和语言的形式定义</h2><h3 id="2-3-1-文法的形式定义"><a href="#2-3-1-文法的形式定义" class="headerlink" title="2.3.1 文法的形式定义"></a>2.3.1 文法的形式定义</h3><p>① 规则、产生式(或重写规则)∶形如α→β或α∷=β的（α，β）有序对，且α∈V+，β∈V* ， V为某字母表。</p>
<ul>
<li>α称为规则的左部(或产生式的左部)。</li>
<li>β称为规则的右部(或产生式的右部)。</li>
</ul>
<p>②文法的定义</p>
<p>（1）文法G定义为四元组（VN，VT，P，S）</p>
<p>​        –VN：非终结符集</p>
<p>​        –VT ：终结符集</p>
<p>​        –P：产生式（规则）集合</p>
<p>​        –S：开始符号</p>
<p>​    VN ∩ VT = φ，S∈VN</p>
<p>​    V=VN∪VT，称为文法G的文法符号集合</p>
<p>（2）习惯上只将产生式写出。并有如下约定：</p>
<p>​        –第一条产生式的左部是开始符号</p>
<p>​        –用尖括号括起的是非终结符，否则为终结符。或者大写字母表示非终结符，小写字母表示终结符</p>
<p>​        –G可写成G[S]，S是开始符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G：S→aAb      A→ab    A→aAb    A→ε </span><br><span class="line">G[S]： A→ab    A→aAb    A→ε  S→aSb </span><br><span class="line">缩写形式 G[S]：A→ab|aAb|ε      S→aSb</span><br><span class="line">注意：元符号“|”读作“或”</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-推导的形式定义"><a href="#2-3-2-推导的形式定义" class="headerlink" title="2.3.2 推导的形式定义"></a>2.3.2 推导的形式定义</h3><p>直接推导“=&gt;”</p>
<p>​         α→β是文法G的产生式，若有v,w满足：</p>
<p>​         v=γ α δ, w= γ β δ, 其中 γ∈V* , δ∈V*</p>
<pre><code> 则称v直接推导出w, 记作 v =&gt; w

或w直接归约到v</code></pre><p>若存在v=&gt;w0=&gt;w1 =&gt;… =&gt;wn=w, (n&gt;0)，则称v  <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" /> w，v推导出w，或w归约到v。</p>
<p>若有v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608220954013.png" alt="image-20200608220954013" style="zoom:50%;" />  w，或v=w，则记为v <img src="C:\Users\KinKi Kids\AppData\Roaming\Typora\typora-user-images\image-20200608221128579.png" alt="image-20200608221128579" style="zoom:50%;" />  w</p>
<p><strong>句型</strong></p>
<p>​    – 有文法G，若S =*&gt;  x，则称x是文法G的句型。</p>
<p>​    一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。</p>
<p><strong>句子</strong></p>
<p>​    – 有文法G，若S =+&gt; x，且x∈VT*，则称x是文法G的句子。</p>
<p>​    句子是不包含非终结符的句型。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如：有下列文法：</span><br><span class="line">　　S→AB</span><br><span class="line">　　A→aA|a</span><br><span class="line">　　B→bB|b</span><br><span class="line">用上述文法推导字符串aaabbb过程如下：</span><br><span class="line">　　S→AB→aAB→aaAB→aaaB→aaabB→aaabbB→aaabbb</span><br><span class="line">AB、aAB、aaAB、aaaB、aaabB、aaabbB和aaabbb都是上述文法的一个句型</span><br><span class="line">只有终结符的句型为句子。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T          </span><br><span class="line">	T→T*F|F          </span><br><span class="line">	F→(E)|a</span><br><span class="line">E&#x3D;&gt;E+T&#x3D;&gt;T+T&#x3D;&gt;F+T&#x3D;&gt;a+T&#x3D;&gt;a+T*F&#x3D;&gt;a+F*F&#x3D;&gt;a+a*F&#x3D;&gt;a+a*a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-语言的形式定义"><a href="#2-3-3-语言的形式定义" class="headerlink" title="2.3.3 语言的形式定义"></a>2.3.3 语言的形式定义</h3><p>由文法G生成的语言记为L(G),它是文法G的一切句子的集合:                    </p>
<p>​        L(G)={x|S =+&gt; x，其中S为文法的开始符号，且x ∈VT*}</p>
<p><strong>文法的等价</strong></p>
<p>若L（G1）=L（G2），则称文法G1和G2是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如文法G1[A]：A→0R    与   G2[S]：S→0S1 等价</span><br><span class="line">           A→01                S→01</span><br><span class="line">           R→A1</span><br></pre></td></tr></table></figure>

<p>练习：已知语言描述，写出文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：若语言由0、1符号串组成，串中0和1的个数相同，构造其文法。</span><br><span class="line"> A → 0B|1C</span><br><span class="line"> B → 1|1A|0BB</span><br><span class="line"> C → 0|0A|1CC</span><br></pre></td></tr></table></figure>

<p>练习：已知文法，写出语言描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：G[E]：E→E+T|T</span><br><span class="line">         T→T*F|F</span><br><span class="line">         F→(E)|a</span><br><span class="line">表示一切能用符号a，+，*，(和)构成的算术表达式</span><br></pre></td></tr></table></figure>

<h2 id="2-4-文法的类型"><a href="#2-4-文法的类型" class="headerlink" title="2.4 文法的类型"></a>2.4 文法的类型</h2><p><strong>Chomsky</strong> <strong>将文法分为四种类型：</strong></p>
<p>（1）0型文法（短语文法）：G=(VN,VT,P,S)对任一产生式α→β，都有α∈(VN∪VT) *，且至少含有一个非终结符， β∈(VN∪VT) *</p>
<p>（2）1型文法（上下文有关文法）：对任一产生式α→β，都有|β|≥|α|， 仅仅 S→ε除外，1型文法也可描述为α1Aα2→α1βα2</p>
<p>（3）2型文法（上下文无关文法）：对任一产生式α→β，都有α∈VN ， β∈(VN∪VT)*</p>
<p>（4）3型文法（正规文法）：任一产生式α→β的形式都为A→aB或A→a，其中A∈VN，B∈VN，a∈VT</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1型（上下文有关）文法：</span><br><span class="line">   文法G[S]：	 S→CD		Ab→bA</span><br><span class="line">			   C→aCA	  Ba→aB</span><br><span class="line">			   C→bCB	  Bb→bB</span><br><span class="line">			   AD→aD	  C→ε</span><br><span class="line">			   BD→bD	  D→ε</span><br><span class="line">			   Aa→bD</span><br><span class="line">L(G)&#x3D;&#123;w|w∈&#123;a,b&#125;*&#125;</span><br><span class="line"></span><br><span class="line">2型（上下文无关）文法：</span><br><span class="line">   文法G[S]：	S→aB|bA</span><br><span class="line">			  A→a|aS|bAA</span><br><span class="line">			  B→b|bS|aBB</span><br><span class="line">   文法G[S]：	S→0A|1B|0</span><br><span class="line">			  A→0A|1B|0S</span><br><span class="line">			  B→1B|1|0</span><br><span class="line"></span><br><span class="line">定义标识符的3型（正规）文法：</span><br><span class="line">   文法G[I]：	I → iT</span><br><span class="line">			 I → i</span><br><span class="line">			 T → iT</span><br><span class="line">			 T → dT</span><br><span class="line">			 T → i</span><br><span class="line">             T → d</span><br></pre></td></tr></table></figure>

<p><strong>文法和语言</strong></p>
<p>0型文法产生的语言称为0型语言</p>
<p>1型文法或上下文有关文法（ CSG ）产生的语言称为1型语言或上下文有关语言（CSL）</p>
<p>2型文法或上下文无关文法（ CFG ）产生的语言称为2型语言或上下文无关语言（ CF L ） </p>
<p>3型文法或正则（正规）文法（ RG ）产生的语言称为3型语言正则（正规）语言（ RL ）</p>
<p><strong>文法和识别系统</strong></p>
<p>0型文法（短语文法）的能力相当于图灵机，可以表征任何递归可枚举集，而且任何0型语言都是递归可枚举的</p>
<p>1型文法（上下文有关文法）：产生式的形式为α1Aα2→α1βα2，即只有A出现在α1和α2的上下文中时，才允许β取代A。其识别系统是线性界限自动机。</p>
<p>2型文法（上下文无关文法、CFG）：产生式的形式为A→β，β取代A时与A的上下文无关。其识别系统是不确定的下推自动机。</p>
<p>3型文法（正规文法、右线性文法）：产生的语言是有穷自动机（FA）所接受的集合</p>
<h2 id="2-5-上下文无关文法及其语法树"><a href="#2-5-上下文无关文法及其语法树" class="headerlink" title="2.5 上下文无关文法及其语法树"></a>2.5 上下文无关文法及其语法树</h2><h3 id="2-5-1-上下文无关文法的语法树"><a href="#2-5-1-上下文无关文法的语法树" class="headerlink" title="2.5.1 上下文无关文法的语法树"></a>2.5.1 上下文无关文法的语法树</h3><p>用于描述上下文无关文法的句型推导的直观方法</p>
<p>叶子结点：树中没有子孙的结点。</p>
<p>从左到右读出推导树的叶子标记，所得的句型为推导树的结果。也把该推导树称为该句型的语法树。</p>
<p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定文法G，对于G的任何句型都能构造与之关联的语法树（推导树）。这棵树满足下列4个条件：</span><br><span class="line">1、每个结点都有一个V中的符号作标记</span><br><span class="line">2、根的标记是开始符号S</span><br><span class="line">3、若一结点n至少有一个它自己除外的子孙，并且n有标记A，则A∈VN</span><br><span class="line">4、如果结点n的直接子孙，从左到右的次序是结点n1,n2,…,nk，其标记分别为A1,A2,…,Ak，那么A→A1A2,…,Ak一定是P中的一个产生式</span><br></pre></td></tr></table></figure>

<p>推导过程中使用产生式的顺序：</p>
<ul>
<li>最左（最右）推导：在推导的任何一步α=&gt;β，其中α、β是句型，都是对α中的最左（右）非终结符进行替换</li>
<li><strong>最右推导被称为规范推导</strong>。 <strong>最左归约–&gt;规范规约</strong></li>
<li>由规范推导所得的句型称为规范句型</li>
</ul>
<h3 id="2-5-2-二义性"><a href="#2-5-2-二义性" class="headerlink" title="2.5.2 二义性"></a>2.5.2 二义性</h3><p><strong>二义文法</strong></p>
<p>若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是<em>二义</em> 的。</p>
<p>或者，若一个文法存在某个句子有两个不同的最左（右）推导，则称这个文法是<em>二义</em> 的。</p>
<p>产生某上下文无关语言的每一个文法都是二义的，则称此语言是<em>先天二义</em>的。</p>
<p>二义文法改造为无二义文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G[E]: E → i         G[E]：E → T|E+T</span><br><span class="line">	  E → E+E             T → F|T*F</span><br><span class="line">	  E → E*E             F →（E）|i</span><br><span class="line">	  E → (E)       规定优先顺序和结合律</span><br></pre></td></tr></table></figure>

<h2 id="2-6-句型的分析"><a href="#2-6-句型的分析" class="headerlink" title="2.6 句型的分析"></a>2.6 句型的分析</h2><p><strong>句型分析</strong> 就是识别一个符号串是否为某文法的句型，是某个推导的构造过程。</p>
<p>在语言的编译实现中，把完成句型分析的程序称为<em>分析程序</em> 或<em>识别程序</em>。分析算法又称<em>识别算法</em>。</p>
<p><em>从左到右的分析算法</em> ，即总是从左到右地识别输入符号串，首先识别符号串中的最左符号，进而依次识别右边的一个符号。</p>
<p><strong>分析算法可分为：</strong></p>
<p><strong><em>自上而下分析法</em>：</strong> </p>
<p>从文法的开始符号出发，反复使用各种产生式，寻找与输入符号匹配的推导。</p>
<p><strong><em>自下而上分析法</em>：</strong></p>
<p> 从输入符号串开始，逐步进行归约，直至归约到文法的开始符号。</p>
<p>两种方法反映了两种不同的语法树的构造过程</p>
<p><strong>句型分析的有关问题</strong></p>
<p>1）如何选择使用哪个产生式进行推导？</p>
<p>2）如何识别可归约的串？</p>
<p><strong>句型分析</strong></p>
<p>短语、直接短语、句柄的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒+ γ，则称γ是句型αγβ的相对于非终结符A的&#96;短语&#96; 。</span><br><span class="line">如果 S⇒* αAβ 且 A ⇒ γ，则称γ是句型αγβ的相对于规则A→γ的&#96;直接(简单)短语&#96;。</span><br><span class="line">直接短语中的最左直接短语为该句型的句柄。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">短语：</span><br><span class="line">一个句型的分析树中的每一棵子树的边缘(所有叶节点)所组成的符号串称为该句型的一个短语(phrase)。 </span><br><span class="line">直接短语：</span><br><span class="line">如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语(immediate phrase)；</span><br><span class="line">所有子树中，深度为2的子树的叶子节点串就是直接短语（因为直接短语必须是由子树根节点用一步推出来的，所以深度为2）；</span><br><span class="line">即如果子树中不再包含其他的子树，即A只能推导出b，而b不能再推出其他的式子，则b为此句型的直接短语。</span><br><span class="line"></span><br><span class="line">句柄：</span><br><span class="line">“可规约串”，句柄对应某个产生式的右部，是某个，但不是任意一个。</span><br><span class="line">作为一种规约对象，句柄表示最左直接短语。</span><br><span class="line">语法树： 在语法树上，则表示为最左边的只包含相邻父子节点的短语（最左直接短语）</span><br></pre></td></tr></table></figure>

<p>素短语和最左素短语</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">素短语：</span><br><span class="line">是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">最左素短语就是句型最左边的素短语，是算符优先分析法的规约对象。</span><br><span class="line">语法树：通过语法树分析时，要注意先判断是否为素短语，再找相对最左端的素短语。</span><br><span class="line"></span><br><span class="line">理解：</span><br><span class="line">素短语 ：</span><br><span class="line">指一个短语至少包含一个终结符，并且除它自身之外不再包含其他素短语。</span><br><span class="line">从短语集合中找出所有含有终结符的短语，然后选出除它自身之外不再含更小的素短语。</span><br><span class="line">（这个小的概念是集合中没有被包含的元素，如有两个短语aAA和aAAA，aAA含于aAAA，所以aAA比aAAA小）</span><br><span class="line"></span><br><span class="line">最左素短语：</span><br><span class="line">从素短语集合中找出最左边的素短语。</span><br></pre></td></tr></table></figure>

<h2 id="2-7文法实用中的一些说明"><a href="#2-7文法实用中的一些说明" class="headerlink" title="2.7文法实用中的一些说明"></a>2.7文法实用中的一些说明</h2><h3 id="2-7-1-有关文法的实用限制"><a href="#2-7-1-有关文法的实用限制" class="headerlink" title="2.7.1 有关文法的实用限制"></a>2.7.1 有关文法的实用限制</h3><p>文法中不得含有<em>有害规则</em> 和<em>多余规则</em></p>
<ul>
<li><p>有害规则：形如U→U的产生式。会引起文法的二义性</p>
</li>
<li><p>多余规则：指文法中任何句子的推导都不会用到的规则</p>
<p>1）文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达</p>
<p>2）文法中某些非终结符，由它不能推出终结符号串来，称为不可终止的</p>
</li>
</ul>
<p>对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件：</p>
<p>​        1）A必须在某句型中出现。</p>
<p>​        2）必须能从A推出终结符号串t来。</p>
<h3 id="2-7-2-上下文无关文法中的ε规则"><a href="#2-7-2-上下文无关文法中的ε规则" class="headerlink" title="2.7.2 上下文无关文法中的ε规则"></a>2.7.2 上下文无关文法中的ε规则</h3><p>具有形式A→ε的规则称为ε规则，其中A∈VN</p>
<p>某些著作和讲义中限制这种规则的出现。因为ε规则会使有关文法的一些讨论和证明变得复杂</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://artemisaturn.github.io/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Daphne Wang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">编译原理（1）编译概述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-31 11:05:01" itemprop="dateCreated datePublished" datetime="2020-05-31T11:05:01+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-01 09:00:35" itemprop="dateModified" datetime="2020-08-01T09:00:35+08:00">2020-08-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h3 id="1-1-程序设计语言"><a href="#1-1-程序设计语言" class="headerlink" title="1.1 程序设计语言"></a>1.1 程序设计语言</h3><p>Machine Code</p>
<p>Assembly Language</p>
<p>High-level Language</p>
<p>如Algol, Fortran, Pascal, C语言等。</p>
<h3 id="1-2-什么叫编译程序"><a href="#1-2-什么叫编译程序" class="headerlink" title="1.2 什么叫编译程序"></a>1.2 什么叫编译程序</h3><p>翻译程序：就是将源程序转换成目标程序的程序。</p>
<p>source program —–&gt;  Translator  ——&gt;  target program</p>
<p>翻译程序和解释程序的区别：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" alt="1"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531170908968.png" class="" title="This is image1">

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解释方式最终不生成目标程序，这是编译方式和解释方式的根本区别。</span><br><span class="line">编译方式：是将源程序经编译得到可执行文件后，就可脱离源程序和编译程序单独执行，所以编译方式的效率高，执行速度快；</span><br><span class="line">解释方式：在执行时，必须源程序和解释程序同时参与才能运行，其不产生可执行程序文件，效率低，执行速度慢。</span><br></pre></td></tr></table></figure>

<p>编译程序和汇编程序的区别：</p>
<p>​        如果源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，这样的一个翻译程序称为编译程序。如果源语言是汇编语言，而目标语言是机器语言，这样的一个翻译程序称为汇编程序。</p>
<p>解释性语言：</p>
<p>（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行：  源代码—&gt;中间代码—&gt;机器语言</p>
<p>（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；</p>
<p>（3）解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；</p>
<p>（4）运行效率一般相对比较低，依赖解释器，跨平台性好；</p>
<p>（5）Java是编译性-解释性语言，因为其同时具备编译性和解释性两种特性。</p>
<h3 id="1-3-编译程序的组成"><a href="#1-3-编译程序的组成" class="headerlink" title="1.3 编译程序的组成"></a>1.3 编译程序的组成</h3><p>一个典型的编译程序应具有以下的组成：</p>
<p><img src="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" alt="2"></p>
<img src="/2020/05/31/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%EF%BC%881%EF%BC%89%E7%BC%96%E8%AF%91%E6%A6%82%E8%BF%B0/image-20200531200636454.png" class="" title="This is image2">

<p>编译程序的两个主要任务：</p>
<p>一是分析，二是综合。</p>
<p>编译程序结构(components)</p>
<ul>
<li>词法分析程序</li>
<li>语法分析程序</li>
<li>语义分析程序</li>
<li>中间代码生成程序</li>
<li>代码优化程序</li>
<li>目标代码生成程序</li>
<li>符号表管理程序</li>
<li>出错处理程序</li>
</ul>
<p>（1）Scanner （词法分析）</p>
<p>任务：识别单词符号，是最初级的语法分析。</p>
<p>依循的规则：语言的构词规则。</p>
<p>（2）Parser （语法分析）</p>
<p>任务∶对词法分析的输出即单词符号串进行分析，识别出一个个语法成分，并进行语法检查。</p>
<p>依循的规则：语法规则。</p>
<p>（语法单位：算术表达式、短语、句子、子程序……）</p>
<p>（3）Semantic Analyzer （语义分析）</p>
<p>任务：对语法分析所识别的各种语法成分的意义(即语义)进行确定并加以处理。</p>
<p>依循的规则：语义规则</p>
<p>（4）Intermediate Code Generator</p>
<p>任务：从源程序的树形或其它形式，产生源程序的中间代码。</p>
<p>中间代码：四元式、三元式……</p>
<p>（5）Target Code Generator</p>
<p>任务：将中间代码转换成汇编程序或者机器语言。</p>
<p>（6）代码优化</p>
<p>代码优化程序的功能是将中间代码中重复和冗余部分进行优化，提高目标程序的执行效率。</p>
<p>（7）符号表管理</p>
<ul>
<li>符号表管理是一个贯穿编译全过程的工作。</li>
<li>编译程序在分析源程序时，需要记录标识符的各种属性信息；</li>
<li>在语义分析和代码生成阶段，还要对建立的符号表进行检索，提取相应的属性信息。–类型、作用域、分配存储信息</li>
</ul>
<p>（8）Error Handler （错误检测及处理）</p>
<ul>
<li>错误可发生在编译的各个阶段，错误处理也是贯穿编译全过程。</li>
<li>词法分析阶段可查出的错误，如标识符的组成不符合词法规则； </li>
<li>语句结构错误是在语法分析中可查出的错误；</li>
<li>语义分析阶段可查出的错误，即结构正确，但所涉及的操作无意义或错误。</li>
<li>在编译时查出的，叫Comple-time error，在运行时表现才表现出来的错误叫Run-time error。</li>
</ul>
<p>（9）前端和后端</p>
<ul>
<li>前端包括编译逻辑结构中的分析部分，即词法分析、语法分析、语义分析和中间代码生成，除此还包括符号表建造及相应分析中的错误处理以及与机器无关的优化部分。</li>
<li>后端包括与目标机有关的部分，即综合部分，它包括目标代码生成及生成期间对符号表的相应检索操作和错误处理操作，以及与机器相关的代码优化部分。</li>
<li>将编译系统划分为前后端，有利于移植编译系统和利用后端为同一目标机配置不同语言的编译系统。</li>
</ul>
<p>（10）遍（pass）</p>
<p>​        对源程序(或其中间形式)从头至尾扫描一次并进行有关加工处理，生成新的中间形式或最终目标程序，称为一遍。</p>
<p>分遍原则∶</p>
<ul>
<li>目标质量高低(高则多遍) </li>
<li>机器内存大小(小则多遍)</li>
<li>源语言简繁(繁则多遍)</li>
<li>设计人员多少(多则多遍)</li>
</ul>
<p>多遍扫描编译程序的优缺点∶</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：（1）可以减少内存容量的需求，分便后，以遍为单位分别调用编译的各个子程序，各遍程序可以相互覆盖；</span><br><span class="line">（2）可使各遍的编译程序相互独立，结构清晰；</span><br><span class="line">（3）能够进行充分的优化，产生高质量的目标程序；</span><br><span class="line">（4）可将编译程序分为“前端”和“后端”，有利于编译程序的移植。</span><br><span class="line">缺点：每遍都要读符号、送符号，增加了许多重复性工作，降低了编译效率。</span><br></pre></td></tr></table></figure>

<h3 id="1-4-编译程序的生成"><a href="#1-4-编译程序的生成" class="headerlink" title="1.4 编译程序的生成"></a>1.4 编译程序的生成</h3><p><strong>实现工具：</strong>Low-level Language；</p>
<p>​                   High-level Language；</p>
<p>​                   Automatic Builder。</p>
<p><strong>生成方法：</strong>Self-compiler;</p>
<p>​                   transplant</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Daphne Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daphne Wang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
